
lcd_nios.elf:     file format elf32-littlenios2
lcd_nios.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x040001b4

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x04000020 paddr 0x04000020 align 2**12
         filesz 0x000094a4 memsz 0x000097a0 flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000194  04000020  04000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         00007490  040001b4  040001b4  000011b4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000770  04007644  04007644  00008644  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00001710  04007db4  04007db4  00008db4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000002fc  040094c4  040094c4  0000a4c4  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000026  00000000  00000000  0000a4c4  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 000007b0  00000000  00000000  0000a4f0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00000e62  00000000  00000000  0000aca0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0000ec89  00000000  00000000  0000bb02  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 0000400a  00000000  00000000  0001a78b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000a226  00000000  00000000  0001e795  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00001160  00000000  00000000  000289bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00000fd5  00000000  00000000  00029b1c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00002854  00000000  00000000  0002aaf1  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000040  00000000  00000000  0002d348  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000230  00000000  00000000  0002d388  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0002fa9c  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0002fa9f  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0002faa2  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0002faa3  2**0
                  CONTENTS, READONLY
 21 .sysid_hash   00000004  00000000  00000000  0002faa4  2**0
                  CONTENTS, READONLY
 22 .sysid_base   00000004  00000000  00000000  0002faa8  2**0
                  CONTENTS, READONLY
 23 .sysid_time   00000004  00000000  00000000  0002faac  2**0
                  CONTENTS, READONLY
 24 .stderr_dev   00000009  00000000  00000000  0002fab0  2**0
                  CONTENTS, READONLY
 25 .stdin_dev    00000009  00000000  00000000  0002fab9  2**0
                  CONTENTS, READONLY
 26 .stdout_dev   00000009  00000000  00000000  0002fac2  2**0
                  CONTENTS, READONLY
 27 .sopc_system_name 00000004  00000000  00000000  0002facb  2**0
                  CONTENTS, READONLY
 28 .quartus_project_dir 00000010  00000000  00000000  0002facf  2**0
                  CONTENTS, READONLY
 29 .jdi          000045f9  00000000  00000000  0002fadf  2**0
                  CONTENTS, READONLY
 30 .sopcinfo     0007d2cc  00000000  00000000  000340d8  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
04000020 l    d  .exceptions	00000000 .exceptions
040001b4 l    d  .text	00000000 .text
04007644 l    d  .rodata	00000000 .rodata
04007db4 l    d  .rwdata	00000000 .rwdata
040094c4 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
040001e8 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 AsciiLib.c
04007644 l     O .rodata	000005f0 AsciiLib
00000000 l    df *ABS*	00000000 LCD32.c
040094c4 l     O .bss	00000001 LCD_Code
00000000 l    df *ABS*	00000000 main.c
00000000 l    df *ABS*	00000000 touch.c
040094c6 l     O .bss	00000004 screen.1908
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
04002a00 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
04007dc0 l     O .rwdata	000000c8 epcs
04007e88 l     O .rwdata	00001060 jtag_uart
04004074 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
04004138 l     F .text	00000288 alt_epcs_flash_query
04004100 l     F .text	00000038 alt_flash_device_register
040043c0 l     F .text	00000108 alt_epcs_flash_memcmp
04004848 l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
04004c98 l     F .text	00000228 altera_avalon_jtag_uart_irq
04004ec0 l     F .text	000000b0 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 epcs_commands.c
040058cc l     F .text	00000038 epcs_await_wip_released
04005904 l     F .text	00000038 epcs_test_wip
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_close.c
040061e4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
04006244 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
04006324 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
040067e8 l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
04006924 l     F .text	000000dc alt_file_locked
04006b88 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 impure.c
04009090 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
040072e0 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 lib2-divmod.c
04007494 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 alt_exit.c
040075e0 l     F .text	00000040 alt_sim_halt
04004748 g     F .text	00000090 alt_epcs_flash_get_info
04003f54 g     F .text	0000006c alt_main
04009530 g     O .bss	00000100 alt_irq
04003520 g     F .text	00000088 __eqdf2
04000304 g     F .text	00000078 LCD_ReadData
040013d0 g     F .text	000000c8 GUI_Text
00000000  w      *UND*	00000000 __errno
040057d4 g     F .text	000000f8 epcs_sector_erase
00000000 g     F .entry	00000000 __reset
04000bcc g     F .text	00000104 LCD_Clear
0400154c g     F .text	00000030 TP_Init
040094e8 g     O .bss	00000004 errno
040094d4 g     O .bss	00000004 alt_argv
04011490 g       *ABS*	00000000 _gp
04003fc0 g     F .text	00000030 usleep
04008f10 g     O .rwdata	00000180 alt_fd_list
04000548 g     F .text	00000684 LCD_Initializtion
04005ad8 g     F .text	00000064 epcs_write_status_register
04006e0c g     F .text	00000094 alt_find_dev
04003eb4 g     F .text	000000a0 memcpy
040036b8 g     F .text	000000f8 __floatsidf
040068ac g     F .text	00000078 alt_io_redirect
04007644 g       *ABS*	00000000 __DTOR_END__
040048dc g     F .text	0000011c alt_epcs_flash_write_block
040001ec g     F .text	00000060 GetASCIICode
040050d8 g     F .text	00000224 altera_avalon_jtag_uart_read
04001048 g     F .text	00000274 LCD_DrawLine
00000000  w      *UND*	00000000 malloc
040075d0 g     F .text	00000008 __udivsi3
0400295c g     F .text	000000a4 __fixunsdfsi
040094a0 g     O .rwdata	00000004 alt_max_fd
04003cb4 g     F .text	00000138 __unpack_d
04002e90 g     F .text	00000074 __adddf3
040047d8 g     F .text	00000070 alt_epcs_flash_erase_block
040094c0 g     O .rwdata	00000004 _global_impure_ptr
04005df0 g     F .text	00000058 epcs_exit_4_bytes_mode
040097c0 g       *ABS*	00000000 __bss_end
040066f0 g     F .text	000000f8 alt_iic_isr_register
040094ca g     O .bss	00000004 display
04006ce0 g     F .text	0000010c alt_tick
0400157c g     F .text	00000030 DelayUS
0400186c g     F .text	000002dc DrawCross
040066a8 g     F .text	00000048 alt_ic_irq_enabled
04000fe4 g     F .text	00000064 LCD_SetPoint
04006c48 g     F .text	00000098 alt_alarm_stop
040094dc g     O .bss	00000004 alt_irq_active
040000ec g     F .exceptions	000000c8 alt_irq_handler
04008ee8 g     O .rwdata	00000028 alt_dev_null
040037b0 g     F .text	000000d8 __fixdfsi
04002530 g     F .text	000002e8 getDisplayPoint
04000cd0 g     F .text	00000128 LCD_show_test
04009498 g     O .rwdata	00000008 alt_dev_list
040075d8 g     F .text	00000008 __umodsi3
04001718 g     F .text	0000005c Read_Y
04005cac g     F .text	0000006c epcs_read_electronic_signature
040097c0 g       *ABS*	00000000 end
04004bd8 g     F .text	000000c0 altera_avalon_jtag_uart_init
04007640 g       *ABS*	00000000 __CTOR_LIST__
06000000 g       *ABS*	00000000 __alt_stack_pointer
04003920 g     F .text	00000080 __clzsi2
040052fc g     F .text	00000240 altera_avalon_jtag_uart_write
04001774 g     F .text	0000005c TP_GetAdXY
040015ac g     F .text	0000004c WR_CMD
0400041c g     F .text	0000012c LCD_SetCursor
040072e4 g     F .text	000001b0 __call_exitprocs
040001b4 g     F .text	00000038 _start
040094e0 g     O .bss	00000004 _alt_tick_rate
0400553c g     F .text	00000238 alt_avalon_spi_command
040094e4 g     O .bss	00000004 _alt_nticks
04004024 g     F .text	00000050 alt_sys_init
04002818 g     F .text	00000144 TouchPanel_Calibrate
040071ac g     F .text	00000134 __register_exitproc
04004f70 g     F .text	00000074 altera_avalon_jtag_uart_close
04005774 g     F .text	00000060 epcs_read_status_register
04004a90 g     F .text	00000058 altera_avalon_jtag_uart_read_fd
04006fc0 g     F .text	000000b8 alt_get_fd
04005f9c g     F .text	0000014c alt_busy_sleep
0400024c g     F .text	00000060 LCD_WriteIndex
04003dec g     F .text	000000c8 __fpcmp_parts_d
04005d18 g     F .text	00000080 epcs_read_device_id
040070c4 g     F .text	00000074 memcmp
04004b40 g     F .text	00000048 altera_avalon_jtag_uart_close_fd
040097c0 g       *ABS*	00000000 __alt_stack_base
04004b88 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
040032c8 g     F .text	00000258 __divdf3
04002f04 g     F .text	000003c4 __muldf3
040094ec g     O .bss	0000000c ScreenSample
04006ea0 g     F .text	00000120 alt_find_file
04006270 g     F .text	000000b4 alt_dev_llist_insert
040094a8 g     O .rwdata	00000008 alt_flash_dev_list
040094c4 g       *ABS*	00000000 __bss_start
04001498 g     F .text	000000b4 main
040094d8 g     O .bss	00000004 alt_envp
04004ae8 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
04009630 g     O .bss	00000190 _atexit0
040094a4 g     O .rwdata	00000004 alt_errno
040094f8 g     O .bss	00000038 matrix
04007db4 g     O .rwdata	0000000c DisplaySample
04007510 g     F .text	00000060 __divsi3
04007c64 g     O .rodata	00000014 __thenan_df
04007644 g       *ABS*	00000000 __CTOR_END__
040044c8 g     F .text	00000280 alt_epcs_flash_write
04007644 g       *ABS*	00000000 __DTOR_LIST__
040035a8 g     F .text	00000088 __nedf2
04003ff0 g     F .text	00000034 alt_irq_init
04006be8 g     F .text	00000060 alt_release_fd
04007c78 g     O .rodata	00000100 __clz_tab
04007078 g     F .text	00000014 atexit
0400037c g     F .text	00000050 LCD_WriteReg
040012bc g     F .text	00000114 PutChar
040094bc g     O .rwdata	00000004 _impure_ptr
040094d0 g     O .bss	00000004 alt_argc
040063e8 g     F .text	00000064 _do_dtors
04000020 g       .exceptions	00000000 alt_irq_entry
040002ac g     F .text	00000058 LCD_WriteData
04009490 g     O .rwdata	00000008 alt_fs_list
040017d0 g     F .text	0000009c TP_DrawPoint
0400593c g     F .text	0000014c epcs_read_buffer
040040ac g     F .text	00000054 alt_epcs_flash_init
0400651c g     F .text	00000050 alt_ic_isr_register
040016bc g     F .text	0000005c Read_X
040094c4 g       *ABS*	00000000 _edata
040097c0 g       *ABS*	00000000 _end
0400644c g     F .text	0000007c alt_flash_open_dev
04004fe4 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
04001f0c g     F .text	00000624 setCalibrationMatrix
04006608 g     F .text	000000a0 alt_ic_irq_disable
04005d98 g     F .text	00000058 epcs_enter_4_bytes_mode
04006dec g     F .text	00000020 altera_nios2_qsys_irq_init
04007c34 g     O .rodata	00000010 colorfol1
0400708c g     F .text	00000038 exit
040064c8 g     F .text	00000054 alt_flash_close_dev
04007570 g     F .text	00000060 __modsi3
040015f8 g     F .text	000000c4 RD_AD
06000000 g       *ABS*	00000000 __alt_data_end
04000020 g     F .exceptions	00000000 alt_exception
04000e70 g     F .text	00000174 LCD_GetPoint
04000000 g       *ABS*	00000000 __alt_mem_sdram
04007620 g     F .text	00000020 _exit
04005e48 g     F .text	00000154 alt_alarm_start
04003888 g     F .text	00000098 __muldi3
04007138 g     F .text	00000074 strlen
04005a88 g     F .text	00000050 epcs_write_enable
04006a00 g     F .text	00000188 open
04003630 g     F .text	00000088 __gedf2
04001b48 g     F .text	000003c4 Read_Ads7846
040094b0 g     O .rwdata	00000004 alt_priority_mask
0400656c g     F .text	0000009c alt_ic_irq_enable
00000000 g       *ABS*	00000000 __alt_mem_epcs
04002e10 g     F .text	00000080 __subdf3
040049f8 g     F .text	00000098 alt_epcs_flash_read
040094b4 g     O .rwdata	00000008 alt_alarm_list
04006384 g     F .text	00000064 _do_ctors
040060e8 g     F .text	000000fc close
040003cc g     F .text	00000050 LCD_ReadReg
040039a0 g     F .text	00000314 __pack_d
04000df8 g     F .text	00000078 LCD_BGR2RGB
00000000  w      *UND*	00000000 free
04005b3c g     F .text	00000170 epcs_write_buffer



Disassembly of section .exceptions:

04000020 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 4000020:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 4000024:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 4000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 400002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 4000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 4000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 4000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 400003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 4000040:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 4000044:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 4000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 400004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 4000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 4000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 4000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 400005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 4000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 4000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 4000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 400006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 4000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 4000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 4000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 400007c:	10000326 	beq	r2,zero,400008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 4000080:	20000226 	beq	r4,zero,400008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 4000084:	40000ec0 	call	40000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 4000088:	00000306 	br	4000098 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 400008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 4000090:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 4000094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 4000098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 400009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 40000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 40000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 40000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 40000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 40000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 40000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 40000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 40000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 40000c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 40000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 40000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 40000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 40000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 40000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 40000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 40000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 40000e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 40000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 40000e8:	ef80083a 	eret

040000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 40000ec:	defff904 	addi	sp,sp,-28
 40000f0:	dfc00615 	stw	ra,24(sp)
 40000f4:	df000515 	stw	fp,20(sp)
 40000f8:	df000504 	addi	fp,sp,20
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 40000fc:	0005313a 	rdctl	r2,ipending
 4000100:	e0bffc15 	stw	r2,-16(fp)

  return active;
 4000104:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 4000108:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 400010c:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 4000110:	00800044 	movi	r2,1
 4000114:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 4000118:	e0ffff17 	ldw	r3,-4(fp)
 400011c:	e0bffe17 	ldw	r2,-8(fp)
 4000120:	1884703a 	and	r2,r3,r2
 4000124:	1005003a 	cmpeq	r2,r2,zero
 4000128:	1000161e 	bne	r2,zero,4000184 <alt_irq_handler+0x98>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 400012c:	e0bffd17 	ldw	r2,-12(fp)
 4000130:	00c10074 	movhi	r3,1025
 4000134:	18e54c04 	addi	r3,r3,-27344
 4000138:	100490fa 	slli	r2,r2,3
 400013c:	10c5883a 	add	r2,r2,r3
 4000140:	11400017 	ldw	r5,0(r2)
 4000144:	e0bffd17 	ldw	r2,-12(fp)
 4000148:	00c10074 	movhi	r3,1025
 400014c:	18e54c04 	addi	r3,r3,-27344
 4000150:	100490fa 	slli	r2,r2,3
 4000154:	10c5883a 	add	r2,r2,r3
 4000158:	10800104 	addi	r2,r2,4
 400015c:	11000017 	ldw	r4,0(r2)
 4000160:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 4000164:	0005313a 	rdctl	r2,ipending
 4000168:	e0bffb15 	stw	r2,-20(fp)

  return active;
 400016c:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 4000170:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 4000174:	e0bfff17 	ldw	r2,-4(fp)
 4000178:	1004c03a 	cmpne	r2,r2,zero
 400017c:	103fe31e 	bne	r2,zero,400010c <alt_irq_handler+0x20>
 4000180:	00000706 	br	40001a0 <alt_irq_handler+0xb4>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 4000184:	e0bffe17 	ldw	r2,-8(fp)
 4000188:	1085883a 	add	r2,r2,r2
 400018c:	e0bffe15 	stw	r2,-8(fp)
      i++;
 4000190:	e0bffd17 	ldw	r2,-12(fp)
 4000194:	10800044 	addi	r2,r2,1
 4000198:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 400019c:	003fde06 	br	4000118 <alt_irq_handler+0x2c>
  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
}
 40001a0:	e037883a 	mov	sp,fp
 40001a4:	dfc00117 	ldw	ra,4(sp)
 40001a8:	df000017 	ldw	fp,0(sp)
 40001ac:	dec00204 	addi	sp,sp,8
 40001b0:	f800283a 	ret

Disassembly of section .text:

040001b4 <_start>:
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 40001b4:	06c18034 	movhi	sp,1536
    ori sp, sp, %lo(__alt_stack_pointer)
 40001b8:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 40001bc:	06810074 	movhi	gp,1025
    ori gp, gp, %lo(_gp)
 40001c0:	d6852414 	ori	gp,gp,5264
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 40001c4:	00810034 	movhi	r2,1024
    ori r2, r2, %lo(__bss_start)
 40001c8:	10a53114 	ori	r2,r2,38084

    movhi r3, %hi(__bss_end)
 40001cc:	00c10034 	movhi	r3,1024
    ori r3, r3, %lo(__bss_end)
 40001d0:	18e5f014 	ori	r3,r3,38848

    beq r2, r3, 1f
 40001d4:	10c00326 	beq	r2,r3,40001e4 <_start+0x30>

0:
    stw zero, (r2)
 40001d8:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 40001dc:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 40001e0:	10fffd36 	bltu	r2,r3,40001d8 <_start+0x24>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 40001e4:	4003f540 	call	4003f54 <alt_main>

040001e8 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 40001e8:	003fff06 	br	40001e8 <alt_after_alt_main>

040001ec <GetASCIICode>:
* Output         : 
* Return         : None
* Attention      : None
*******************************************************************************/
void GetASCIICode(unsigned char* pBuffer,unsigned char ASCII)
{  
 40001ec:	defffc04 	addi	sp,sp,-16
 40001f0:	dfc00315 	stw	ra,12(sp)
 40001f4:	df000215 	stw	fp,8(sp)
 40001f8:	df000204 	addi	fp,sp,8
 40001fc:	e13ffe15 	stw	r4,-8(fp)
 4000200:	e17fff05 	stb	r5,-4(fp)
   memcpy(pBuffer,AsciiLib[(ASCII - 32)] ,16);
 4000204:	e0bfff03 	ldbu	r2,-4(fp)
 4000208:	1004913a 	slli	r2,r2,4
 400020c:	1007883a 	mov	r3,r2
 4000210:	00810034 	movhi	r2,1024
 4000214:	109d9104 	addi	r2,r2,30276
 4000218:	10bf8004 	addi	r2,r2,-512
 400021c:	1885883a 	add	r2,r3,r2
 4000220:	1007883a 	mov	r3,r2
 4000224:	e0bffe17 	ldw	r2,-8(fp)
 4000228:	1009883a 	mov	r4,r2
 400022c:	180b883a 	mov	r5,r3
 4000230:	01800404 	movi	r6,16
 4000234:	4003eb40 	call	4003eb4 <memcpy>
}
 4000238:	e037883a 	mov	sp,fp
 400023c:	dfc00117 	ldw	ra,4(sp)
 4000240:	df000017 	ldw	fp,0(sp)
 4000244:	dec00204 	addi	sp,sp,8
 4000248:	f800283a 	ret

0400024c <LCD_WriteIndex>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
__inline void LCD_WriteIndex(alt_u16 index)
{
 400024c:	defffe04 	addi	sp,sp,-8
 4000250:	df000115 	stw	fp,4(sp)
 4000254:	df000104 	addi	fp,sp,4
 4000258:	e13fff0d 	sth	r4,-4(fp)
    Clr_Rs;
 400025c:	00862c04 	movi	r2,6320
 4000260:	10000035 	stwio	zero,0(r2)
    Set_nRd;
 4000264:	00c61804 	movi	r3,6240
 4000268:	00800044 	movi	r2,1
 400026c:	18800035 	stwio	r2,0(r3)
    
    IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD32_DATA_BASE, 0XFFFF) ;  /* GPIO_Write(GPIOE,index); */
 4000270:	00c61d04 	movi	r3,6260
 4000274:	00bfffd4 	movui	r2,65535
 4000278:	18800035 	stwio	r2,0(r3)
    IOWR_ALTERA_AVALON_PIO_DATA(LCD32_DATA_BASE, index);
 400027c:	e0ffff0b 	ldhu	r3,-4(fp)
 4000280:	00861c04 	movi	r2,6256
 4000284:	10c00035 	stwio	r3,0(r2)
    
    Clr_nWr;
 4000288:	00862004 	movi	r2,6272
 400028c:	10000035 	stwio	zero,0(r2)
    Set_nWr;
 4000290:	00c62004 	movi	r3,6272
 4000294:	00800044 	movi	r2,1
 4000298:	18800035 	stwio	r2,0(r3)
}
 400029c:	e037883a 	mov	sp,fp
 40002a0:	df000017 	ldw	fp,0(sp)
 40002a4:	dec00104 	addi	sp,sp,4
 40002a8:	f800283a 	ret

040002ac <LCD_WriteData>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
__inline void LCD_WriteData(alt_u16 data)
{
 40002ac:	defffe04 	addi	sp,sp,-8
 40002b0:	df000115 	stw	fp,4(sp)
 40002b4:	df000104 	addi	fp,sp,4
 40002b8:	e13fff0d 	sth	r4,-4(fp)
    Set_Rs;
 40002bc:	00c62c04 	movi	r3,6320
 40002c0:	00800044 	movi	r2,1
 40002c4:	18800035 	stwio	r2,0(r3)
    
    IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD32_DATA_BASE, 0XFFFF) ;  /* GPIO_Write(GPIOE,index); */
 40002c8:	00c61d04 	movi	r3,6260
 40002cc:	00bfffd4 	movui	r2,65535
 40002d0:	18800035 	stwio	r2,0(r3)
    IOWR_ALTERA_AVALON_PIO_DATA(LCD32_DATA_BASE, data);
 40002d4:	e0ffff0b 	ldhu	r3,-4(fp)
 40002d8:	00861c04 	movi	r2,6256
 40002dc:	10c00035 	stwio	r3,0(r2)
    
    Clr_nWr;
 40002e0:	00862004 	movi	r2,6272
 40002e4:	10000035 	stwio	zero,0(r2)
    Set_nWr;
 40002e8:	00c62004 	movi	r3,6272
 40002ec:	00800044 	movi	r2,1
 40002f0:	18800035 	stwio	r2,0(r3)
}
 40002f4:	e037883a 	mov	sp,fp
 40002f8:	df000017 	ldw	fp,0(sp)
 40002fc:	dec00104 	addi	sp,sp,4
 4000300:	f800283a 	ret

04000304 <LCD_ReadData>:
* Output         : None
* Return         : 
* Attention      : None
*******************************************************************************/
__inline alt_u16 LCD_ReadData(void)
{
 4000304:	defffe04 	addi	sp,sp,-8
 4000308:	df000115 	stw	fp,4(sp)
 400030c:	df000104 	addi	fp,sp,4
    alt_u16 value;

    Set_Rs;
 4000310:	00c62c04 	movi	r3,6320
 4000314:	00800044 	movi	r2,1
 4000318:	18800035 	stwio	r2,0(r3)
    Set_nWr;
 400031c:	00c62004 	movi	r3,6272
 4000320:	00800044 	movi	r2,1
 4000324:	18800035 	stwio	r2,0(r3)
    Clr_nRd;
 4000328:	00861804 	movi	r2,6240
 400032c:	10000035 	stwio	zero,0(r2)
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_All;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init(GPIOE, &GPIO_InitStructure);
*/
    IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD32_DATA_BASE, 0X0000) ;  /* GPIO_Write(GPIOE,index); */
 4000330:	00861d04 	movi	r2,6260
 4000334:	10000035 	stwio	zero,0(r2)
    value=IORD_ALTERA_AVALON_PIO_DATA(LCD32_DATA_BASE);
 4000338:	00861c04 	movi	r2,6256
 400033c:	10800037 	ldwio	r2,0(r2)
 4000340:	e0bfff0d 	sth	r2,-4(fp)
     value=IORD_ALTERA_AVALON_PIO_DATA(LCD32_DATA_BASE);
 4000344:	00861c04 	movi	r2,6256
 4000348:	10800037 	ldwio	r2,0(r2)
 400034c:	e0bfff0d 	sth	r2,-4(fp)
    
    IOWR_ALTERA_AVALON_PIO_DIRECTION(LCD32_DATA_BASE, 0XFFFF) ;
 4000350:	00c61d04 	movi	r3,6260
 4000354:	00bfffd4 	movui	r2,65535
 4000358:	18800035 	stwio	r2,0(r3)

    Set_nRd;
 400035c:	00c61804 	movi	r3,6240
 4000360:	00800044 	movi	r2,1
 4000364:	18800035 	stwio	r2,0(r3)

    return value;
 4000368:	e0bfff0b 	ldhu	r2,-4(fp)
}
 400036c:	e037883a 	mov	sp,fp
 4000370:	df000017 	ldw	fp,0(sp)
 4000374:	dec00104 	addi	sp,sp,4
 4000378:	f800283a 	ret

0400037c <LCD_WriteReg>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
__inline void LCD_WriteReg(alt_u16 LCD_Reg,alt_u16 LCD_RegValue)
{ 
 400037c:	defffc04 	addi	sp,sp,-16
 4000380:	dfc00315 	stw	ra,12(sp)
 4000384:	df000215 	stw	fp,8(sp)
 4000388:	df000204 	addi	fp,sp,8
 400038c:	e13ffe0d 	sth	r4,-8(fp)
 4000390:	e17fff0d 	sth	r5,-4(fp)
    /* Write 16-bit Index, then Write Reg */  
    Clr_Cs;
 4000394:	00863404 	movi	r2,6352
 4000398:	10000035 	stwio	zero,0(r2)
    LCD_WriteIndex(LCD_Reg);         
 400039c:	e13ffe0b 	ldhu	r4,-8(fp)
 40003a0:	400024c0 	call	400024c <LCD_WriteIndex>
    /* Write 16-bit Reg */
    LCD_WriteData(LCD_RegValue);  
 40003a4:	e13fff0b 	ldhu	r4,-4(fp)
 40003a8:	40002ac0 	call	40002ac <LCD_WriteData>
    Set_Cs; 
 40003ac:	00c63404 	movi	r3,6352
 40003b0:	00800044 	movi	r2,1
 40003b4:	18800035 	stwio	r2,0(r3)
}
 40003b8:	e037883a 	mov	sp,fp
 40003bc:	dfc00117 	ldw	ra,4(sp)
 40003c0:	df000017 	ldw	fp,0(sp)
 40003c4:	dec00204 	addi	sp,sp,8
 40003c8:	f800283a 	ret

040003cc <LCD_ReadReg>:
* Output         : None
* Return         : LCD Register Value.
* Attention      : None
*******************************************************************************/
__inline alt_u16 LCD_ReadReg(alt_u16 LCD_Reg)
{
 40003cc:	defffc04 	addi	sp,sp,-16
 40003d0:	dfc00315 	stw	ra,12(sp)
 40003d4:	df000215 	stw	fp,8(sp)
 40003d8:	df000204 	addi	fp,sp,8
 40003dc:	e13fff0d 	sth	r4,-4(fp)
    alt_u16 LCD_RAM;
    
    /* Write 16-bit Index (then Read Reg) */
    Clr_Cs;
 40003e0:	00863404 	movi	r2,6352
 40003e4:	10000035 	stwio	zero,0(r2)
    LCD_WriteIndex(LCD_Reg);
 40003e8:	e13fff0b 	ldhu	r4,-4(fp)
 40003ec:	400024c0 	call	400024c <LCD_WriteIndex>
    /* Read 16-bit Reg */
    LCD_RAM = LCD_ReadData();       
 40003f0:	40003040 	call	4000304 <LCD_ReadData>
 40003f4:	e0bffe0d 	sth	r2,-8(fp)
    Set_Cs;
 40003f8:	00c63404 	movi	r3,6352
 40003fc:	00800044 	movi	r2,1
 4000400:	18800035 	stwio	r2,0(r3)
    return LCD_RAM;
 4000404:	e0bffe0b 	ldhu	r2,-8(fp)
}
 4000408:	e037883a 	mov	sp,fp
 400040c:	dfc00117 	ldw	ra,4(sp)
 4000410:	df000017 	ldw	fp,0(sp)
 4000414:	dec00204 	addi	sp,sp,8
 4000418:	f800283a 	ret

0400041c <LCD_SetCursor>:

      

void LCD_SetCursor( alt_u16 Xpos, alt_u16 Ypos )
{
 400041c:	defffa04 	addi	sp,sp,-24
 4000420:	dfc00515 	stw	ra,20(sp)
 4000424:	df000415 	stw	fp,16(sp)
 4000428:	df000404 	addi	fp,sp,16
 400042c:	e13ffd0d 	sth	r4,-12(fp)
 4000430:	e17ffe0d 	sth	r5,-8(fp)
    #if  ( DISP_ORIENTATION == 90 ) || ( DISP_ORIENTATION == 270 )
    
    alt_u16 temp = Xpos;
 4000434:	e0bffd0b 	ldhu	r2,-12(fp)
 4000438:	e0bffc0d 	sth	r2,-16(fp)

             Xpos = Ypos;
 400043c:	e0bffe0b 	ldhu	r2,-8(fp)
 4000440:	e0bffd0d 	sth	r2,-12(fp)
             Ypos = ( MAX_X - 1 ) - temp;  
 4000444:	e0fffc0b 	ldhu	r3,-16(fp)
 4000448:	00804fc4 	movi	r2,319
 400044c:	10c5c83a 	sub	r2,r2,r3
 4000450:	e0bffe0d 	sth	r2,-8(fp)

    #elif  ( DISP_ORIENTATION == 0 ) || ( DISP_ORIENTATION == 180 )
        
    #endif

  switch( LCD_Code )
 4000454:	d0a00d03 	ldbu	r2,-32716(gp)
 4000458:	10803fcc 	andi	r2,r2,255
 400045c:	10bfff04 	addi	r2,r2,-4
 4000460:	e0bfff15 	stw	r2,-4(fp)
 4000464:	e0ffff17 	ldw	r3,-4(fp)
 4000468:	188002a8 	cmpgeui	r2,r3,10
 400046c:	1000131e 	bne	r2,zero,40004bc <LCD_SetCursor+0xa0>
 4000470:	e13fff17 	ldw	r4,-4(fp)
 4000474:	e13fff17 	ldw	r4,-4(fp)
 4000478:	2105883a 	add	r2,r4,r4
 400047c:	1087883a 	add	r3,r2,r2
 4000480:	00810034 	movhi	r2,1024
 4000484:	10812504 	addi	r2,r2,1172
 4000488:	1885883a 	add	r2,r3,r2
 400048c:	10800017 	ldw	r2,0(r2)
 4000490:	1000683a 	jmp	r2
 4000494:	040004d8 	cmpnei	r16,zero,19
 4000498:	040004d8 	cmpnei	r16,zero,19
 400049c:	040004bc 	xorhi	r16,zero,18
 40004a0:	040004bc 	xorhi	r16,zero,18
 40004a4:	040004bc 	xorhi	r16,zero,18
 40004a8:	040004bc 	xorhi	r16,zero,18
 40004ac:	040004f4 	movhi	r16,19
 40004b0:	040004f4 	movhi	r16,19
 40004b4:	040004bc 	xorhi	r16,zero,18
 40004b8:	04000534 	movhi	r16,20
  {
     default:        /* 0x9320 0x9325 0x9328 0x9331 0x5408 0x1505 0x0505 0x7783 0x4531 0x4535 */
          LCD_WriteReg(0x0020, Xpos );     
 40004bc:	e17ffd0b 	ldhu	r5,-12(fp)
 40004c0:	01000804 	movi	r4,32
 40004c4:	400037c0 	call	400037c <LCD_WriteReg>
          LCD_WriteReg(0x0021, Ypos );     
 40004c8:	e17ffe0b 	ldhu	r5,-8(fp)
 40004cc:	01000844 	movi	r4,33
 40004d0:	400037c0 	call	400037c <LCD_WriteReg>
          break; 
 40004d4:	00001706 	br	4000534 <LCD_SetCursor+0x118>

     case SSD1298:   /* 0x8999 */
     case SSD1289:   /* 0x8989 */
          LCD_WriteReg(0x004e, Xpos );      
 40004d8:	e17ffd0b 	ldhu	r5,-12(fp)
 40004dc:	01001384 	movi	r4,78
 40004e0:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x004f, Ypos );          
 40004e4:	e17ffe0b 	ldhu	r5,-8(fp)
 40004e8:	010013c4 	movi	r4,79
 40004ec:	400037c0 	call	400037c <LCD_WriteReg>
          break;  
 40004f0:	00001006 	br	4000534 <LCD_SetCursor+0x118>

     case HX8347A:   /* 0x0047 */
     case HX8347D:   /* 0x0047 */
          LCD_WriteReg(0x02, Xpos>>8 );                                                  
 40004f4:	e0bffd0b 	ldhu	r2,-12(fp)
 40004f8:	1004d23a 	srli	r2,r2,8
 40004fc:	117fffcc 	andi	r5,r2,65535
 4000500:	01000084 	movi	r4,2
 4000504:	400037c0 	call	400037c <LCD_WriteReg>
          LCD_WriteReg(0x03, Xpos );  
 4000508:	e17ffd0b 	ldhu	r5,-12(fp)
 400050c:	010000c4 	movi	r4,3
 4000510:	400037c0 	call	400037c <LCD_WriteReg>

          LCD_WriteReg(0x06, Ypos>>8 );                           
 4000514:	e0bffe0b 	ldhu	r2,-8(fp)
 4000518:	1004d23a 	srli	r2,r2,8
 400051c:	117fffcc 	andi	r5,r2,65535
 4000520:	01000184 	movi	r4,6
 4000524:	400037c0 	call	400037c <LCD_WriteReg>
          LCD_WriteReg(0x07, Ypos );    
 4000528:	e17ffe0b 	ldhu	r5,-8(fp)
 400052c:	010001c4 	movi	r4,7
 4000530:	400037c0 	call	400037c <LCD_WriteReg>
    
          break;     
     case SSD2119:   /* 3.5 LCD 0x9919 */
          break; 
  }
}
 4000534:	e037883a 	mov	sp,fp
 4000538:	dfc00117 	ldw	ra,4(sp)
 400053c:	df000017 	ldw	fp,0(sp)
 4000540:	dec00204 	addi	sp,sp,8
 4000544:	f800283a 	ret

04000548 <LCD_Initializtion>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void LCD_Initializtion(void)
{
 4000548:	defffd04 	addi	sp,sp,-12
 400054c:	dfc00215 	stw	ra,8(sp)
 4000550:	df000115 	stw	fp,4(sp)
 4000554:	df000104 	addi	fp,sp,4
    alt_u16 DeviceCode;

   // LCD_Configuration();
     Clr_RST ;      /* LCD_RESET *////0
 4000558:	00862404 	movi	r2,6288
 400055c:	10000035 	stwio	zero,0(r2)
    delay_ms(100);
 4000560:	010000b4 	movhi	r4,2
 4000564:	2121a804 	addi	r4,r4,-31072
 4000568:	4003fc00 	call	4003fc0 <usleep>
     Set_RST;    /////////1
 400056c:	00c62404 	movi	r3,6288
 4000570:	00800044 	movi	r2,1
 4000574:	18800035 	stwio	r2,0(r3)

    /* Set MN(multipliers) of PLL, VCO = crystal freq * (N+1) */
    /* PLL freq = VCO/M with 250MHz < VCO < 800MHz */
    /* The max PLL freq is around 120MHz. To obtain 120MHz as the PLL freq */

    DeviceCode = LCD_ReadReg(0x0000);       /* Read LCD ID  */                 
 4000578:	0009883a 	mov	r4,zero
 400057c:	40003cc0 	call	40003cc <LCD_ReadReg>
 4000580:	e0bfff0d 	sth	r2,-4(fp)
    
    /*For ILI9325*/ 
    if( DeviceCode == 0x9325 || DeviceCode == 0x9328 )  
 4000584:	e0ffff0b 	ldhu	r3,-4(fp)
 4000588:	00a4c954 	movui	r2,37669
 400058c:	18800326 	beq	r3,r2,400059c <LCD_Initializtion+0x54>
 4000590:	e0ffff0b 	ldhu	r3,-4(fp)
 4000594:	00a4ca14 	movui	r2,37672
 4000598:	1880b71e 	bne	r3,r2,4000878 <LCD_Initializtion+0x330>
    {
        LCD_Code = ILI9325;
 400059c:	00800044 	movi	r2,1
 40005a0:	d0a00d05 	stb	r2,-32716(gp)
        LCD_WriteReg(0x00e7,0x0010);      
 40005a4:	010039c4 	movi	r4,231
 40005a8:	01400404 	movi	r5,16
 40005ac:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0000,0x0001);    /* start internal osc */
 40005b0:	0009883a 	mov	r4,zero
 40005b4:	01400044 	movi	r5,1
 40005b8:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0001,0x0100);     
 40005bc:	01000044 	movi	r4,1
 40005c0:	01404004 	movi	r5,256
 40005c4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0002,0x0700);    /* power on sequence */
 40005c8:	01000084 	movi	r4,2
 40005cc:	0141c004 	movi	r5,1792
 40005d0:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0003,(1<<12)|(1<<5)|(1<<4)|(0<<3) );     /* importance */
 40005d4:	010000c4 	movi	r4,3
 40005d8:	01440c04 	movi	r5,4144
 40005dc:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0004,0x0000);                                   
 40005e0:	01000104 	movi	r4,4
 40005e4:	000b883a 	mov	r5,zero
 40005e8:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0008,0x0207);               
 40005ec:	01000204 	movi	r4,8
 40005f0:	014081c4 	movi	r5,519
 40005f4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0009,0x0000);         
 40005f8:	01000244 	movi	r4,9
 40005fc:	000b883a 	mov	r5,zero
 4000600:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x000a,0x0000);    /* display setting */        
 4000604:	01000284 	movi	r4,10
 4000608:	000b883a 	mov	r5,zero
 400060c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x000c,0x0001);    /* display setting */        
 4000610:	01000304 	movi	r4,12
 4000614:	01400044 	movi	r5,1
 4000618:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x000d,0x0000);                    
 400061c:	01000344 	movi	r4,13
 4000620:	000b883a 	mov	r5,zero
 4000624:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x000f,0x0000);
 4000628:	010003c4 	movi	r4,15
 400062c:	000b883a 	mov	r5,zero
 4000630:	400037c0 	call	400037c <LCD_WriteReg>
        /* Power On sequence */
        LCD_WriteReg(0x0010,0x0000);   
 4000634:	01000404 	movi	r4,16
 4000638:	000b883a 	mov	r5,zero
 400063c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0011,0x0007);
 4000640:	01000444 	movi	r4,17
 4000644:	014001c4 	movi	r5,7
 4000648:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0012,0x0000);                                                                 
 400064c:	01000484 	movi	r4,18
 4000650:	000b883a 	mov	r5,zero
 4000654:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0013,0x0000);                 
 4000658:	010004c4 	movi	r4,19
 400065c:	000b883a 	mov	r5,zero
 4000660:	400037c0 	call	400037c <LCD_WriteReg>
        delay_ms(50);  /* delay 50 ms */        
 4000664:	0130d414 	movui	r4,50000
 4000668:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0010,0x1590);   
 400066c:	01000404 	movi	r4,16
 4000670:	01456404 	movi	r5,5520
 4000674:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0011,0x0227);
 4000678:	01000444 	movi	r4,17
 400067c:	014089c4 	movi	r5,551
 4000680:	400037c0 	call	400037c <LCD_WriteReg>
        delay_ms(50);  /* delay 50 ms */        
 4000684:	0130d414 	movui	r4,50000
 4000688:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0012,0x009c);                  
 400068c:	01000484 	movi	r4,18
 4000690:	01402704 	movi	r5,156
 4000694:	400037c0 	call	400037c <LCD_WriteReg>
        delay_ms(50);  /* delay 50 ms */        
 4000698:	0130d414 	movui	r4,50000
 400069c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0013,0x1900);   
 40006a0:	010004c4 	movi	r4,19
 40006a4:	01464004 	movi	r5,6400
 40006a8:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0029,0x0023);
 40006ac:	01000a44 	movi	r4,41
 40006b0:	014008c4 	movi	r5,35
 40006b4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x002b,0x000e);
 40006b8:	01000ac4 	movi	r4,43
 40006bc:	01400384 	movi	r5,14
 40006c0:	400037c0 	call	400037c <LCD_WriteReg>
        delay_ms(50);  /* delay 50 ms */        
 40006c4:	0130d414 	movui	r4,50000
 40006c8:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0020,0x0000);                                                            
 40006cc:	01000804 	movi	r4,32
 40006d0:	000b883a 	mov	r5,zero
 40006d4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0021,0x0000);           
 40006d8:	01000844 	movi	r4,33
 40006dc:	000b883a 	mov	r5,zero
 40006e0:	400037c0 	call	400037c <LCD_WriteReg>
        delay_ms(50);  /* delay 50 ms */        
 40006e4:	0130d414 	movui	r4,50000
 40006e8:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0030,0x0007); 
 40006ec:	01000c04 	movi	r4,48
 40006f0:	014001c4 	movi	r5,7
 40006f4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0031,0x0707);   
 40006f8:	01000c44 	movi	r4,49
 40006fc:	0141c1c4 	movi	r5,1799
 4000700:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0032,0x0006);
 4000704:	01000c84 	movi	r4,50
 4000708:	01400184 	movi	r5,6
 400070c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0035,0x0704);
 4000710:	01000d44 	movi	r4,53
 4000714:	0141c104 	movi	r5,1796
 4000718:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0036,0x1f04); 
 400071c:	01000d84 	movi	r4,54
 4000720:	0147c104 	movi	r5,7940
 4000724:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0037,0x0004);
 4000728:	01000dc4 	movi	r4,55
 400072c:	01400104 	movi	r5,4
 4000730:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0038,0x0000);        
 4000734:	01000e04 	movi	r4,56
 4000738:	000b883a 	mov	r5,zero
 400073c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0039,0x0706);     
 4000740:	01000e44 	movi	r4,57
 4000744:	0141c184 	movi	r5,1798
 4000748:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x003c,0x0701);
 400074c:	01000f04 	movi	r4,60
 4000750:	0141c044 	movi	r5,1793
 4000754:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x003d,0x000f);
 4000758:	01000f44 	movi	r4,61
 400075c:	014003c4 	movi	r5,15
 4000760:	400037c0 	call	400037c <LCD_WriteReg>
        delay_ms(50);  /* delay 50 ms */        
 4000764:	0130d414 	movui	r4,50000
 4000768:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0050,0x0000);        
 400076c:	01001404 	movi	r4,80
 4000770:	000b883a 	mov	r5,zero
 4000774:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0051,0x00ef);   
 4000778:	01001444 	movi	r4,81
 400077c:	01403bc4 	movi	r5,239
 4000780:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0052,0x0000);     
 4000784:	01001484 	movi	r4,82
 4000788:	000b883a 	mov	r5,zero
 400078c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0053,0x013f);
 4000790:	010014c4 	movi	r4,83
 4000794:	01404fc4 	movi	r5,319
 4000798:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0060,0xa700);        
 400079c:	01001804 	movi	r4,96
 40007a0:	0169c014 	movui	r5,42752
 40007a4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0061,0x0001); 
 40007a8:	01001844 	movi	r4,97
 40007ac:	01400044 	movi	r5,1
 40007b0:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x006a,0x0000);
 40007b4:	01001a84 	movi	r4,106
 40007b8:	000b883a 	mov	r5,zero
 40007bc:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0080,0x0000);
 40007c0:	01002004 	movi	r4,128
 40007c4:	000b883a 	mov	r5,zero
 40007c8:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0081,0x0000);
 40007cc:	01002044 	movi	r4,129
 40007d0:	000b883a 	mov	r5,zero
 40007d4:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0082,0x0000);
 40007d8:	01002084 	movi	r4,130
 40007dc:	000b883a 	mov	r5,zero
 40007e0:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0083,0x0000);
 40007e4:	010020c4 	movi	r4,131
 40007e8:	000b883a 	mov	r5,zero
 40007ec:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0084,0x0000);
 40007f0:	01002104 	movi	r4,132
 40007f4:	000b883a 	mov	r5,zero
 40007f8:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0085,0x0000);
 40007fc:	01002144 	movi	r4,133
 4000800:	000b883a 	mov	r5,zero
 4000804:	400037c0 	call	400037c <LCD_WriteReg>
          
        LCD_WriteReg(0x0090,0x0010);     
 4000808:	01002404 	movi	r4,144
 400080c:	01400404 	movi	r5,16
 4000810:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0092,0x0000);  
 4000814:	01002484 	movi	r4,146
 4000818:	000b883a 	mov	r5,zero
 400081c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0093,0x0003);
 4000820:	010024c4 	movi	r4,147
 4000824:	014000c4 	movi	r5,3
 4000828:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0095,0x0110);
 400082c:	01002544 	movi	r4,149
 4000830:	01404404 	movi	r5,272
 4000834:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0097,0x0000);        
 4000838:	010025c4 	movi	r4,151
 400083c:	000b883a 	mov	r5,zero
 4000840:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0098,0x0000);  
 4000844:	01002604 	movi	r4,152
 4000848:	000b883a 	mov	r5,zero
 400084c:	400037c0 	call	400037c <LCD_WriteReg>
        /* display on sequence */    
        LCD_WriteReg(0x0007,0x0133);
 4000850:	010001c4 	movi	r4,7
 4000854:	01404cc4 	movi	r5,307
 4000858:	400037c0 	call	400037c <LCD_WriteReg>
        
        LCD_WriteReg(0x0020,0x0000);
 400085c:	01000804 	movi	r4,32
 4000860:	000b883a 	mov	r5,zero
 4000864:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x0021,0x0000);
 4000868:	01000844 	movi	r4,33
 400086c:	000b883a 	mov	r5,zero
 4000870:	400037c0 	call	400037c <LCD_WriteReg>
    /* The max PLL freq is around 120MHz. To obtain 120MHz as the PLL freq */

    DeviceCode = LCD_ReadReg(0x0000);       /* Read LCD ID  */                 
    
    /*For ILI9325*/ 
    if( DeviceCode == 0x9325 || DeviceCode == 0x9328 )  
 4000874:	0000ce06 	br	4000bb0 <LCD_Initializtion+0x668>
        LCD_WriteReg(0x0007,0x0133);
        
        LCD_WriteReg(0x0020,0x0000);
        LCD_WriteReg(0x0021,0x0000);
    }
    else if( DeviceCode == 0x8989 )  /*For SSD1289*/
 4000878:	e0ffff0b 	ldhu	r3,-4(fp)
 400087c:	00a26254 	movui	r2,35209
 4000880:	1880cb1e 	bne	r3,r2,4000bb0 <LCD_Initializtion+0x668>
    {
        LCD_Code = SSD1289;
 4000884:	00800144 	movi	r2,5
 4000888:	d0a00d05 	stb	r2,-32716(gp)
        LCD_WriteReg(0x0000,0x0001);    delay_ms(50);   /* Enable LCD Oscillator */
 400088c:	0009883a 	mov	r4,zero
 4000890:	01400044 	movi	r5,1
 4000894:	400037c0 	call	400037c <LCD_WriteReg>
 4000898:	0130d414 	movui	r4,50000
 400089c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0003,0xA8A4);    delay_ms(50);   
 40008a0:	010000c4 	movi	r4,3
 40008a4:	016a2914 	movui	r5,43172
 40008a8:	400037c0 	call	400037c <LCD_WriteReg>
 40008ac:	0130d414 	movui	r4,50000
 40008b0:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x000C,0x0000);    delay_ms(50);   
 40008b4:	01000304 	movi	r4,12
 40008b8:	000b883a 	mov	r5,zero
 40008bc:	400037c0 	call	400037c <LCD_WriteReg>
 40008c0:	0130d414 	movui	r4,50000
 40008c4:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x000D,0x080C);    delay_ms(50);   
 40008c8:	01000344 	movi	r4,13
 40008cc:	01420304 	movi	r5,2060
 40008d0:	400037c0 	call	400037c <LCD_WriteReg>
 40008d4:	0130d414 	movui	r4,50000
 40008d8:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x000E,0x2B00);    delay_ms(50);   
 40008dc:	01000384 	movi	r4,14
 40008e0:	014ac004 	movi	r5,11008
 40008e4:	400037c0 	call	400037c <LCD_WriteReg>
 40008e8:	0130d414 	movui	r4,50000
 40008ec:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x001E,0x00B0);    delay_ms(50);   
 40008f0:	01000784 	movi	r4,30
 40008f4:	01402c04 	movi	r5,176
 40008f8:	400037c0 	call	400037c <LCD_WriteReg>
 40008fc:	0130d414 	movui	r4,50000
 4000900:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0001,0x2B3F);    delay_ms(50);   /* 320*240 0x2B3F */
 4000904:	01000044 	movi	r4,1
 4000908:	014acfc4 	movi	r5,11071
 400090c:	400037c0 	call	400037c <LCD_WriteReg>
 4000910:	0130d414 	movui	r4,50000
 4000914:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0002,0x0600);    delay_ms(50);
 4000918:	01000084 	movi	r4,2
 400091c:	01418004 	movi	r5,1536
 4000920:	400037c0 	call	400037c <LCD_WriteReg>
 4000924:	0130d414 	movui	r4,50000
 4000928:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0010,0x0000);    delay_ms(50);
 400092c:	01000404 	movi	r4,16
 4000930:	000b883a 	mov	r5,zero
 4000934:	400037c0 	call	400037c <LCD_WriteReg>
 4000938:	0130d414 	movui	r4,50000
 400093c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0011,0x6070);    delay_ms(50);
 4000940:	01000444 	movi	r4,17
 4000944:	01581c04 	movi	r5,24688
 4000948:	400037c0 	call	400037c <LCD_WriteReg>
 400094c:	0130d414 	movui	r4,50000
 4000950:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0005,0x0000);    delay_ms(50);
 4000954:	01000144 	movi	r4,5
 4000958:	000b883a 	mov	r5,zero
 400095c:	400037c0 	call	400037c <LCD_WriteReg>
 4000960:	0130d414 	movui	r4,50000
 4000964:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0006,0x0000);    delay_ms(50);
 4000968:	01000184 	movi	r4,6
 400096c:	000b883a 	mov	r5,zero
 4000970:	400037c0 	call	400037c <LCD_WriteReg>
 4000974:	0130d414 	movui	r4,50000
 4000978:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0016,0xEF1C);    delay_ms(50);
 400097c:	01000584 	movi	r4,22
 4000980:	017bc714 	movui	r5,61212
 4000984:	400037c0 	call	400037c <LCD_WriteReg>
 4000988:	0130d414 	movui	r4,50000
 400098c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0017,0x0003);    delay_ms(50);
 4000990:	010005c4 	movi	r4,23
 4000994:	014000c4 	movi	r5,3
 4000998:	400037c0 	call	400037c <LCD_WriteReg>
 400099c:	0130d414 	movui	r4,50000
 40009a0:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0007,0x0133);    delay_ms(50);         
 40009a4:	010001c4 	movi	r4,7
 40009a8:	01404cc4 	movi	r5,307
 40009ac:	400037c0 	call	400037c <LCD_WriteReg>
 40009b0:	0130d414 	movui	r4,50000
 40009b4:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x000B,0x0000);    delay_ms(50);
 40009b8:	010002c4 	movi	r4,11
 40009bc:	000b883a 	mov	r5,zero
 40009c0:	400037c0 	call	400037c <LCD_WriteReg>
 40009c4:	0130d414 	movui	r4,50000
 40009c8:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x000F,0x0000);    delay_ms(50);
 40009cc:	010003c4 	movi	r4,15
 40009d0:	000b883a 	mov	r5,zero
 40009d4:	400037c0 	call	400037c <LCD_WriteReg>
 40009d8:	0130d414 	movui	r4,50000
 40009dc:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0041,0x0000);    delay_ms(50);
 40009e0:	01001044 	movi	r4,65
 40009e4:	000b883a 	mov	r5,zero
 40009e8:	400037c0 	call	400037c <LCD_WriteReg>
 40009ec:	0130d414 	movui	r4,50000
 40009f0:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0042,0x0000);    delay_ms(50);
 40009f4:	01001084 	movi	r4,66
 40009f8:	000b883a 	mov	r5,zero
 40009fc:	400037c0 	call	400037c <LCD_WriteReg>
 4000a00:	0130d414 	movui	r4,50000
 4000a04:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0048,0x0000);    delay_ms(50);
 4000a08:	01001204 	movi	r4,72
 4000a0c:	000b883a 	mov	r5,zero
 4000a10:	400037c0 	call	400037c <LCD_WriteReg>
 4000a14:	0130d414 	movui	r4,50000
 4000a18:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0049,0x013F);    delay_ms(50);
 4000a1c:	01001244 	movi	r4,73
 4000a20:	01404fc4 	movi	r5,319
 4000a24:	400037c0 	call	400037c <LCD_WriteReg>
 4000a28:	0130d414 	movui	r4,50000
 4000a2c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x004A,0x0000);    delay_ms(50);
 4000a30:	01001284 	movi	r4,74
 4000a34:	000b883a 	mov	r5,zero
 4000a38:	400037c0 	call	400037c <LCD_WriteReg>
 4000a3c:	0130d414 	movui	r4,50000
 4000a40:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x004B,0x0000);    delay_ms(50);
 4000a44:	010012c4 	movi	r4,75
 4000a48:	000b883a 	mov	r5,zero
 4000a4c:	400037c0 	call	400037c <LCD_WriteReg>
 4000a50:	0130d414 	movui	r4,50000
 4000a54:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0044,0xEF00);    delay_ms(50);
 4000a58:	01001104 	movi	r4,68
 4000a5c:	017bc014 	movui	r5,61184
 4000a60:	400037c0 	call	400037c <LCD_WriteReg>
 4000a64:	0130d414 	movui	r4,50000
 4000a68:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0045,0x0000);    delay_ms(50);
 4000a6c:	01001144 	movi	r4,69
 4000a70:	000b883a 	mov	r5,zero
 4000a74:	400037c0 	call	400037c <LCD_WriteReg>
 4000a78:	0130d414 	movui	r4,50000
 4000a7c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0046,0x013F);    delay_ms(50);
 4000a80:	01001184 	movi	r4,70
 4000a84:	01404fc4 	movi	r5,319
 4000a88:	400037c0 	call	400037c <LCD_WriteReg>
 4000a8c:	0130d414 	movui	r4,50000
 4000a90:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0030,0x0707);    delay_ms(50);
 4000a94:	01000c04 	movi	r4,48
 4000a98:	0141c1c4 	movi	r5,1799
 4000a9c:	400037c0 	call	400037c <LCD_WriteReg>
 4000aa0:	0130d414 	movui	r4,50000
 4000aa4:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0031,0x0204);    delay_ms(50);
 4000aa8:	01000c44 	movi	r4,49
 4000aac:	01408104 	movi	r5,516
 4000ab0:	400037c0 	call	400037c <LCD_WriteReg>
 4000ab4:	0130d414 	movui	r4,50000
 4000ab8:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0032,0x0204);    delay_ms(50);
 4000abc:	01000c84 	movi	r4,50
 4000ac0:	01408104 	movi	r5,516
 4000ac4:	400037c0 	call	400037c <LCD_WriteReg>
 4000ac8:	0130d414 	movui	r4,50000
 4000acc:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0033,0x0502);    delay_ms(50);
 4000ad0:	01000cc4 	movi	r4,51
 4000ad4:	01414084 	movi	r5,1282
 4000ad8:	400037c0 	call	400037c <LCD_WriteReg>
 4000adc:	0130d414 	movui	r4,50000
 4000ae0:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0034,0x0507);    delay_ms(50);
 4000ae4:	01000d04 	movi	r4,52
 4000ae8:	014141c4 	movi	r5,1287
 4000aec:	400037c0 	call	400037c <LCD_WriteReg>
 4000af0:	0130d414 	movui	r4,50000
 4000af4:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0035,0x0204);    delay_ms(50);
 4000af8:	01000d44 	movi	r4,53
 4000afc:	01408104 	movi	r5,516
 4000b00:	400037c0 	call	400037c <LCD_WriteReg>
 4000b04:	0130d414 	movui	r4,50000
 4000b08:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0036,0x0204);    delay_ms(50);
 4000b0c:	01000d84 	movi	r4,54
 4000b10:	01408104 	movi	r5,516
 4000b14:	400037c0 	call	400037c <LCD_WriteReg>
 4000b18:	0130d414 	movui	r4,50000
 4000b1c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0037,0x0502);    delay_ms(50);
 4000b20:	01000dc4 	movi	r4,55
 4000b24:	01414084 	movi	r5,1282
 4000b28:	400037c0 	call	400037c <LCD_WriteReg>
 4000b2c:	0130d414 	movui	r4,50000
 4000b30:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x003A,0x0302);    delay_ms(50);
 4000b34:	01000e84 	movi	r4,58
 4000b38:	0140c084 	movi	r5,770
 4000b3c:	400037c0 	call	400037c <LCD_WriteReg>
 4000b40:	0130d414 	movui	r4,50000
 4000b44:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x003B,0x0302);    delay_ms(50);
 4000b48:	01000ec4 	movi	r4,59
 4000b4c:	0140c084 	movi	r5,770
 4000b50:	400037c0 	call	400037c <LCD_WriteReg>
 4000b54:	0130d414 	movui	r4,50000
 4000b58:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0023,0x0000);    delay_ms(50);
 4000b5c:	010008c4 	movi	r4,35
 4000b60:	000b883a 	mov	r5,zero
 4000b64:	400037c0 	call	400037c <LCD_WriteReg>
 4000b68:	0130d414 	movui	r4,50000
 4000b6c:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0024,0x0000);    delay_ms(50);
 4000b70:	01000904 	movi	r4,36
 4000b74:	000b883a 	mov	r5,zero
 4000b78:	400037c0 	call	400037c <LCD_WriteReg>
 4000b7c:	0130d414 	movui	r4,50000
 4000b80:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x0025,0x8000);    delay_ms(50);
 4000b84:	01000944 	movi	r4,37
 4000b88:	01600014 	movui	r5,32768
 4000b8c:	400037c0 	call	400037c <LCD_WriteReg>
 4000b90:	0130d414 	movui	r4,50000
 4000b94:	4003fc00 	call	4003fc0 <usleep>
        LCD_WriteReg(0x004f,0);
 4000b98:	010013c4 	movi	r4,79
 4000b9c:	000b883a 	mov	r5,zero
 4000ba0:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x004e,0);
 4000ba4:	01001384 	movi	r4,78
 4000ba8:	000b883a 	mov	r5,zero
 4000bac:	400037c0 	call	400037c <LCD_WriteReg>
    }
     
    delay_ms(50);   /* delay 50 ms */       
 4000bb0:	0130d414 	movui	r4,50000
 4000bb4:	4003fc00 	call	4003fc0 <usleep>
}
 4000bb8:	e037883a 	mov	sp,fp
 4000bbc:	dfc00117 	ldw	ra,4(sp)
 4000bc0:	df000017 	ldw	fp,0(sp)
 4000bc4:	dec00204 	addi	sp,sp,8
 4000bc8:	f800283a 	ret

04000bcc <LCD_Clear>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void LCD_Clear(alt_u16 Color)
{
 4000bcc:	defffc04 	addi	sp,sp,-16
 4000bd0:	dfc00315 	stw	ra,12(sp)
 4000bd4:	df000215 	stw	fp,8(sp)
 4000bd8:	df000204 	addi	fp,sp,8
 4000bdc:	e13fff0d 	sth	r4,-4(fp)
    alt_u32 index=0;
 4000be0:	e03ffe15 	stw	zero,-8(fp)
    
    if( LCD_Code == HX8347D || LCD_Code == HX8347A )
 4000be4:	d0a00d03 	ldbu	r2,-32716(gp)
 4000be8:	10803fcc 	andi	r2,r2,255
 4000bec:	108002a0 	cmpeqi	r2,r2,10
 4000bf0:	1000041e 	bne	r2,zero,4000c04 <LCD_Clear+0x38>
 4000bf4:	d0a00d03 	ldbu	r2,-32716(gp)
 4000bf8:	10803fcc 	andi	r2,r2,255
 4000bfc:	108002d8 	cmpnei	r2,r2,11
 4000c00:	1000191e 	bne	r2,zero,4000c68 <LCD_Clear+0x9c>
    {
        LCD_WriteReg(0x02,0x00);                                                  
 4000c04:	01000084 	movi	r4,2
 4000c08:	000b883a 	mov	r5,zero
 4000c0c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x03,0x00);  
 4000c10:	010000c4 	movi	r4,3
 4000c14:	000b883a 	mov	r5,zero
 4000c18:	400037c0 	call	400037c <LCD_WriteReg>
                        
        LCD_WriteReg(0x04,0x00);                           
 4000c1c:	01000104 	movi	r4,4
 4000c20:	000b883a 	mov	r5,zero
 4000c24:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x05,0xEF);  
 4000c28:	01000144 	movi	r4,5
 4000c2c:	01403bc4 	movi	r5,239
 4000c30:	400037c0 	call	400037c <LCD_WriteReg>
                         
        LCD_WriteReg(0x06,0x00);                           
 4000c34:	01000184 	movi	r4,6
 4000c38:	000b883a 	mov	r5,zero
 4000c3c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x07,0x00);    
 4000c40:	010001c4 	movi	r4,7
 4000c44:	000b883a 	mov	r5,zero
 4000c48:	400037c0 	call	400037c <LCD_WriteReg>
                       
        LCD_WriteReg(0x08,0x01);                           
 4000c4c:	01000204 	movi	r4,8
 4000c50:	01400044 	movi	r5,1
 4000c54:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x09,0x3F);     
 4000c58:	01000244 	movi	r4,9
 4000c5c:	01400fc4 	movi	r5,63
 4000c60:	400037c0 	call	400037c <LCD_WriteReg>
*******************************************************************************/
void LCD_Clear(alt_u16 Color)
{
    alt_u32 index=0;
    
    if( LCD_Code == HX8347D || LCD_Code == HX8347A )
 4000c64:	00000306 	br	4000c74 <LCD_Clear+0xa8>
        LCD_WriteReg(0x08,0x01);                           
        LCD_WriteReg(0x09,0x3F);     
    }
    else
    {   
        LCD_SetCursor(0,0); 
 4000c68:	0009883a 	mov	r4,zero
 4000c6c:	000b883a 	mov	r5,zero
 4000c70:	400041c0 	call	400041c <LCD_SetCursor>
    }   
    Clr_Cs; 
 4000c74:	00863404 	movi	r2,6352
 4000c78:	10000035 	stwio	zero,0(r2)
    LCD_WriteIndex(0x0022);
 4000c7c:	01000884 	movi	r4,34
 4000c80:	400024c0 	call	400024c <LCD_WriteIndex>
    for( index = 0; index < MAX_X * MAX_Y; index++ )
 4000c84:	e03ffe15 	stw	zero,-8(fp)
 4000c88:	00000506 	br	4000ca0 <LCD_Clear+0xd4>
    {
        LCD_WriteData(Color);
 4000c8c:	e13fff0b 	ldhu	r4,-4(fp)
 4000c90:	40002ac0 	call	40002ac <LCD_WriteData>
    {   
        LCD_SetCursor(0,0); 
    }   
    Clr_Cs; 
    LCD_WriteIndex(0x0022);
    for( index = 0; index < MAX_X * MAX_Y; index++ )
 4000c94:	e0bffe17 	ldw	r2,-8(fp)
 4000c98:	10800044 	addi	r2,r2,1
 4000c9c:	e0bffe15 	stw	r2,-8(fp)
 4000ca0:	e0fffe17 	ldw	r3,-8(fp)
 4000ca4:	00800074 	movhi	r2,1
 4000ca8:	108affc4 	addi	r2,r2,11263
 4000cac:	10fff72e 	bgeu	r2,r3,4000c8c <LCD_Clear+0xc0>
    {
        LCD_WriteData(Color);
    }
    Set_Cs;
 4000cb0:	00c63404 	movi	r3,6352
 4000cb4:	00800044 	movi	r2,1
 4000cb8:	18800035 	stwio	r2,0(r3)
}
 4000cbc:	e037883a 	mov	sp,fp
 4000cc0:	dfc00117 	ldw	ra,4(sp)
 4000cc4:	df000017 	ldw	fp,0(sp)
 4000cc8:	dec00204 	addi	sp,sp,8
 4000ccc:	f800283a 	ret

04000cd0 <LCD_show_test>:
void LCD_show_test()
{ alt_u32 index=0,i;
 4000cd0:	defffc04 	addi	sp,sp,-16
 4000cd4:	dfc00315 	stw	ra,12(sp)
 4000cd8:	df000215 	stw	fp,8(sp)
 4000cdc:	df000204 	addi	fp,sp,8
 4000ce0:	e03fff15 	stw	zero,-4(fp)
    if( LCD_Code == HX8347D || LCD_Code == HX8347A )
 4000ce4:	d0a00d03 	ldbu	r2,-32716(gp)
 4000ce8:	10803fcc 	andi	r2,r2,255
 4000cec:	108002a0 	cmpeqi	r2,r2,10
 4000cf0:	1000041e 	bne	r2,zero,4000d04 <LCD_show_test+0x34>
 4000cf4:	d0a00d03 	ldbu	r2,-32716(gp)
 4000cf8:	10803fcc 	andi	r2,r2,255
 4000cfc:	108002d8 	cmpnei	r2,r2,11
 4000d00:	1000191e 	bne	r2,zero,4000d68 <LCD_show_test+0x98>
    {
        LCD_WriteReg(0x02,0x00);                                                  
 4000d04:	01000084 	movi	r4,2
 4000d08:	000b883a 	mov	r5,zero
 4000d0c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x03,0x00);  
 4000d10:	010000c4 	movi	r4,3
 4000d14:	000b883a 	mov	r5,zero
 4000d18:	400037c0 	call	400037c <LCD_WriteReg>
                        
        LCD_WriteReg(0x04,0x00);                           
 4000d1c:	01000104 	movi	r4,4
 4000d20:	000b883a 	mov	r5,zero
 4000d24:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x05,0xEF);  
 4000d28:	01000144 	movi	r4,5
 4000d2c:	01403bc4 	movi	r5,239
 4000d30:	400037c0 	call	400037c <LCD_WriteReg>
                         
        LCD_WriteReg(0x06,0x00);                           
 4000d34:	01000184 	movi	r4,6
 4000d38:	000b883a 	mov	r5,zero
 4000d3c:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x07,0x00);    
 4000d40:	010001c4 	movi	r4,7
 4000d44:	000b883a 	mov	r5,zero
 4000d48:	400037c0 	call	400037c <LCD_WriteReg>
                       
        LCD_WriteReg(0x08,0x01);                           
 4000d4c:	01000204 	movi	r4,8
 4000d50:	01400044 	movi	r5,1
 4000d54:	400037c0 	call	400037c <LCD_WriteReg>
        LCD_WriteReg(0x09,0x3F);     
 4000d58:	01000244 	movi	r4,9
 4000d5c:	01400fc4 	movi	r5,63
 4000d60:	400037c0 	call	400037c <LCD_WriteReg>
    }
    Set_Cs;
}
void LCD_show_test()
{ alt_u32 index=0,i;
    if( LCD_Code == HX8347D || LCD_Code == HX8347A )
 4000d64:	00000306 	br	4000d74 <LCD_show_test+0xa4>
        LCD_WriteReg(0x08,0x01);                           
        LCD_WriteReg(0x09,0x3F);     
    }
    else
    {   
        LCD_SetCursor(0,0); 
 4000d68:	0009883a 	mov	r4,zero
 4000d6c:	000b883a 	mov	r5,zero
 4000d70:	400041c0 	call	400041c <LCD_SetCursor>
    }   
    Clr_Cs; 
 4000d74:	00863404 	movi	r2,6352
 4000d78:	10000035 	stwio	zero,0(r2)
    LCD_WriteIndex(0x0022);
 4000d7c:	01000884 	movi	r4,34
 4000d80:	400024c0 	call	400024c <LCD_WriteIndex>
  for( i = 0; i< 8; i++ )
 4000d84:	e03ffe15 	stw	zero,-8(fp)
 4000d88:	00001706 	br	4000de8 <LCD_show_test+0x118>
    for( index = i*40 * 240; index < (i+1)*40 * 240; index++ )
 4000d8c:	e0bffe17 	ldw	r2,-8(fp)
 4000d90:	10896024 	muli	r2,r2,9600
 4000d94:	e0bfff15 	stw	r2,-4(fp)
 4000d98:	00000b06 	br	4000dc8 <LCD_show_test+0xf8>
    {
        LCD_WriteData(colorfol1[i]);
 4000d9c:	e0bffe17 	ldw	r2,-8(fp)
 4000da0:	00c10034 	movhi	r3,1024
 4000da4:	18df0d04 	addi	r3,r3,31796
 4000da8:	1085883a 	add	r2,r2,r2
 4000dac:	10c5883a 	add	r2,r2,r3
 4000db0:	1080000b 	ldhu	r2,0(r2)
 4000db4:	113fffcc 	andi	r4,r2,65535
 4000db8:	40002ac0 	call	40002ac <LCD_WriteData>
        LCD_SetCursor(0,0); 
    }   
    Clr_Cs; 
    LCD_WriteIndex(0x0022);
  for( i = 0; i< 8; i++ )
    for( index = i*40 * 240; index < (i+1)*40 * 240; index++ )
 4000dbc:	e0bfff17 	ldw	r2,-4(fp)
 4000dc0:	10800044 	addi	r2,r2,1
 4000dc4:	e0bfff15 	stw	r2,-4(fp)
 4000dc8:	e0bffe17 	ldw	r2,-8(fp)
 4000dcc:	10896024 	muli	r2,r2,9600
 4000dd0:	10c96004 	addi	r3,r2,9600
 4000dd4:	e0bfff17 	ldw	r2,-4(fp)
 4000dd8:	10fff036 	bltu	r2,r3,4000d9c <LCD_show_test+0xcc>
    {   
        LCD_SetCursor(0,0); 
    }   
    Clr_Cs; 
    LCD_WriteIndex(0x0022);
  for( i = 0; i< 8; i++ )
 4000ddc:	e0bffe17 	ldw	r2,-8(fp)
 4000de0:	10800044 	addi	r2,r2,1
 4000de4:	e0bffe15 	stw	r2,-8(fp)
 4000de8:	e0bffe17 	ldw	r2,-8(fp)
 4000dec:	10800230 	cmpltui	r2,r2,8
 4000df0:	103fe61e 	bne	r2,zero,4000d8c <LCD_show_test+0xbc>
    for( index = i*40 * 240; index < (i+1)*40 * 240; index++ )
    {
        LCD_WriteData(colorfol1[i]);
    }
    while(1);
 4000df4:	003fff06 	br	4000df4 <LCD_show_test+0x124>

04000df8 <LCD_BGR2RGB>:
* Output         : None
* Return         : RGB color
* Attention      :
*******************************************************************************/
alt_u16 LCD_BGR2RGB(alt_u16 color)
{
 4000df8:	defffc04 	addi	sp,sp,-16
 4000dfc:	df000315 	stw	fp,12(sp)
 4000e00:	df000304 	addi	fp,sp,12
 4000e04:	e13fff0d 	sth	r4,-4(fp)
    alt_u16  r, g, b, rgb;
    
    b = ( color>>0 )  & 0x1f;
 4000e08:	e0bfff0b 	ldhu	r2,-4(fp)
 4000e0c:	108007cc 	andi	r2,r2,31
 4000e10:	e0bffd8d 	sth	r2,-10(fp)
    g = ( color>>5 )  & 0x3f;
 4000e14:	e0bfff0b 	ldhu	r2,-4(fp)
 4000e18:	1004d17a 	srli	r2,r2,5
 4000e1c:	10800fcc 	andi	r2,r2,63
 4000e20:	e0bffe0d 	sth	r2,-8(fp)
    r = ( color>>11 ) & 0x1f;
 4000e24:	e0bfff0b 	ldhu	r2,-4(fp)
 4000e28:	1004d2fa 	srli	r2,r2,11
 4000e2c:	108007cc 	andi	r2,r2,31
 4000e30:	e0bffe8d 	sth	r2,-6(fp)
    
    rgb =  (b<<11) + (g<<5) + (r<<0);
 4000e34:	e0bffd8b 	ldhu	r2,-10(fp)
 4000e38:	100492fa 	slli	r2,r2,11
 4000e3c:	1007883a 	mov	r3,r2
 4000e40:	e0bffe0b 	ldhu	r2,-8(fp)
 4000e44:	1004917a 	slli	r2,r2,5
 4000e48:	1885883a 	add	r2,r3,r2
 4000e4c:	1007883a 	mov	r3,r2
 4000e50:	e0bffe8b 	ldhu	r2,-6(fp)
 4000e54:	1885883a 	add	r2,r3,r2
 4000e58:	e0bffd0d 	sth	r2,-12(fp)
    
    return( rgb );
 4000e5c:	e0bffd0b 	ldhu	r2,-12(fp)
}
 4000e60:	e037883a 	mov	sp,fp
 4000e64:	df000017 	ldw	fp,0(sp)
 4000e68:	dec00104 	addi	sp,sp,4
 4000e6c:	f800283a 	ret

04000e70 <LCD_GetPoint>:
* Output         : None
* Return         : Screen Color
* Attention      : None
*******************************************************************************/
alt_u16 LCD_GetPoint(alt_u16 Xpos,alt_u16 Ypos)
{
 4000e70:	defff804 	addi	sp,sp,-32
 4000e74:	dfc00715 	stw	ra,28(sp)
 4000e78:	df000615 	stw	fp,24(sp)
 4000e7c:	df000604 	addi	fp,sp,24
 4000e80:	e13ffc0d 	sth	r4,-16(fp)
 4000e84:	e17ffd0d 	sth	r5,-12(fp)
    alt_u16 dummy;
    
    LCD_SetCursor(Xpos,Ypos);
 4000e88:	e13ffc0b 	ldhu	r4,-16(fp)
 4000e8c:	e17ffd0b 	ldhu	r5,-12(fp)
 4000e90:	400041c0 	call	400041c <LCD_SetCursor>
    Clr_Cs;
 4000e94:	00863404 	movi	r2,6352
 4000e98:	10000035 	stwio	zero,0(r2)
    LCD_WriteIndex(0x0022);  
 4000e9c:	01000884 	movi	r4,34
 4000ea0:	400024c0 	call	400024c <LCD_WriteIndex>
    
    switch( LCD_Code )
 4000ea4:	d0a00d03 	ldbu	r2,-32716(gp)
 4000ea8:	10803fcc 	andi	r2,r2,255
 4000eac:	10bfff04 	addi	r2,r2,-4
 4000eb0:	e0bfff15 	stw	r2,-4(fp)
 4000eb4:	e0ffff17 	ldw	r3,-4(fp)
 4000eb8:	18800268 	cmpgeui	r2,r3,9
 4000ebc:	1000381e 	bne	r2,zero,4000fa0 <LCD_GetPoint+0x130>
 4000ec0:	e13fff17 	ldw	r4,-4(fp)
 4000ec4:	e13fff17 	ldw	r4,-4(fp)
 4000ec8:	2105883a 	add	r2,r4,r4
 4000ecc:	1087883a 	add	r3,r2,r2
 4000ed0:	00810034 	movhi	r2,1024
 4000ed4:	1083b904 	addi	r2,r2,3812
 4000ed8:	1885883a 	add	r2,r3,r2
 4000edc:	10800017 	ldw	r2,0(r2)
 4000ee0:	1000683a 	jmp	r2
 4000ee4:	04000f08 	cmpgei	r16,zero,60
 4000ee8:	04000f08 	cmpgei	r16,zero,60
 4000eec:	04000f08 	cmpgei	r16,zero,60
 4000ef0:	04000f08 	cmpgei	r16,zero,60
 4000ef4:	04000fa0 	cmpeqi	r16,zero,62
 4000ef8:	04000fa0 	cmpeqi	r16,zero,62
 4000efc:	04000f30 	cmpltui	r16,zero,60
 4000f00:	04000f30 	cmpltui	r16,zero,60
 4000f04:	04000f08 	cmpgei	r16,zero,60
        case ST7781:
        case LGDP4531:
        case LGDP4535:
        case SSD1289:
        case SSD1298:
      dummy = LCD_ReadData();
 4000f08:	40003040 	call	4000304 <LCD_ReadData>
 4000f0c:	e0bffb0d 	sth	r2,-20(fp)
      dummy = LCD_ReadData(); 
 4000f10:	40003040 	call	4000304 <LCD_ReadData>
 4000f14:	e0bffb0d 	sth	r2,-20(fp)
      Set_Cs;   
 4000f18:	00c63404 	movi	r3,6352
 4000f1c:	00800044 	movi	r2,1
 4000f20:	18800035 	stwio	r2,0(r3)
          return  dummy;          
 4000f24:	e0bffb0b 	ldhu	r2,-20(fp)
 4000f28:	e0bffe15 	stw	r2,-8(fp)
 4000f2c:	00002706 	br	4000fcc <LCD_GetPoint+0x15c>
    case HX8347A:
      case HX8347D:
    {
      alt_u8 red,green,blue;
      red = LCD_ReadData()>>3;
 4000f30:	40003040 	call	4000304 <LCD_ReadData>
 4000f34:	10bfffcc 	andi	r2,r2,65535
 4000f38:	1004d0fa 	srli	r2,r2,3
 4000f3c:	e0bffa85 	stb	r2,-22(fp)
      green = LCD_ReadData()>>3; 
 4000f40:	40003040 	call	4000304 <LCD_ReadData>
 4000f44:	10bfffcc 	andi	r2,r2,65535
 4000f48:	1004d0fa 	srli	r2,r2,3
 4000f4c:	e0bffa45 	stb	r2,-23(fp)
      blue = LCD_ReadData()>>2; 
 4000f50:	40003040 	call	4000304 <LCD_ReadData>
 4000f54:	10bfffcc 	andi	r2,r2,65535
 4000f58:	1004d0ba 	srli	r2,r2,2
 4000f5c:	e0bffa05 	stb	r2,-24(fp)
      dummy = ( green << 11 ) | (blue << 5 ) | red;
 4000f60:	e0bffa43 	ldbu	r2,-23(fp)
 4000f64:	100492fa 	slli	r2,r2,11
 4000f68:	1007883a 	mov	r3,r2
 4000f6c:	e0bffa03 	ldbu	r2,-24(fp)
 4000f70:	1004917a 	slli	r2,r2,5
 4000f74:	1884b03a 	or	r2,r3,r2
 4000f78:	1007883a 	mov	r3,r2
 4000f7c:	e0bffa83 	ldbu	r2,-22(fp)
 4000f80:	1884b03a 	or	r2,r3,r2
 4000f84:	e0bffb0d 	sth	r2,-20(fp)
        }
      Set_Cs;   
 4000f88:	00c63404 	movi	r3,6352
 4000f8c:	00800044 	movi	r2,1
 4000f90:	18800035 	stwio	r2,0(r3)
      return  dummy;
 4000f94:	e0fffb0b 	ldhu	r3,-20(fp)
 4000f98:	e0fffe15 	stw	r3,-8(fp)
 4000f9c:	00000b06 	br	4000fcc <LCD_GetPoint+0x15c>
    default:    /* 0x9320 0x9325 0x9328 0x9331 0x5408 0x1505 0x0505 0x9919 */
      dummy = LCD_ReadData();
 4000fa0:	40003040 	call	4000304 <LCD_ReadData>
 4000fa4:	e0bffb0d 	sth	r2,-20(fp)
      dummy = LCD_ReadData(); 
 4000fa8:	40003040 	call	4000304 <LCD_ReadData>
 4000fac:	e0bffb0d 	sth	r2,-20(fp)
      Set_Cs;   
 4000fb0:	00c63404 	movi	r3,6352
 4000fb4:	00800044 	movi	r2,1
 4000fb8:	18800035 	stwio	r2,0(r3)
      return  LCD_BGR2RGB( dummy );
 4000fbc:	e13ffb0b 	ldhu	r4,-20(fp)
 4000fc0:	4000df80 	call	4000df8 <LCD_BGR2RGB>
 4000fc4:	10bfffcc 	andi	r2,r2,65535
 4000fc8:	e0bffe15 	stw	r2,-8(fp)
 4000fcc:	e0bffe17 	ldw	r2,-8(fp)
    }
}
 4000fd0:	e037883a 	mov	sp,fp
 4000fd4:	dfc00117 	ldw	ra,4(sp)
 4000fd8:	df000017 	ldw	fp,0(sp)
 4000fdc:	dec00204 	addi	sp,sp,8
 4000fe0:	f800283a 	ret

04000fe4 <LCD_SetPoint>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void LCD_SetPoint(alt_u16 Xpos,alt_u16 Ypos,alt_u16 point)
{
 4000fe4:	defffb04 	addi	sp,sp,-20
 4000fe8:	dfc00415 	stw	ra,16(sp)
 4000fec:	df000315 	stw	fp,12(sp)
 4000ff0:	df000304 	addi	fp,sp,12
 4000ff4:	e13ffd0d 	sth	r4,-12(fp)
 4000ff8:	e17ffe0d 	sth	r5,-8(fp)
 4000ffc:	e1bfff0d 	sth	r6,-4(fp)
    if( Xpos >= MAX_X || Ypos >= MAX_Y )
 4001000:	e0bffd0b 	ldhu	r2,-12(fp)
 4001004:	10805028 	cmpgeui	r2,r2,320
 4001008:	10000a1e 	bne	r2,zero,4001034 <LCD_SetPoint+0x50>
 400100c:	e0bffe0b 	ldhu	r2,-8(fp)
 4001010:	10803c30 	cmpltui	r2,r2,240
 4001014:	1000011e 	bne	r2,zero,400101c <LCD_SetPoint+0x38>
    {
        return;
 4001018:	00000606 	br	4001034 <LCD_SetPoint+0x50>
    }
    LCD_SetCursor(Xpos,Ypos);
 400101c:	e13ffd0b 	ldhu	r4,-12(fp)
 4001020:	e17ffe0b 	ldhu	r5,-8(fp)
 4001024:	400041c0 	call	400041c <LCD_SetCursor>
    LCD_WriteReg(0x0022,point);
 4001028:	e17fff0b 	ldhu	r5,-4(fp)
 400102c:	01000884 	movi	r4,34
 4001030:	400037c0 	call	400037c <LCD_WriteReg>
}
 4001034:	e037883a 	mov	sp,fp
 4001038:	dfc00117 	ldw	ra,4(sp)
 400103c:	df000017 	ldw	fp,0(sp)
 4001040:	dec00204 	addi	sp,sp,8
 4001044:	f800283a 	ret

04001048 <LCD_DrawLine>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/     
void LCD_DrawLine( alt_u16 x0, alt_u16 y0, alt_u16 x1, alt_u16 y1 , alt_u16 color )
{
 4001048:	defff704 	addi	sp,sp,-36
 400104c:	dfc00815 	stw	ra,32(sp)
 4001050:	df000715 	stw	fp,28(sp)
 4001054:	df000704 	addi	fp,sp,28
 4001058:	e0800217 	ldw	r2,8(fp)
 400105c:	e13ffb0d 	sth	r4,-20(fp)
 4001060:	e17ffc0d 	sth	r5,-16(fp)
 4001064:	e1bffd0d 	sth	r6,-12(fp)
 4001068:	e1fffe0d 	sth	r7,-8(fp)
 400106c:	e0bfff0d 	sth	r2,-4(fp)
  short dx,dy;
  short temp;

  if( x0 > x1 )
 4001070:	e0fffb0b 	ldhu	r3,-20(fp)
 4001074:	e0bffd0b 	ldhu	r2,-12(fp)
 4001078:	10c0062e 	bgeu	r2,r3,4001094 <LCD_DrawLine+0x4c>
  {
    temp = x1;
 400107c:	e0bffd0b 	ldhu	r2,-12(fp)
 4001080:	e0bff90d 	sth	r2,-28(fp)
    x1 = x0;
 4001084:	e0bffb0b 	ldhu	r2,-20(fp)
 4001088:	e0bffd0d 	sth	r2,-12(fp)
    x0 = temp;   
 400108c:	e0bff90b 	ldhu	r2,-28(fp)
 4001090:	e0bffb0d 	sth	r2,-20(fp)
  }
  if( y0 > y1 )
 4001094:	e0fffc0b 	ldhu	r3,-16(fp)
 4001098:	e0bffe0b 	ldhu	r2,-8(fp)
 400109c:	10c0062e 	bgeu	r2,r3,40010b8 <LCD_DrawLine+0x70>
  {
    temp = y1;
 40010a0:	e0bffe0b 	ldhu	r2,-8(fp)
 40010a4:	e0bff90d 	sth	r2,-28(fp)
    y1 = y0;
 40010a8:	e0bffc0b 	ldhu	r2,-16(fp)
 40010ac:	e0bffe0d 	sth	r2,-8(fp)
    y0 = temp;   
 40010b0:	e0bff90b 	ldhu	r2,-28(fp)
 40010b4:	e0bffc0d 	sth	r2,-16(fp)
  }

  dx = x1-x0;
 40010b8:	e0fffd0b 	ldhu	r3,-12(fp)
 40010bc:	e0bffb0b 	ldhu	r2,-20(fp)
 40010c0:	1885c83a 	sub	r2,r3,r2
 40010c4:	e0bffa0d 	sth	r2,-24(fp)
  dy = y1-y0;
 40010c8:	e0fffe0b 	ldhu	r3,-8(fp)
 40010cc:	e0bffc0b 	ldhu	r2,-16(fp)
 40010d0:	1885c83a 	sub	r2,r3,r2
 40010d4:	e0bff98d 	sth	r2,-26(fp)

  if( dx == 0 )
 40010d8:	e0bffa0f 	ldh	r2,-24(fp)
 40010dc:	1004c03a 	cmpne	r2,r2,zero
 40010e0:	10000b1e 	bne	r2,zero,4001110 <LCD_DrawLine+0xc8>
  {
    do
    { 
      LCD_SetPoint(x0, y0, color);
 40010e4:	e13ffb0b 	ldhu	r4,-20(fp)
 40010e8:	e17ffc0b 	ldhu	r5,-16(fp)
 40010ec:	e1bfff0b 	ldhu	r6,-4(fp)
 40010f0:	4000fe40 	call	4000fe4 <LCD_SetPoint>
      y0++;
 40010f4:	e0bffc0b 	ldhu	r2,-16(fp)
 40010f8:	10800044 	addi	r2,r2,1
 40010fc:	e0bffc0d 	sth	r2,-16(fp)
    }
    while( y1 >= y0 ); 
 4001100:	e0fffe0b 	ldhu	r3,-8(fp)
 4001104:	e0bffc0b 	ldhu	r2,-16(fp)
 4001108:	18bff62e 	bgeu	r3,r2,40010e4 <LCD_DrawLine+0x9c>
    return; 
 400110c:	00006606 	br	40012a8 <LCD_DrawLine+0x260>
  }
  if( dy == 0 )
 4001110:	e0bff98f 	ldh	r2,-26(fp)
 4001114:	1004c03a 	cmpne	r2,r2,zero
 4001118:	10000b1e 	bne	r2,zero,4001148 <LCD_DrawLine+0x100>
  {
    do
    {
      LCD_SetPoint(x0, y0, color);
 400111c:	e13ffb0b 	ldhu	r4,-20(fp)
 4001120:	e17ffc0b 	ldhu	r5,-16(fp)
 4001124:	e1bfff0b 	ldhu	r6,-4(fp)
 4001128:	4000fe40 	call	4000fe4 <LCD_SetPoint>
      x0++;
 400112c:	e0bffb0b 	ldhu	r2,-20(fp)
 4001130:	10800044 	addi	r2,r2,1
 4001134:	e0bffb0d 	sth	r2,-20(fp)
    }
    while( x1 >= x0 ); 
 4001138:	e0fffd0b 	ldhu	r3,-12(fp)
 400113c:	e0bffb0b 	ldhu	r2,-20(fp)
 4001140:	18bff62e 	bgeu	r3,r2,400111c <LCD_DrawLine+0xd4>
        return;
 4001144:	00005806 	br	40012a8 <LCD_DrawLine+0x260>
  }

    /* Bresenham's line algorithm  */
  if( dx > dy )
 4001148:	e0fffa0f 	ldh	r3,-24(fp)
 400114c:	e0bff98f 	ldh	r2,-26(fp)
 4001150:	10c02b0e 	bge	r2,r3,4001200 <LCD_DrawLine+0x1b8>
  {
    temp = 2 * dy - dx;
 4001154:	e0bff98f 	ldh	r2,-26(fp)
 4001158:	1085883a 	add	r2,r2,r2
 400115c:	1007883a 	mov	r3,r2
 4001160:	e0bffa0b 	ldhu	r2,-24(fp)
 4001164:	1885c83a 	sub	r2,r3,r2
 4001168:	e0bff90d 	sth	r2,-28(fp)
    while( x0 != x1 )
 400116c:	00001c06 	br	40011e0 <LCD_DrawLine+0x198>
    {
        LCD_SetPoint(x0,y0,color);
 4001170:	e13ffb0b 	ldhu	r4,-20(fp)
 4001174:	e17ffc0b 	ldhu	r5,-16(fp)
 4001178:	e1bfff0b 	ldhu	r6,-4(fp)
 400117c:	4000fe40 	call	4000fe4 <LCD_SetPoint>
        x0++;
 4001180:	e0bffb0b 	ldhu	r2,-20(fp)
 4001184:	10800044 	addi	r2,r2,1
 4001188:	e0bffb0d 	sth	r2,-20(fp)
        if( temp > 0 )
 400118c:	e0bff90f 	ldh	r2,-28(fp)
 4001190:	10800050 	cmplti	r2,r2,1
 4001194:	10000c1e 	bne	r2,zero,40011c8 <LCD_DrawLine+0x180>
        {
          y0++;
 4001198:	e0bffc0b 	ldhu	r2,-16(fp)
 400119c:	10800044 	addi	r2,r2,1
 40011a0:	e0bffc0d 	sth	r2,-16(fp)
          temp += 2 * dy - 2 * dx; 
 40011a4:	e0fff98f 	ldh	r3,-26(fp)
 40011a8:	e0bffa0f 	ldh	r2,-24(fp)
 40011ac:	1885c83a 	sub	r2,r3,r2
 40011b0:	1085883a 	add	r2,r2,r2
 40011b4:	1007883a 	mov	r3,r2
 40011b8:	e0bff90b 	ldhu	r2,-28(fp)
 40011bc:	1885883a 	add	r2,r3,r2
 40011c0:	e0bff90d 	sth	r2,-28(fp)
 40011c4:	00000606 	br	40011e0 <LCD_DrawLine+0x198>
          }
      else         
      {
              temp += 2 * dy;
 40011c8:	e0bff98f 	ldh	r2,-26(fp)
 40011cc:	1085883a 	add	r2,r2,r2
 40011d0:	1007883a 	mov	r3,r2
 40011d4:	e0bff90b 	ldhu	r2,-28(fp)
 40011d8:	1885883a 	add	r2,r3,r2
 40011dc:	e0bff90d 	sth	r2,-28(fp)

    /* Bresenham's line algorithm  */
  if( dx > dy )
  {
    temp = 2 * dy - dx;
    while( x0 != x1 )
 40011e0:	e0fffb0b 	ldhu	r3,-20(fp)
 40011e4:	e0bffd0b 	ldhu	r2,-12(fp)
 40011e8:	18bfe11e 	bne	r3,r2,4001170 <LCD_DrawLine+0x128>
      else         
      {
              temp += 2 * dy;
            }       
    }
    LCD_SetPoint(x0,y0,color);
 40011ec:	e13ffb0b 	ldhu	r4,-20(fp)
 40011f0:	e17ffc0b 	ldhu	r5,-16(fp)
 40011f4:	e1bfff0b 	ldhu	r6,-4(fp)
 40011f8:	4000fe40 	call	4000fe4 <LCD_SetPoint>
 40011fc:	00002a06 	br	40012a8 <LCD_DrawLine+0x260>
  }  
  else
  {
    temp = 2 * dx - dy;
 4001200:	e0bffa0f 	ldh	r2,-24(fp)
 4001204:	1085883a 	add	r2,r2,r2
 4001208:	1007883a 	mov	r3,r2
 400120c:	e0bff98b 	ldhu	r2,-26(fp)
 4001210:	1885c83a 	sub	r2,r3,r2
 4001214:	e0bff90d 	sth	r2,-28(fp)
    while( y0 != y1 )
 4001218:	00001c06 	br	400128c <LCD_DrawLine+0x244>
    {
          LCD_SetPoint(x0,y0,color);     
 400121c:	e13ffb0b 	ldhu	r4,-20(fp)
 4001220:	e17ffc0b 	ldhu	r5,-16(fp)
 4001224:	e1bfff0b 	ldhu	r6,-4(fp)
 4001228:	4000fe40 	call	4000fe4 <LCD_SetPoint>
      y0++;                 
 400122c:	e0bffc0b 	ldhu	r2,-16(fp)
 4001230:	10800044 	addi	r2,r2,1
 4001234:	e0bffc0d 	sth	r2,-16(fp)
      if( temp > 0 )           
 4001238:	e0bff90f 	ldh	r2,-28(fp)
 400123c:	10800050 	cmplti	r2,r2,1
 4001240:	10000c1e 	bne	r2,zero,4001274 <LCD_DrawLine+0x22c>
      {
        x0++;               
 4001244:	e0bffb0b 	ldhu	r2,-20(fp)
 4001248:	10800044 	addi	r2,r2,1
 400124c:	e0bffb0d 	sth	r2,-20(fp)
        temp+=2*dy-2*dx; 
 4001250:	e0fff98f 	ldh	r3,-26(fp)
 4001254:	e0bffa0f 	ldh	r2,-24(fp)
 4001258:	1885c83a 	sub	r2,r3,r2
 400125c:	1085883a 	add	r2,r2,r2
 4001260:	1007883a 	mov	r3,r2
 4001264:	e0bff90b 	ldhu	r2,-28(fp)
 4001268:	1885883a 	add	r2,r3,r2
 400126c:	e0bff90d 	sth	r2,-28(fp)
 4001270:	00000606 	br	400128c <LCD_DrawLine+0x244>
      }
      else
            {
        temp += 2 * dy;
 4001274:	e0bff98f 	ldh	r2,-26(fp)
 4001278:	1085883a 	add	r2,r2,r2
 400127c:	1007883a 	mov	r3,r2
 4001280:	e0bff90b 	ldhu	r2,-28(fp)
 4001284:	1885883a 	add	r2,r3,r2
 4001288:	e0bff90d 	sth	r2,-28(fp)
    LCD_SetPoint(x0,y0,color);
  }  
  else
  {
    temp = 2 * dx - dy;
    while( y0 != y1 )
 400128c:	e0fffc0b 	ldhu	r3,-16(fp)
 4001290:	e0bffe0b 	ldhu	r2,-8(fp)
 4001294:	18bfe11e 	bne	r3,r2,400121c <LCD_DrawLine+0x1d4>
      else
            {
        temp += 2 * dy;
            }
    } 
    LCD_SetPoint(x0,y0,color);
 4001298:	e13ffb0b 	ldhu	r4,-20(fp)
 400129c:	e17ffc0b 	ldhu	r5,-16(fp)
 40012a0:	e1bfff0b 	ldhu	r6,-4(fp)
 40012a4:	4000fe40 	call	4000fe4 <LCD_SetPoint>
    }
} 
 40012a8:	e037883a 	mov	sp,fp
 40012ac:	dfc00117 	ldw	ra,4(sp)
 40012b0:	df000017 	ldw	fp,0(sp)
 40012b4:	dec00204 	addi	sp,sp,8
 40012b8:	f800283a 	ret

040012bc <PutChar>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void PutChar( alt_u16 Xpos, alt_u16 Ypos, alt_u8 ASCI, alt_u16 charColor, alt_u16 bkColor )
{
 40012bc:	defff304 	addi	sp,sp,-52
 40012c0:	dfc00c15 	stw	ra,48(sp)
 40012c4:	df000b15 	stw	fp,44(sp)
 40012c8:	df000b04 	addi	fp,sp,44
 40012cc:	e0800217 	ldw	r2,8(fp)
 40012d0:	e13ffb0d 	sth	r4,-20(fp)
 40012d4:	e17ffc0d 	sth	r5,-16(fp)
 40012d8:	e1bffd05 	stb	r6,-12(fp)
 40012dc:	e1fffe0d 	sth	r7,-8(fp)
 40012e0:	e0bfff0d 	sth	r2,-4(fp)
    alt_u16 i, j;
    alt_u8 buffer[16], tmp_char;
    GetASCIICode(buffer,ASCI);
 40012e4:	e17ffd03 	ldbu	r5,-12(fp)
 40012e8:	e13ff684 	addi	r4,fp,-38
 40012ec:	40001ec0 	call	40001ec <GetASCIICode>
    for( i=0; i<16; i++ )
 40012f0:	e03ff60d 	sth	zero,-40(fp)
 40012f4:	00002e06 	br	40013b0 <PutChar+0xf4>
    {
        tmp_char = buffer[i];
 40012f8:	e0fff60b 	ldhu	r3,-40(fp)
 40012fc:	e0bff684 	addi	r2,fp,-38
 4001300:	10c5883a 	add	r2,r2,r3
 4001304:	10800003 	ldbu	r2,0(r2)
 4001308:	e0bff505 	stb	r2,-44(fp)
        for( j=0; j<8; j++ )
 400130c:	e03ff58d 	sth	zero,-42(fp)
 4001310:	00002106 	br	4001398 <PutChar+0xdc>
        {
            if( (tmp_char >> 7 - j) & 0x01 == 0x01 )
 4001314:	e13ff503 	ldbu	r4,-44(fp)
 4001318:	e0fff58b 	ldhu	r3,-42(fp)
 400131c:	008001c4 	movi	r2,7
 4001320:	10c5c83a 	sub	r2,r2,r3
 4001324:	2085d83a 	sra	r2,r4,r2
 4001328:	1080004c 	andi	r2,r2,1
 400132c:	10803fcc 	andi	r2,r2,255
 4001330:	1005003a 	cmpeq	r2,r2,zero
 4001334:	10000b1e 	bne	r2,zero,4001364 <PutChar+0xa8>
            {
                LCD_SetPoint( Xpos + j, Ypos + i, charColor );
 4001338:	e0fffb0b 	ldhu	r3,-20(fp)
 400133c:	e0bff58b 	ldhu	r2,-42(fp)
 4001340:	1885883a 	add	r2,r3,r2
 4001344:	113fffcc 	andi	r4,r2,65535
 4001348:	e0fffc0b 	ldhu	r3,-16(fp)
 400134c:	e0bff60b 	ldhu	r2,-40(fp)
 4001350:	1885883a 	add	r2,r3,r2
 4001354:	117fffcc 	andi	r5,r2,65535
 4001358:	e1bffe0b 	ldhu	r6,-8(fp)
 400135c:	4000fe40 	call	4000fe4 <LCD_SetPoint>
 4001360:	00000a06 	br	400138c <PutChar+0xd0>
            }
            else
            {
                LCD_SetPoint( Xpos + j, Ypos + i, bkColor );
 4001364:	e0fffb0b 	ldhu	r3,-20(fp)
 4001368:	e0bff58b 	ldhu	r2,-42(fp)
 400136c:	1885883a 	add	r2,r3,r2
 4001370:	113fffcc 	andi	r4,r2,65535
 4001374:	e0fffc0b 	ldhu	r3,-16(fp)
 4001378:	e0bff60b 	ldhu	r2,-40(fp)
 400137c:	1885883a 	add	r2,r3,r2
 4001380:	117fffcc 	andi	r5,r2,65535
 4001384:	e1bfff0b 	ldhu	r6,-4(fp)
 4001388:	4000fe40 	call	4000fe4 <LCD_SetPoint>
    alt_u8 buffer[16], tmp_char;
    GetASCIICode(buffer,ASCI);
    for( i=0; i<16; i++ )
    {
        tmp_char = buffer[i];
        for( j=0; j<8; j++ )
 400138c:	e0bff58b 	ldhu	r2,-42(fp)
 4001390:	10800044 	addi	r2,r2,1
 4001394:	e0bff58d 	sth	r2,-42(fp)
 4001398:	e0bff58b 	ldhu	r2,-42(fp)
 400139c:	10800230 	cmpltui	r2,r2,8
 40013a0:	103fdc1e 	bne	r2,zero,4001314 <PutChar+0x58>
void PutChar( alt_u16 Xpos, alt_u16 Ypos, alt_u8 ASCI, alt_u16 charColor, alt_u16 bkColor )
{
    alt_u16 i, j;
    alt_u8 buffer[16], tmp_char;
    GetASCIICode(buffer,ASCI);
    for( i=0; i<16; i++ )
 40013a4:	e0bff60b 	ldhu	r2,-40(fp)
 40013a8:	10800044 	addi	r2,r2,1
 40013ac:	e0bff60d 	sth	r2,-40(fp)
 40013b0:	e0bff60b 	ldhu	r2,-40(fp)
 40013b4:	10800430 	cmpltui	r2,r2,16
 40013b8:	103fcf1e 	bne	r2,zero,40012f8 <PutChar+0x3c>
            {
                LCD_SetPoint( Xpos + j, Ypos + i, bkColor );
            }
        }
    }
}
 40013bc:	e037883a 	mov	sp,fp
 40013c0:	dfc00117 	ldw	ra,4(sp)
 40013c4:	df000017 	ldw	fp,0(sp)
 40013c8:	dec00204 	addi	sp,sp,8
 40013cc:	f800283a 	ret

040013d0 <GUI_Text>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void GUI_Text(alt_u16 Xpos, alt_u16 Ypos, alt_u8 *str,alt_u16 Color, alt_u16 bkColor)
{
 40013d0:	defff704 	addi	sp,sp,-36
 40013d4:	dfc00815 	stw	ra,32(sp)
 40013d8:	df000715 	stw	fp,28(sp)
 40013dc:	df000704 	addi	fp,sp,28
 40013e0:	e1bffd15 	stw	r6,-12(fp)
 40013e4:	e0800217 	ldw	r2,8(fp)
 40013e8:	e13ffb0d 	sth	r4,-20(fp)
 40013ec:	e17ffc0d 	sth	r5,-16(fp)
 40013f0:	e1fffe0d 	sth	r7,-8(fp)
 40013f4:	e0bfff0d 	sth	r2,-4(fp)
    alt_u8 TempChar;
    do
    {
        TempChar = *str++;  
 40013f8:	e0bffd17 	ldw	r2,-12(fp)
 40013fc:	10800003 	ldbu	r2,0(r2)
 4001400:	e0bffa05 	stb	r2,-24(fp)
 4001404:	e0bffd17 	ldw	r2,-12(fp)
 4001408:	10800044 	addi	r2,r2,1
 400140c:	e0bffd15 	stw	r2,-12(fp)
        PutChar( Xpos, Ypos, TempChar, Color, bkColor );    
 4001410:	e13ffb0b 	ldhu	r4,-20(fp)
 4001414:	e17ffc0b 	ldhu	r5,-16(fp)
 4001418:	e1bffa03 	ldbu	r6,-24(fp)
 400141c:	e1fffe0b 	ldhu	r7,-8(fp)
 4001420:	e0bfff0b 	ldhu	r2,-4(fp)
 4001424:	d8800015 	stw	r2,0(sp)
 4001428:	40012bc0 	call	40012bc <PutChar>
        if( Xpos < MAX_X - 8 )
 400142c:	e0bffb0b 	ldhu	r2,-20(fp)
 4001430:	10804e28 	cmpgeui	r2,r2,312
 4001434:	1000041e 	bne	r2,zero,4001448 <GUI_Text+0x78>
        {
            Xpos += 8;
 4001438:	e0bffb0b 	ldhu	r2,-20(fp)
 400143c:	10800204 	addi	r2,r2,8
 4001440:	e0bffb0d 	sth	r2,-20(fp)
 4001444:	00000a06 	br	4001470 <GUI_Text+0xa0>
        } 
        else if ( Ypos < MAX_Y - 16 )
 4001448:	e0bffc0b 	ldhu	r2,-16(fp)
 400144c:	10803828 	cmpgeui	r2,r2,224
 4001450:	1000051e 	bne	r2,zero,4001468 <GUI_Text+0x98>
        {
            Xpos = 0;
 4001454:	e03ffb0d 	sth	zero,-20(fp)
            Ypos += 16;
 4001458:	e0bffc0b 	ldhu	r2,-16(fp)
 400145c:	10800404 	addi	r2,r2,16
 4001460:	e0bffc0d 	sth	r2,-16(fp)
 4001464:	00000206 	br	4001470 <GUI_Text+0xa0>
        }   
        else
        {
            Xpos = 0;
 4001468:	e03ffb0d 	sth	zero,-20(fp)
            Ypos = 0;
 400146c:	e03ffc0d 	sth	zero,-16(fp)
        }    
    }
    while ( *str != 0 );
 4001470:	e0bffd17 	ldw	r2,-12(fp)
 4001474:	10800003 	ldbu	r2,0(r2)
 4001478:	10803fcc 	andi	r2,r2,255
 400147c:	1004c03a 	cmpne	r2,r2,zero
 4001480:	103fdd1e 	bne	r2,zero,40013f8 <GUI_Text+0x28>
}
 4001484:	e037883a 	mov	sp,fp
 4001488:	dfc00117 	ldw	ra,4(sp)
 400148c:	df000017 	ldw	fp,0(sp)
 4001490:	dec00204 	addi	sp,sp,8
 4001494:	f800283a 	ret

04001498 <main>:
#include "touch.h"
#define msleep(ms)  usleep(1000*ms)
#define DIRECTION_PA(data)  IOWR_ALTERA_AVALON_PIO_DIRECTION(PA_BASE, data)
#define DATA_PA(data)  IOWR_ALTERA_AVALON_PIO_DATA(PA_BASE, data)
int main(void)
{     
 4001498:	defffe04 	addi	sp,sp,-8
 400149c:	dfc00115 	stw	ra,4(sp)
 40014a0:	df000015 	stw	fp,0(sp)
 40014a4:	d839883a 	mov	fp,sp
       //IOWR_ALTERA_AVALON_PIO_DATA(VCC_BASE, 1);
       //IOWR_ALTERA_AVALON_PIO_DATA(GND_BASE, 0);
       IOWR_ALTERA_AVALON_PIO_DATA(BL_P_BASE, 1);
 40014a8:	00861404 	movi	r2,6224
 40014ac:	00c00044 	movi	r3,1
 40014b0:	10c00035 	stwio	r3,0(r2)
       IOWR_ALTERA_AVALON_PIO_DATA(BL_N_BASE, 0);
 40014b4:	00861004 	movi	r2,6208
 40014b8:	10000035 	stwio	zero,0(r2)
       
       TP_Init(); 
 40014bc:	400154c0 	call	400154c <TP_Init>
	   LCD_Initializtion();
 40014c0:	40005480 	call	4000548 <LCD_Initializtion>
       
       LCD_Clear(Blue);
 40014c4:	010007c4 	movi	r4,31
 40014c8:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(Yellow);
 40014cc:	013ff814 	movui	r4,65504
 40014d0:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(White);
 40014d4:	013fffd4 	movui	r4,65535
 40014d8:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(Black);
 40014dc:	0009883a 	mov	r4,zero
 40014e0:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(Magenta);
 40014e4:	013e07d4 	movui	r4,63519
 40014e8:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(Red);
 40014ec:	013e0014 	movui	r4,63488
 40014f0:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(Green);
 40014f4:	0101f804 	movi	r4,2016
 40014f8:	4000bcc0 	call	4000bcc <LCD_Clear>
       LCD_Clear(Cyan);
 40014fc:	011fffc4 	movi	r4,32767
 4001500:	4000bcc0 	call	4000bcc <LCD_Clear>
        
     // LCD_show_test();
         
        TouchPanel_Calibrate(); 
 4001504:	40028180 	call	4002818 <TouchPanel_Calibrate>
   
    while (1)  
  {
    getDisplayPoint(&display, Read_Ads7846(), &matrix ) ;
 4001508:	4001b480 	call	4001b48 <Read_Ads7846>
 400150c:	100b883a 	mov	r5,r2
 4001510:	01010074 	movhi	r4,1025
 4001514:	21253284 	addi	r4,r4,-27446
 4001518:	01810074 	movhi	r6,1025
 400151c:	31a53e04 	addi	r6,r6,-27400
 4001520:	40025300 	call	4002530 <getDisplayPoint>
    TP_DrawPoint(display.x,display.y);
 4001524:	00810074 	movhi	r2,1025
 4001528:	10a53284 	addi	r2,r2,-27446
 400152c:	1080000b 	ldhu	r2,0(r2)
 4001530:	113fffcc 	andi	r4,r2,65535
 4001534:	00810074 	movhi	r2,1025
 4001538:	10a53284 	addi	r2,r2,-27446
 400153c:	1080008b 	ldhu	r2,2(r2)
 4001540:	117fffcc 	andi	r5,r2,65535
 4001544:	40017d00 	call	40017d0 <TP_DrawPoint>
  }
 4001548:	003fef06 	br	4001508 <main+0x70>

0400154c <TP_Init>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void TP_Init(void) 
{
 400154c:	deffff04 	addi	sp,sp,-4
 4001550:	df000015 	stw	fp,0(sp)
 4001554:	d839883a 	mov	fp,sp
  TP_CS(1); 
 4001558:	00863004 	movi	r2,6336
 400155c:	00c00044 	movi	r3,1
 4001560:	10c00035 	stwio	r3,0(r2)
  TOUCH_SPI_INIT; 
 4001564:	00860304 	movi	r2,6156
 4001568:	10000035 	stwio	zero,0(r2)
} 
 400156c:	e037883a 	mov	sp,fp
 4001570:	df000017 	ldw	fp,0(sp)
 4001574:	dec00104 	addi	sp,sp,4
 4001578:	f800283a 	ret

0400157c <DelayUS>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void DelayUS(alt_u32 cnt)
{
 400157c:	defffd04 	addi	sp,sp,-12
 4001580:	dfc00215 	stw	ra,8(sp)
 4001584:	df000115 	stw	fp,4(sp)
 4001588:	df000104 	addi	fp,sp,4
 400158c:	e13fff15 	stw	r4,-4(fp)
   usleep(cnt);
 4001590:	e13fff17 	ldw	r4,-4(fp)
 4001594:	4003fc00 	call	4003fc0 <usleep>
}
 4001598:	e037883a 	mov	sp,fp
 400159c:	dfc00117 	ldw	ra,4(sp)
 40015a0:	df000017 	ldw	fp,0(sp)
 40015a4:	dec00204 	addi	sp,sp,8
 40015a8:	f800283a 	ret

040015ac <WR_CMD>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void WR_CMD (alt_u8 cmd)  
{ 
 40015ac:	defffa04 	addi	sp,sp,-24
 40015b0:	dfc00515 	stw	ra,20(sp)
 40015b4:	df000415 	stw	fp,16(sp)
 40015b8:	df000404 	addi	fp,sp,16
 40015bc:	e13fff05 	stb	r4,-4(fp)
 alt_avalon_spi_command(SPI_TOUCH_BASE,0,1,&cmd,0,NULL,ALT_AVALON_SPI_COMMAND_MERGE);
 40015c0:	d8000015 	stw	zero,0(sp)
 40015c4:	d8000115 	stw	zero,4(sp)
 40015c8:	00800044 	movi	r2,1
 40015cc:	d8800215 	stw	r2,8(sp)
 40015d0:	01060004 	movi	r4,6144
 40015d4:	000b883a 	mov	r5,zero
 40015d8:	01800044 	movi	r6,1
 40015dc:	e1ffff04 	addi	r7,fp,-4
 40015e0:	400553c0 	call	400553c <alt_avalon_spi_command>
} 
 40015e4:	e037883a 	mov	sp,fp
 40015e8:	dfc00117 	ldw	ra,4(sp)
 40015ec:	df000017 	ldw	fp,0(sp)
 40015f0:	dec00204 	addi	sp,sp,8
 40015f4:	f800283a 	ret

040015f8 <RD_AD>:
* Output         : None
* Return         : 
* Attention      : None
*******************************************************************************/
int RD_AD(void)  
{ 
 40015f8:	defffa04 	addi	sp,sp,-24
 40015fc:	dfc00515 	stw	ra,20(sp)
 4001600:	df000415 	stw	fp,16(sp)
 4001604:	df000404 	addi	fp,sp,16
  unsigned short buf; 
  alt_u8 temp;
  alt_avalon_spi_command(SPI_TOUCH_BASE,0,0,NULL,1,&temp,ALT_AVALON_SPI_COMMAND_MERGE);
 4001608:	00800044 	movi	r2,1
 400160c:	d8800015 	stw	r2,0(sp)
 4001610:	e0bfff84 	addi	r2,fp,-2
 4001614:	d8800115 	stw	r2,4(sp)
 4001618:	00800044 	movi	r2,1
 400161c:	d8800215 	stw	r2,8(sp)
 4001620:	01060004 	movi	r4,6144
 4001624:	000b883a 	mov	r5,zero
 4001628:	000d883a 	mov	r6,zero
 400162c:	000f883a 	mov	r7,zero
 4001630:	400553c0 	call	400553c <alt_avalon_spi_command>
   
  buf=((alt_u16)temp)<<8; 
 4001634:	e0bfff83 	ldbu	r2,-2(fp)
 4001638:	10803fcc 	andi	r2,r2,255
 400163c:	1004923a 	slli	r2,r2,8
 4001640:	e0bfff0d 	sth	r2,-4(fp)
  DelayUS(1);
 4001644:	01000044 	movi	r4,1
 4001648:	400157c0 	call	400157c <DelayUS>
   
  alt_avalon_spi_command(SPI_TOUCH_BASE,0,0,NULL,1,&temp,ALT_AVALON_SPI_COMMAND_MERGE);
 400164c:	00800044 	movi	r2,1
 4001650:	d8800015 	stw	r2,0(sp)
 4001654:	e0bfff84 	addi	r2,fp,-2
 4001658:	d8800115 	stw	r2,4(sp)
 400165c:	00800044 	movi	r2,1
 4001660:	d8800215 	stw	r2,8(sp)
 4001664:	01060004 	movi	r4,6144
 4001668:	000b883a 	mov	r5,zero
 400166c:	000d883a 	mov	r6,zero
 4001670:	000f883a 	mov	r7,zero
 4001674:	400553c0 	call	400553c <alt_avalon_spi_command>
  
  buf |=(alt_u16)temp; 
 4001678:	e0bfff83 	ldbu	r2,-2(fp)
 400167c:	10c03fcc 	andi	r3,r2,255
 4001680:	e0bfff0b 	ldhu	r2,-4(fp)
 4001684:	10c4b03a 	or	r2,r2,r3
 4001688:	e0bfff0d 	sth	r2,-4(fp)
  
  buf>>=3; 
 400168c:	e0bfff0b 	ldhu	r2,-4(fp)
 4001690:	1004d0fa 	srli	r2,r2,3
 4001694:	e0bfff0d 	sth	r2,-4(fp)
  buf&=0xfff; 
 4001698:	e0bfff0b 	ldhu	r2,-4(fp)
 400169c:	1083ffcc 	andi	r2,r2,4095
 40016a0:	e0bfff0d 	sth	r2,-4(fp)
  return buf; 
 40016a4:	e0bfff0b 	ldhu	r2,-4(fp)
} 
 40016a8:	e037883a 	mov	sp,fp
 40016ac:	dfc00117 	ldw	ra,4(sp)
 40016b0:	df000017 	ldw	fp,0(sp)
 40016b4:	dec00204 	addi	sp,sp,8
 40016b8:	f800283a 	ret

040016bc <Read_X>:
* Output         : None
* Return         : 
* Attention      : None
*******************************************************************************/
int Read_X(void)  
{  
 40016bc:	defffd04 	addi	sp,sp,-12
 40016c0:	dfc00215 	stw	ra,8(sp)
 40016c4:	df000115 	stw	fp,4(sp)
 40016c8:	df000104 	addi	fp,sp,4
  int i; 
  TP_CS(0); 
 40016cc:	00863004 	movi	r2,6336
 40016d0:	10000035 	stwio	zero,0(r2)
  DelayUS(1); 
 40016d4:	01000044 	movi	r4,1
 40016d8:	400157c0 	call	400157c <DelayUS>
  WR_CMD(CHX); 
 40016dc:	01002404 	movi	r4,144
 40016e0:	40015ac0 	call	40015ac <WR_CMD>
  DelayUS(1); 
 40016e4:	01000044 	movi	r4,1
 40016e8:	400157c0 	call	400157c <DelayUS>
  i=RD_AD(); 
 40016ec:	40015f80 	call	40015f8 <RD_AD>
 40016f0:	e0bfff15 	stw	r2,-4(fp)
  TP_CS(1); 
 40016f4:	00c63004 	movi	r3,6336
 40016f8:	00800044 	movi	r2,1
 40016fc:	18800035 	stwio	r2,0(r3)
  return i;    
 4001700:	e0bfff17 	ldw	r2,-4(fp)
} 
 4001704:	e037883a 	mov	sp,fp
 4001708:	dfc00117 	ldw	ra,4(sp)
 400170c:	df000017 	ldw	fp,0(sp)
 4001710:	dec00204 	addi	sp,sp,8
 4001714:	f800283a 	ret

04001718 <Read_Y>:
* Output         : None
* Return         : 
* Attention      : None
*******************************************************************************/
int Read_Y(void)  
{  
 4001718:	defffd04 	addi	sp,sp,-12
 400171c:	dfc00215 	stw	ra,8(sp)
 4001720:	df000115 	stw	fp,4(sp)
 4001724:	df000104 	addi	fp,sp,4
  int i; 
  TP_CS(0); 
 4001728:	00863004 	movi	r2,6336
 400172c:	10000035 	stwio	zero,0(r2)
  DelayUS(1); 
 4001730:	01000044 	movi	r4,1
 4001734:	400157c0 	call	400157c <DelayUS>
  WR_CMD(CHY); 
 4001738:	01003404 	movi	r4,208
 400173c:	40015ac0 	call	40015ac <WR_CMD>
  DelayUS(1); 
 4001740:	01000044 	movi	r4,1
 4001744:	400157c0 	call	400157c <DelayUS>
  i=RD_AD(); 
 4001748:	40015f80 	call	40015f8 <RD_AD>
 400174c:	e0bfff15 	stw	r2,-4(fp)
  TP_CS(1); 
 4001750:	00c63004 	movi	r3,6336
 4001754:	00800044 	movi	r2,1
 4001758:	18800035 	stwio	r2,0(r3)
  return i;     
 400175c:	e0bfff17 	ldw	r2,-4(fp)
} 
 4001760:	e037883a 	mov	sp,fp
 4001764:	dfc00117 	ldw	ra,4(sp)
 4001768:	df000017 	ldw	fp,0(sp)
 400176c:	dec00204 	addi	sp,sp,8
 4001770:	f800283a 	ret

04001774 <TP_GetAdXY>:
* Output         : None
* Return         : 
* Attention      : None
*******************************************************************************/
void TP_GetAdXY(int *x,int *y)  
{ 
 4001774:	defffa04 	addi	sp,sp,-24
 4001778:	dfc00515 	stw	ra,20(sp)
 400177c:	df000415 	stw	fp,16(sp)
 4001780:	df000404 	addi	fp,sp,16
 4001784:	e13ffe15 	stw	r4,-8(fp)
 4001788:	e17fff15 	stw	r5,-4(fp)
  int adx,ady; 
  adx=Read_X(); 
 400178c:	40016bc0 	call	40016bc <Read_X>
 4001790:	e0bffd15 	stw	r2,-12(fp)
  DelayUS(1); 
 4001794:	01000044 	movi	r4,1
 4001798:	400157c0 	call	400157c <DelayUS>
  ady=Read_Y(); 
 400179c:	40017180 	call	4001718 <Read_Y>
 40017a0:	e0bffc15 	stw	r2,-16(fp)
  *x=adx; 
 40017a4:	e0fffe17 	ldw	r3,-8(fp)
 40017a8:	e0bffd17 	ldw	r2,-12(fp)
 40017ac:	18800015 	stw	r2,0(r3)
  *y=ady; 
 40017b0:	e0ffff17 	ldw	r3,-4(fp)
 40017b4:	e0bffc17 	ldw	r2,-16(fp)
 40017b8:	18800015 	stw	r2,0(r3)
} 
 40017bc:	e037883a 	mov	sp,fp
 40017c0:	dfc00117 	ldw	ra,4(sp)
 40017c4:	df000017 	ldw	fp,0(sp)
 40017c8:	dec00204 	addi	sp,sp,8
 40017cc:	f800283a 	ret

040017d0 <TP_DrawPoint>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void TP_DrawPoint(alt_u32 Xpos,alt_u32 Ypos)
{
 40017d0:	defffc04 	addi	sp,sp,-16
 40017d4:	dfc00315 	stw	ra,12(sp)
 40017d8:	df000215 	stw	fp,8(sp)
 40017dc:	df000204 	addi	fp,sp,8
 40017e0:	e13ffe15 	stw	r4,-8(fp)
 40017e4:	e17fff15 	stw	r5,-4(fp)
  LCD_SetPoint(Xpos,Ypos,Blue);     /* Center point */
 40017e8:	e0bffe17 	ldw	r2,-8(fp)
 40017ec:	113fffcc 	andi	r4,r2,65535
 40017f0:	e0bfff17 	ldw	r2,-4(fp)
 40017f4:	117fffcc 	andi	r5,r2,65535
 40017f8:	018007c4 	movi	r6,31
 40017fc:	4000fe40 	call	4000fe4 <LCD_SetPoint>
  LCD_SetPoint(Xpos+1,Ypos,Blue);
 4001800:	e0bffe17 	ldw	r2,-8(fp)
 4001804:	10800044 	addi	r2,r2,1
 4001808:	113fffcc 	andi	r4,r2,65535
 400180c:	e0bfff17 	ldw	r2,-4(fp)
 4001810:	117fffcc 	andi	r5,r2,65535
 4001814:	018007c4 	movi	r6,31
 4001818:	4000fe40 	call	4000fe4 <LCD_SetPoint>
  LCD_SetPoint(Xpos,Ypos+1,Blue);
 400181c:	e0bffe17 	ldw	r2,-8(fp)
 4001820:	113fffcc 	andi	r4,r2,65535
 4001824:	e0bfff17 	ldw	r2,-4(fp)
 4001828:	10800044 	addi	r2,r2,1
 400182c:	117fffcc 	andi	r5,r2,65535
 4001830:	018007c4 	movi	r6,31
 4001834:	4000fe40 	call	4000fe4 <LCD_SetPoint>
  LCD_SetPoint(Xpos+1,Ypos+1,Blue); 
 4001838:	e0bffe17 	ldw	r2,-8(fp)
 400183c:	10800044 	addi	r2,r2,1
 4001840:	113fffcc 	andi	r4,r2,65535
 4001844:	e0bfff17 	ldw	r2,-4(fp)
 4001848:	10800044 	addi	r2,r2,1
 400184c:	117fffcc 	andi	r5,r2,65535
 4001850:	018007c4 	movi	r6,31
 4001854:	4000fe40 	call	4000fe4 <LCD_SetPoint>
}   
 4001858:	e037883a 	mov	sp,fp
 400185c:	dfc00117 	ldw	ra,4(sp)
 4001860:	df000017 	ldw	fp,0(sp)
 4001864:	dec00204 	addi	sp,sp,8
 4001868:	f800283a 	ret

0400186c <DrawCross>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void DrawCross(alt_u32 Xpos,alt_u32 Ypos)
{
 400186c:	defffb04 	addi	sp,sp,-20
 4001870:	dfc00415 	stw	ra,16(sp)
 4001874:	df000315 	stw	fp,12(sp)
 4001878:	df000304 	addi	fp,sp,12
 400187c:	e13ffe15 	stw	r4,-8(fp)
 4001880:	e17fff15 	stw	r5,-4(fp)
  LCD_DrawLine(Xpos-15,Ypos,Xpos-2,Ypos,Red);
 4001884:	e0bffe17 	ldw	r2,-8(fp)
 4001888:	10bffc44 	addi	r2,r2,-15
 400188c:	113fffcc 	andi	r4,r2,65535
 4001890:	e0bfff17 	ldw	r2,-4(fp)
 4001894:	117fffcc 	andi	r5,r2,65535
 4001898:	e0bffe17 	ldw	r2,-8(fp)
 400189c:	10bfff84 	addi	r2,r2,-2
 40018a0:	11bfffcc 	andi	r6,r2,65535
 40018a4:	e0bfff17 	ldw	r2,-4(fp)
 40018a8:	11ffffcc 	andi	r7,r2,65535
 40018ac:	00be0014 	movui	r2,63488
 40018b0:	d8800015 	stw	r2,0(sp)
 40018b4:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos+2,Ypos,Xpos+15,Ypos,Red);
 40018b8:	e0bffe17 	ldw	r2,-8(fp)
 40018bc:	10800084 	addi	r2,r2,2
 40018c0:	113fffcc 	andi	r4,r2,65535
 40018c4:	e0bfff17 	ldw	r2,-4(fp)
 40018c8:	117fffcc 	andi	r5,r2,65535
 40018cc:	e0bffe17 	ldw	r2,-8(fp)
 40018d0:	108003c4 	addi	r2,r2,15
 40018d4:	11bfffcc 	andi	r6,r2,65535
 40018d8:	e0bfff17 	ldw	r2,-4(fp)
 40018dc:	11ffffcc 	andi	r7,r2,65535
 40018e0:	00be0014 	movui	r2,63488
 40018e4:	d8800015 	stw	r2,0(sp)
 40018e8:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos,Ypos-15,Xpos,Ypos-2,Red);
 40018ec:	e0bffe17 	ldw	r2,-8(fp)
 40018f0:	113fffcc 	andi	r4,r2,65535
 40018f4:	e0bfff17 	ldw	r2,-4(fp)
 40018f8:	10bffc44 	addi	r2,r2,-15
 40018fc:	117fffcc 	andi	r5,r2,65535
 4001900:	e0bffe17 	ldw	r2,-8(fp)
 4001904:	11bfffcc 	andi	r6,r2,65535
 4001908:	e0bfff17 	ldw	r2,-4(fp)
 400190c:	10bfff84 	addi	r2,r2,-2
 4001910:	11ffffcc 	andi	r7,r2,65535
 4001914:	00be0014 	movui	r2,63488
 4001918:	d8800015 	stw	r2,0(sp)
 400191c:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos,Ypos+2,Xpos,Ypos+15,Red);
 4001920:	e0bffe17 	ldw	r2,-8(fp)
 4001924:	113fffcc 	andi	r4,r2,65535
 4001928:	e0bfff17 	ldw	r2,-4(fp)
 400192c:	10800084 	addi	r2,r2,2
 4001930:	117fffcc 	andi	r5,r2,65535
 4001934:	e0bffe17 	ldw	r2,-8(fp)
 4001938:	11bfffcc 	andi	r6,r2,65535
 400193c:	e0bfff17 	ldw	r2,-4(fp)
 4001940:	108003c4 	addi	r2,r2,15
 4001944:	11ffffcc 	andi	r7,r2,65535
 4001948:	00be0014 	movui	r2,63488
 400194c:	d8800015 	stw	r2,0(sp)
 4001950:	40010480 	call	4001048 <LCD_DrawLine>
  
  LCD_DrawLine(Xpos-15,Ypos+15,Xpos-7,Ypos+15,RGB565CONVERT(184,158,131));
 4001954:	e0bffe17 	ldw	r2,-8(fp)
 4001958:	10bffc44 	addi	r2,r2,-15
 400195c:	113fffcc 	andi	r4,r2,65535
 4001960:	e0bfff17 	ldw	r2,-4(fp)
 4001964:	108003c4 	addi	r2,r2,15
 4001968:	117fffcc 	andi	r5,r2,65535
 400196c:	e0bffe17 	ldw	r2,-8(fp)
 4001970:	10bffe44 	addi	r2,r2,-7
 4001974:	11bfffcc 	andi	r6,r2,65535
 4001978:	e0bfff17 	ldw	r2,-4(fp)
 400197c:	108003c4 	addi	r2,r2,15
 4001980:	11ffffcc 	andi	r7,r2,65535
 4001984:	00af3c14 	movui	r2,48368
 4001988:	d8800015 	stw	r2,0(sp)
 400198c:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos-15,Ypos+7,Xpos-15,Ypos+15,RGB565CONVERT(184,158,131));
 4001990:	e0bffe17 	ldw	r2,-8(fp)
 4001994:	10bffc44 	addi	r2,r2,-15
 4001998:	113fffcc 	andi	r4,r2,65535
 400199c:	e0bfff17 	ldw	r2,-4(fp)
 40019a0:	108001c4 	addi	r2,r2,7
 40019a4:	117fffcc 	andi	r5,r2,65535
 40019a8:	e0bffe17 	ldw	r2,-8(fp)
 40019ac:	10bffc44 	addi	r2,r2,-15
 40019b0:	11bfffcc 	andi	r6,r2,65535
 40019b4:	e0bfff17 	ldw	r2,-4(fp)
 40019b8:	108003c4 	addi	r2,r2,15
 40019bc:	11ffffcc 	andi	r7,r2,65535
 40019c0:	00af3c14 	movui	r2,48368
 40019c4:	d8800015 	stw	r2,0(sp)
 40019c8:	40010480 	call	4001048 <LCD_DrawLine>

  LCD_DrawLine(Xpos-15,Ypos-15,Xpos-7,Ypos-15,RGB565CONVERT(184,158,131));
 40019cc:	e0bffe17 	ldw	r2,-8(fp)
 40019d0:	10bffc44 	addi	r2,r2,-15
 40019d4:	113fffcc 	andi	r4,r2,65535
 40019d8:	e0bfff17 	ldw	r2,-4(fp)
 40019dc:	10bffc44 	addi	r2,r2,-15
 40019e0:	117fffcc 	andi	r5,r2,65535
 40019e4:	e0bffe17 	ldw	r2,-8(fp)
 40019e8:	10bffe44 	addi	r2,r2,-7
 40019ec:	11bfffcc 	andi	r6,r2,65535
 40019f0:	e0bfff17 	ldw	r2,-4(fp)
 40019f4:	10bffc44 	addi	r2,r2,-15
 40019f8:	11ffffcc 	andi	r7,r2,65535
 40019fc:	00af3c14 	movui	r2,48368
 4001a00:	d8800015 	stw	r2,0(sp)
 4001a04:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos-15,Ypos-7,Xpos-15,Ypos-15,RGB565CONVERT(184,158,131));
 4001a08:	e0bffe17 	ldw	r2,-8(fp)
 4001a0c:	10bffc44 	addi	r2,r2,-15
 4001a10:	113fffcc 	andi	r4,r2,65535
 4001a14:	e0bfff17 	ldw	r2,-4(fp)
 4001a18:	10bffe44 	addi	r2,r2,-7
 4001a1c:	117fffcc 	andi	r5,r2,65535
 4001a20:	e0bffe17 	ldw	r2,-8(fp)
 4001a24:	10bffc44 	addi	r2,r2,-15
 4001a28:	11bfffcc 	andi	r6,r2,65535
 4001a2c:	e0bfff17 	ldw	r2,-4(fp)
 4001a30:	10bffc44 	addi	r2,r2,-15
 4001a34:	11ffffcc 	andi	r7,r2,65535
 4001a38:	00af3c14 	movui	r2,48368
 4001a3c:	d8800015 	stw	r2,0(sp)
 4001a40:	40010480 	call	4001048 <LCD_DrawLine>

  LCD_DrawLine(Xpos+7,Ypos+15,Xpos+15,Ypos+15,RGB565CONVERT(184,158,131));
 4001a44:	e0bffe17 	ldw	r2,-8(fp)
 4001a48:	108001c4 	addi	r2,r2,7
 4001a4c:	113fffcc 	andi	r4,r2,65535
 4001a50:	e0bfff17 	ldw	r2,-4(fp)
 4001a54:	108003c4 	addi	r2,r2,15
 4001a58:	117fffcc 	andi	r5,r2,65535
 4001a5c:	e0bffe17 	ldw	r2,-8(fp)
 4001a60:	108003c4 	addi	r2,r2,15
 4001a64:	11bfffcc 	andi	r6,r2,65535
 4001a68:	e0bfff17 	ldw	r2,-4(fp)
 4001a6c:	108003c4 	addi	r2,r2,15
 4001a70:	11ffffcc 	andi	r7,r2,65535
 4001a74:	00af3c14 	movui	r2,48368
 4001a78:	d8800015 	stw	r2,0(sp)
 4001a7c:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos+15,Ypos+7,Xpos+15,Ypos+15,RGB565CONVERT(184,158,131));
 4001a80:	e0bffe17 	ldw	r2,-8(fp)
 4001a84:	108003c4 	addi	r2,r2,15
 4001a88:	113fffcc 	andi	r4,r2,65535
 4001a8c:	e0bfff17 	ldw	r2,-4(fp)
 4001a90:	108001c4 	addi	r2,r2,7
 4001a94:	117fffcc 	andi	r5,r2,65535
 4001a98:	e0bffe17 	ldw	r2,-8(fp)
 4001a9c:	108003c4 	addi	r2,r2,15
 4001aa0:	11bfffcc 	andi	r6,r2,65535
 4001aa4:	e0bfff17 	ldw	r2,-4(fp)
 4001aa8:	108003c4 	addi	r2,r2,15
 4001aac:	11ffffcc 	andi	r7,r2,65535
 4001ab0:	00af3c14 	movui	r2,48368
 4001ab4:	d8800015 	stw	r2,0(sp)
 4001ab8:	40010480 	call	4001048 <LCD_DrawLine>

  LCD_DrawLine(Xpos+7,Ypos-15,Xpos+15,Ypos-15,RGB565CONVERT(184,158,131));
 4001abc:	e0bffe17 	ldw	r2,-8(fp)
 4001ac0:	108001c4 	addi	r2,r2,7
 4001ac4:	113fffcc 	andi	r4,r2,65535
 4001ac8:	e0bfff17 	ldw	r2,-4(fp)
 4001acc:	10bffc44 	addi	r2,r2,-15
 4001ad0:	117fffcc 	andi	r5,r2,65535
 4001ad4:	e0bffe17 	ldw	r2,-8(fp)
 4001ad8:	108003c4 	addi	r2,r2,15
 4001adc:	11bfffcc 	andi	r6,r2,65535
 4001ae0:	e0bfff17 	ldw	r2,-4(fp)
 4001ae4:	10bffc44 	addi	r2,r2,-15
 4001ae8:	11ffffcc 	andi	r7,r2,65535
 4001aec:	00af3c14 	movui	r2,48368
 4001af0:	d8800015 	stw	r2,0(sp)
 4001af4:	40010480 	call	4001048 <LCD_DrawLine>
  LCD_DrawLine(Xpos+15,Ypos-15,Xpos+15,Ypos-7,RGB565CONVERT(184,158,131));      
 4001af8:	e0bffe17 	ldw	r2,-8(fp)
 4001afc:	108003c4 	addi	r2,r2,15
 4001b00:	113fffcc 	andi	r4,r2,65535
 4001b04:	e0bfff17 	ldw	r2,-4(fp)
 4001b08:	10bffc44 	addi	r2,r2,-15
 4001b0c:	117fffcc 	andi	r5,r2,65535
 4001b10:	e0bffe17 	ldw	r2,-8(fp)
 4001b14:	108003c4 	addi	r2,r2,15
 4001b18:	11bfffcc 	andi	r6,r2,65535
 4001b1c:	e0bfff17 	ldw	r2,-4(fp)
 4001b20:	10bffe44 	addi	r2,r2,-7
 4001b24:	11ffffcc 	andi	r7,r2,65535
 4001b28:	00af3c14 	movui	r2,48368
 4001b2c:	d8800015 	stw	r2,0(sp)
 4001b30:	40010480 	call	4001048 <LCD_DrawLine>
}   
 4001b34:	e037883a 	mov	sp,fp
 4001b38:	dfc00117 	ldw	ra,4(sp)
 4001b3c:	df000017 	ldw	fp,0(sp)
 4001b40:	dec00204 	addi	sp,sp,8
 4001b44:	f800283a 	ret

04001b48 <Read_Ads7846>:
* Output         : None
* Return         : Coordinate *
* Attention      : None
*******************************************************************************/
Coordinate *Read_Ads7846(void)
{
 4001b48:	deffe804 	addi	sp,sp,-96
 4001b4c:	dfc01715 	stw	ra,92(sp)
 4001b50:	df001615 	stw	fp,88(sp)
 4001b54:	df001604 	addi	fp,sp,88
  static Coordinate  screen;
  int m0,m1,m2,TP_X[1],TP_Y[1],temp[3];
  alt_u8 count=0;
 4001b58:	e03fea05 	stb	zero,-88(fp)
  int buffer[2][3]={{0},{0}};
 4001b5c:	e03ff315 	stw	zero,-52(fp)
 4001b60:	e03ff415 	stw	zero,-48(fp)
 4001b64:	e03ff515 	stw	zero,-44(fp)
 4001b68:	e03ff615 	stw	zero,-40(fp)
 4001b6c:	e03ff715 	stw	zero,-36(fp)
 4001b70:	e03ff815 	stw	zero,-32(fp)
  
  do
  {        
    TP_GetAdXY(TP_X,TP_Y);  
 4001b74:	e13fee04 	addi	r4,fp,-72
 4001b78:	e17fef04 	addi	r5,fp,-68
 4001b7c:	40017740 	call	4001774 <TP_GetAdXY>
    buffer[0][count]=TP_X[0];  
 4001b80:	e0bfea03 	ldbu	r2,-88(fp)
 4001b84:	e0ffee17 	ldw	r3,-72(fp)
 4001b88:	1085883a 	add	r2,r2,r2
 4001b8c:	1085883a 	add	r2,r2,r2
 4001b90:	e13fea04 	addi	r4,fp,-88
 4001b94:	1105883a 	add	r2,r2,r4
 4001b98:	10800904 	addi	r2,r2,36
 4001b9c:	10c00015 	stw	r3,0(r2)
    buffer[1][count]=TP_Y[0];
 4001ba0:	e0bfea03 	ldbu	r2,-88(fp)
 4001ba4:	e0ffef17 	ldw	r3,-68(fp)
 4001ba8:	1085883a 	add	r2,r2,r2
 4001bac:	1085883a 	add	r2,r2,r2
 4001bb0:	e13fea04 	addi	r4,fp,-88
 4001bb4:	1105883a 	add	r2,r2,r4
 4001bb8:	10800c04 	addi	r2,r2,48
 4001bbc:	10c00015 	stw	r3,0(r2)
    count++;  
 4001bc0:	e0bfea03 	ldbu	r2,-88(fp)
 4001bc4:	10800044 	addi	r2,r2,1
 4001bc8:	e0bfea05 	stb	r2,-88(fp)
  }
  while(!TP_INT_IN&& count<3);  /* TP_INT_IN  */
 4001bcc:	00862804 	movi	r2,6304
 4001bd0:	10800037 	ldwio	r2,0(r2)
 4001bd4:	1004c03a 	cmpne	r2,r2,zero
 4001bd8:	1000031e 	bne	r2,zero,4001be8 <Read_Ads7846+0xa0>
 4001bdc:	e0bfea03 	ldbu	r2,-88(fp)
 4001be0:	108000f0 	cmpltui	r2,r2,3
 4001be4:	103fe31e 	bne	r2,zero,4001b74 <Read_Ads7846+0x2c>
  if(count==3)   /* Average X Y  */ 
 4001be8:	e0bfea03 	ldbu	r2,-88(fp)
 4001bec:	108000d8 	cmpnei	r2,r2,3
 4001bf0:	1000bf1e 	bne	r2,zero,4001ef0 <Read_Ads7846+0x3a8>
  {
    /* Average X  */
  temp[0]=buffer[0][0];
 4001bf4:	e0bff317 	ldw	r2,-52(fp)
 4001bf8:	e0bff015 	stw	r2,-64(fp)
    temp[1]=buffer[0][1];
 4001bfc:	e0bff417 	ldw	r2,-48(fp)
 4001c00:	e0bff115 	stw	r2,-60(fp)
    temp[2]=buffer[0][2];
 4001c04:	e0bff517 	ldw	r2,-44(fp)
 4001c08:	e0bff215 	stw	r2,-56(fp)

    m0=temp[0]-temp[1];
 4001c0c:	e0fff017 	ldw	r3,-64(fp)
 4001c10:	e0bff117 	ldw	r2,-60(fp)
 4001c14:	1885c83a 	sub	r2,r3,r2
 4001c18:	e0bfed15 	stw	r2,-76(fp)
    m1=temp[1]-temp[2];
 4001c1c:	e0fff117 	ldw	r3,-60(fp)
 4001c20:	e0bff217 	ldw	r2,-56(fp)
 4001c24:	1885c83a 	sub	r2,r3,r2
 4001c28:	e0bfec15 	stw	r2,-80(fp)
    m2=temp[2]-temp[0];
 4001c2c:	e0fff217 	ldw	r3,-56(fp)
 4001c30:	e0bff017 	ldw	r2,-64(fp)
 4001c34:	1885c83a 	sub	r2,r3,r2
 4001c38:	e0bfeb15 	stw	r2,-84(fp)

    m0=m0>0?m0:(-m0);
 4001c3c:	e0bfed17 	ldw	r2,-76(fp)
 4001c40:	e0bffa15 	stw	r2,-24(fp)
 4001c44:	e0fffa17 	ldw	r3,-24(fp)
 4001c48:	1804403a 	cmpge	r2,r3,zero
 4001c4c:	1000031e 	bne	r2,zero,4001c5c <Read_Ads7846+0x114>
 4001c50:	e13ffa17 	ldw	r4,-24(fp)
 4001c54:	0109c83a 	sub	r4,zero,r4
 4001c58:	e13ffa15 	stw	r4,-24(fp)
 4001c5c:	e0bffa17 	ldw	r2,-24(fp)
 4001c60:	e0bfed15 	stw	r2,-76(fp)
  m1=m1>0?m1:(-m1);
 4001c64:	e0ffec17 	ldw	r3,-80(fp)
 4001c68:	e0fffb15 	stw	r3,-20(fp)
 4001c6c:	e13ffb17 	ldw	r4,-20(fp)
 4001c70:	2004403a 	cmpge	r2,r4,zero
 4001c74:	1000031e 	bne	r2,zero,4001c84 <Read_Ads7846+0x13c>
 4001c78:	e0bffb17 	ldw	r2,-20(fp)
 4001c7c:	0085c83a 	sub	r2,zero,r2
 4001c80:	e0bffb15 	stw	r2,-20(fp)
 4001c84:	e0fffb17 	ldw	r3,-20(fp)
 4001c88:	e0ffec15 	stw	r3,-80(fp)
    m2=m2>0?m2:(-m2);
 4001c8c:	e13feb17 	ldw	r4,-84(fp)
 4001c90:	e13ffc15 	stw	r4,-16(fp)
 4001c94:	e0fffc17 	ldw	r3,-16(fp)
 4001c98:	1804403a 	cmpge	r2,r3,zero
 4001c9c:	1000031e 	bne	r2,zero,4001cac <Read_Ads7846+0x164>
 4001ca0:	e13ffc17 	ldw	r4,-16(fp)
 4001ca4:	0109c83a 	sub	r4,zero,r4
 4001ca8:	e13ffc15 	stw	r4,-16(fp)
 4001cac:	e0bffc17 	ldw	r2,-16(fp)
 4001cb0:	e0bfeb15 	stw	r2,-84(fp)

  //  if( m0>THRESHOLD  &&  m1>THRESHOLD  &&  m2>THRESHOLD ) return 0;

    if(m0<m1)
 4001cb4:	e0ffed17 	ldw	r3,-76(fp)
 4001cb8:	e0bfec17 	ldw	r2,-80(fp)
 4001cbc:	1880130e 	bge	r3,r2,4001d0c <Read_Ads7846+0x1c4>
    {
      if(m2<m0) 
 4001cc0:	e0ffeb17 	ldw	r3,-84(fp)
 4001cc4:	e0bfed17 	ldw	r2,-76(fp)
 4001cc8:	1880080e 	bge	r3,r2,4001cec <Read_Ads7846+0x1a4>
        screen.x=(temp[0]+temp[2])/2;
 4001ccc:	e0fff017 	ldw	r3,-64(fp)
 4001cd0:	e0bff217 	ldw	r2,-56(fp)
 4001cd4:	1887883a 	add	r3,r3,r2
 4001cd8:	1804d7fa 	srli	r2,r3,31
 4001cdc:	10c5883a 	add	r2,r2,r3
 4001ce0:	1005d07a 	srai	r2,r2,1
 4001ce4:	d0a00d8d 	sth	r2,-32714(gp)
 4001ce8:	00001a06 	br	4001d54 <Read_Ads7846+0x20c>
      else 
        screen.x=(temp[0]+temp[1])/2;   
 4001cec:	e0fff017 	ldw	r3,-64(fp)
 4001cf0:	e0bff117 	ldw	r2,-60(fp)
 4001cf4:	1887883a 	add	r3,r3,r2
 4001cf8:	1804d7fa 	srli	r2,r3,31
 4001cfc:	10c5883a 	add	r2,r2,r3
 4001d00:	1005d07a 	srai	r2,r2,1
 4001d04:	d0a00d8d 	sth	r2,-32714(gp)
 4001d08:	00001206 	br	4001d54 <Read_Ads7846+0x20c>
    }
    else if(m2<m1) 
 4001d0c:	e0ffeb17 	ldw	r3,-84(fp)
 4001d10:	e0bfec17 	ldw	r2,-80(fp)
 4001d14:	1880080e 	bge	r3,r2,4001d38 <Read_Ads7846+0x1f0>
      screen.x=(temp[0]+temp[2])/2;
 4001d18:	e0fff017 	ldw	r3,-64(fp)
 4001d1c:	e0bff217 	ldw	r2,-56(fp)
 4001d20:	1887883a 	add	r3,r3,r2
 4001d24:	1804d7fa 	srli	r2,r3,31
 4001d28:	10c5883a 	add	r2,r2,r3
 4001d2c:	1005d07a 	srai	r2,r2,1
 4001d30:	d0a00d8d 	sth	r2,-32714(gp)
 4001d34:	00000706 	br	4001d54 <Read_Ads7846+0x20c>
    else 
      screen.x=(temp[1]+temp[2])/2;
 4001d38:	e0fff117 	ldw	r3,-60(fp)
 4001d3c:	e0bff217 	ldw	r2,-56(fp)
 4001d40:	1887883a 	add	r3,r3,r2
 4001d44:	1804d7fa 	srli	r2,r3,31
 4001d48:	10c5883a 	add	r2,r2,r3
 4001d4c:	1005d07a 	srai	r2,r2,1
 4001d50:	d0a00d8d 	sth	r2,-32714(gp)

    /* Average Y  */
  temp[0]=buffer[1][0];
 4001d54:	e0bff617 	ldw	r2,-40(fp)
 4001d58:	e0bff015 	stw	r2,-64(fp)
    temp[1]=buffer[1][1];
 4001d5c:	e0bff717 	ldw	r2,-36(fp)
 4001d60:	e0bff115 	stw	r2,-60(fp)
    temp[2]=buffer[1][2];
 4001d64:	e0bff817 	ldw	r2,-32(fp)
 4001d68:	e0bff215 	stw	r2,-56(fp)
    m0=temp[0]-temp[1];
 4001d6c:	e0fff017 	ldw	r3,-64(fp)
 4001d70:	e0bff117 	ldw	r2,-60(fp)
 4001d74:	1885c83a 	sub	r2,r3,r2
 4001d78:	e0bfed15 	stw	r2,-76(fp)
    m1=temp[1]-temp[2];
 4001d7c:	e0fff117 	ldw	r3,-60(fp)
 4001d80:	e0bff217 	ldw	r2,-56(fp)
 4001d84:	1885c83a 	sub	r2,r3,r2
 4001d88:	e0bfec15 	stw	r2,-80(fp)
    m2=temp[2]-temp[0];
 4001d8c:	e0fff217 	ldw	r3,-56(fp)
 4001d90:	e0bff017 	ldw	r2,-64(fp)
 4001d94:	1885c83a 	sub	r2,r3,r2
 4001d98:	e0bfeb15 	stw	r2,-84(fp)
    m0=m0>0?m0:(-m0);
 4001d9c:	e0ffed17 	ldw	r3,-76(fp)
 4001da0:	e0fffd15 	stw	r3,-12(fp)
 4001da4:	e13ffd17 	ldw	r4,-12(fp)
 4001da8:	2004403a 	cmpge	r2,r4,zero
 4001dac:	1000031e 	bne	r2,zero,4001dbc <Read_Ads7846+0x274>
 4001db0:	e0bffd17 	ldw	r2,-12(fp)
 4001db4:	0085c83a 	sub	r2,zero,r2
 4001db8:	e0bffd15 	stw	r2,-12(fp)
 4001dbc:	e0fffd17 	ldw	r3,-12(fp)
 4001dc0:	e0ffed15 	stw	r3,-76(fp)
    m1=m1>0?m1:(-m1);
 4001dc4:	e13fec17 	ldw	r4,-80(fp)
 4001dc8:	e13ffe15 	stw	r4,-8(fp)
 4001dcc:	e0fffe17 	ldw	r3,-8(fp)
 4001dd0:	1804403a 	cmpge	r2,r3,zero
 4001dd4:	1000031e 	bne	r2,zero,4001de4 <Read_Ads7846+0x29c>
 4001dd8:	e13ffe17 	ldw	r4,-8(fp)
 4001ddc:	0109c83a 	sub	r4,zero,r4
 4001de0:	e13ffe15 	stw	r4,-8(fp)
 4001de4:	e0bffe17 	ldw	r2,-8(fp)
 4001de8:	e0bfec15 	stw	r2,-80(fp)
    m2=m2>0?m2:(-m2);
 4001dec:	e0ffeb17 	ldw	r3,-84(fp)
 4001df0:	e0ffff15 	stw	r3,-4(fp)
 4001df4:	e13fff17 	ldw	r4,-4(fp)
 4001df8:	2004403a 	cmpge	r2,r4,zero
 4001dfc:	1000031e 	bne	r2,zero,4001e0c <Read_Ads7846+0x2c4>
 4001e00:	e0bfff17 	ldw	r2,-4(fp)
 4001e04:	0085c83a 	sub	r2,zero,r2
 4001e08:	e0bfff15 	stw	r2,-4(fp)
 4001e0c:	e0ffff17 	ldw	r3,-4(fp)
 4001e10:	e0ffeb15 	stw	r3,-84(fp)
    //if(m0>THRESHOLD&&m1>THRESHOLD&&m2>THRESHOLD) return 0;

    if(m0<m1)
 4001e14:	e0ffed17 	ldw	r3,-76(fp)
 4001e18:	e0bfec17 	ldw	r2,-80(fp)
 4001e1c:	1880190e 	bge	r3,r2,4001e84 <Read_Ads7846+0x33c>
    {
      if(m2<m0) 
 4001e20:	e0ffeb17 	ldw	r3,-84(fp)
 4001e24:	e0bfed17 	ldw	r2,-76(fp)
 4001e28:	18800b0e 	bge	r3,r2,4001e58 <Read_Ads7846+0x310>
        screen.y=(temp[0]+temp[2])/2;
 4001e2c:	e0fff017 	ldw	r3,-64(fp)
 4001e30:	e0bff217 	ldw	r2,-56(fp)
 4001e34:	1887883a 	add	r3,r3,r2
 4001e38:	1804d7fa 	srli	r2,r3,31
 4001e3c:	10c5883a 	add	r2,r2,r3
 4001e40:	1005d07a 	srai	r2,r2,1
 4001e44:	1007883a 	mov	r3,r2
 4001e48:	00810074 	movhi	r2,1025
 4001e4c:	10a53204 	addi	r2,r2,-27448
 4001e50:	10c0000d 	sth	r3,0(r2)
 4001e54:	00002306 	br	4001ee4 <Read_Ads7846+0x39c>
      else 
        screen.y=(temp[0]+temp[1])/2;   
 4001e58:	e0fff017 	ldw	r3,-64(fp)
 4001e5c:	e0bff117 	ldw	r2,-60(fp)
 4001e60:	1887883a 	add	r3,r3,r2
 4001e64:	1804d7fa 	srli	r2,r3,31
 4001e68:	10c5883a 	add	r2,r2,r3
 4001e6c:	1005d07a 	srai	r2,r2,1
 4001e70:	1007883a 	mov	r3,r2
 4001e74:	00810074 	movhi	r2,1025
 4001e78:	10a53204 	addi	r2,r2,-27448
 4001e7c:	10c0000d 	sth	r3,0(r2)
 4001e80:	00001806 	br	4001ee4 <Read_Ads7846+0x39c>
    }
    else if(m2<m1) 
 4001e84:	e0ffeb17 	ldw	r3,-84(fp)
 4001e88:	e0bfec17 	ldw	r2,-80(fp)
 4001e8c:	18800b0e 	bge	r3,r2,4001ebc <Read_Ads7846+0x374>
       screen.y=(temp[0]+temp[2])/2;
 4001e90:	e0fff017 	ldw	r3,-64(fp)
 4001e94:	e0bff217 	ldw	r2,-56(fp)
 4001e98:	1887883a 	add	r3,r3,r2
 4001e9c:	1804d7fa 	srli	r2,r3,31
 4001ea0:	10c5883a 	add	r2,r2,r3
 4001ea4:	1005d07a 	srai	r2,r2,1
 4001ea8:	1007883a 	mov	r3,r2
 4001eac:	00810074 	movhi	r2,1025
 4001eb0:	10a53204 	addi	r2,r2,-27448
 4001eb4:	10c0000d 	sth	r3,0(r2)
 4001eb8:	00000a06 	br	4001ee4 <Read_Ads7846+0x39c>
    else
       screen.y=(temp[1]+temp[2])/2;
 4001ebc:	e0fff117 	ldw	r3,-60(fp)
 4001ec0:	e0bff217 	ldw	r2,-56(fp)
 4001ec4:	1887883a 	add	r3,r3,r2
 4001ec8:	1804d7fa 	srli	r2,r3,31
 4001ecc:	10c5883a 	add	r2,r2,r3
 4001ed0:	1005d07a 	srai	r2,r2,1
 4001ed4:	1007883a 	mov	r3,r2
 4001ed8:	00810074 	movhi	r2,1025
 4001edc:	10a53204 	addi	r2,r2,-27448
 4001ee0:	10c0000d 	sth	r3,0(r2)

    return &screen;
 4001ee4:	d1200d84 	addi	r4,gp,-32714
 4001ee8:	e13ff915 	stw	r4,-28(fp)
 4001eec:	00000106 	br	4001ef4 <Read_Ads7846+0x3ac>
  }  
  return 0; 
 4001ef0:	e03ff915 	stw	zero,-28(fp)
 4001ef4:	e0bff917 	ldw	r2,-28(fp)
}
 4001ef8:	e037883a 	mov	sp,fp
 4001efc:	dfc00117 	ldw	ra,4(sp)
 4001f00:	df000017 	ldw	fp,0(sp)
 4001f04:	dec00204 	addi	sp,sp,8
 4001f08:	f800283a 	ret

04001f0c <setCalibrationMatrix>:
* Attention      : None
*******************************************************************************/
alt_u8 setCalibrationMatrix( Coordinate * displayPtr,
                          Coordinate * screenPtr,
                          Matrix * matrixPtr)
{
 4001f0c:	defffa04 	addi	sp,sp,-24
 4001f10:	dfc00515 	stw	ra,20(sp)
 4001f14:	df000415 	stw	fp,16(sp)
 4001f18:	df000404 	addi	fp,sp,16
 4001f1c:	e13ffd15 	stw	r4,-12(fp)
 4001f20:	e17ffe15 	stw	r5,-8(fp)
 4001f24:	e1bfff15 	stw	r6,-4(fp)

  alt_u8 retTHRESHOLD = 1 ;
 4001f28:	00800044 	movi	r2,1
 4001f2c:	e0bffc05 	stb	r2,-16(fp)
  /* K(X0X2) (Y1Y2)(X1X2) (Y0Y2) */
  matrixPtr->Divider = ((screenPtr[0].x - screenPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) - 
 4001f30:	e0bffe17 	ldw	r2,-8(fp)
 4001f34:	1080000b 	ldhu	r2,0(r2)
 4001f38:	10ffffcc 	andi	r3,r2,65535
 4001f3c:	e0bffe17 	ldw	r2,-8(fp)
 4001f40:	10800204 	addi	r2,r2,8
 4001f44:	1080000b 	ldhu	r2,0(r2)
 4001f48:	10bfffcc 	andi	r2,r2,65535
 4001f4c:	1889c83a 	sub	r4,r3,r2
 4001f50:	e0bffe17 	ldw	r2,-8(fp)
 4001f54:	10800104 	addi	r2,r2,4
 4001f58:	1080008b 	ldhu	r2,2(r2)
 4001f5c:	10ffffcc 	andi	r3,r2,65535
 4001f60:	e0bffe17 	ldw	r2,-8(fp)
 4001f64:	10800204 	addi	r2,r2,8
 4001f68:	1080008b 	ldhu	r2,2(r2)
 4001f6c:	10bfffcc 	andi	r2,r2,65535
 4001f70:	1885c83a 	sub	r2,r3,r2
 4001f74:	208b383a 	mul	r5,r4,r2
 4001f78:	e0bffe17 	ldw	r2,-8(fp)
 4001f7c:	10800104 	addi	r2,r2,4
 4001f80:	1080000b 	ldhu	r2,0(r2)
 4001f84:	10ffffcc 	andi	r3,r2,65535
 4001f88:	e0bffe17 	ldw	r2,-8(fp)
 4001f8c:	10800204 	addi	r2,r2,8
 4001f90:	1080000b 	ldhu	r2,0(r2)
 4001f94:	10bfffcc 	andi	r2,r2,65535
 4001f98:	1889c83a 	sub	r4,r3,r2
 4001f9c:	e0bffe17 	ldw	r2,-8(fp)
 4001fa0:	1080008b 	ldhu	r2,2(r2)
 4001fa4:	10ffffcc 	andi	r3,r2,65535
 4001fa8:	e0bffe17 	ldw	r2,-8(fp)
 4001fac:	10800204 	addi	r2,r2,8
 4001fb0:	1080008b 	ldhu	r2,2(r2)
 4001fb4:	10bfffcc 	andi	r2,r2,65535
 4001fb8:	1885c83a 	sub	r2,r3,r2
 4001fbc:	2085383a 	mul	r2,r4,r2
 4001fc0:	2889c83a 	sub	r4,r5,r2
 4001fc4:	40036b80 	call	40036b8 <__floatsidf>
 4001fc8:	1009883a 	mov	r4,r2
 4001fcc:	180b883a 	mov	r5,r3
 4001fd0:	e0bfff17 	ldw	r2,-4(fp)
 4001fd4:	11000c15 	stw	r4,48(r2)
 4001fd8:	11400d15 	stw	r5,52(r2)
                       ((screenPtr[1].x - screenPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;
  if( matrixPtr->Divider == 0 )
 4001fdc:	e13fff17 	ldw	r4,-4(fp)
 4001fe0:	20800c17 	ldw	r2,48(r4)
 4001fe4:	20c00d17 	ldw	r3,52(r4)
 4001fe8:	1009883a 	mov	r4,r2
 4001fec:	180b883a 	mov	r5,r3
 4001ff0:	000d883a 	mov	r6,zero
 4001ff4:	000f883a 	mov	r7,zero
 4001ff8:	40035200 	call	4003520 <__eqdf2>
 4001ffc:	1005003a 	cmpeq	r2,r2,zero
 4002000:	1000011e 	bne	r2,zero,4002008 <setCalibrationMatrix+0xfc>
 4002004:	00000206 	br	4002010 <setCalibrationMatrix+0x104>
  {
    retTHRESHOLD = 0;
 4002008:	e03ffc05 	stb	zero,-16(fp)
 400200c:	00014206 	br	4002518 <setCalibrationMatrix+0x60c>
  }
  else
  {
    /* A((XD0XD2) (Y1Y2)(XD1XD2) (Y0Y2))K    */
    matrixPtr->An = ((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].y - screenPtr[2].y)) - 
 4002010:	e0bffd17 	ldw	r2,-12(fp)
 4002014:	1080000b 	ldhu	r2,0(r2)
 4002018:	10ffffcc 	andi	r3,r2,65535
 400201c:	e0bffd17 	ldw	r2,-12(fp)
 4002020:	10800204 	addi	r2,r2,8
 4002024:	1080000b 	ldhu	r2,0(r2)
 4002028:	10bfffcc 	andi	r2,r2,65535
 400202c:	1889c83a 	sub	r4,r3,r2
 4002030:	e0bffe17 	ldw	r2,-8(fp)
 4002034:	10800104 	addi	r2,r2,4
 4002038:	1080008b 	ldhu	r2,2(r2)
 400203c:	10ffffcc 	andi	r3,r2,65535
 4002040:	e0bffe17 	ldw	r2,-8(fp)
 4002044:	10800204 	addi	r2,r2,8
 4002048:	1080008b 	ldhu	r2,2(r2)
 400204c:	10bfffcc 	andi	r2,r2,65535
 4002050:	1885c83a 	sub	r2,r3,r2
 4002054:	208b383a 	mul	r5,r4,r2
 4002058:	e0bffd17 	ldw	r2,-12(fp)
 400205c:	10800104 	addi	r2,r2,4
 4002060:	1080000b 	ldhu	r2,0(r2)
 4002064:	10ffffcc 	andi	r3,r2,65535
 4002068:	e0bffd17 	ldw	r2,-12(fp)
 400206c:	10800204 	addi	r2,r2,8
 4002070:	1080000b 	ldhu	r2,0(r2)
 4002074:	10bfffcc 	andi	r2,r2,65535
 4002078:	1889c83a 	sub	r4,r3,r2
 400207c:	e0bffe17 	ldw	r2,-8(fp)
 4002080:	1080008b 	ldhu	r2,2(r2)
 4002084:	10ffffcc 	andi	r3,r2,65535
 4002088:	e0bffe17 	ldw	r2,-8(fp)
 400208c:	10800204 	addi	r2,r2,8
 4002090:	1080008b 	ldhu	r2,2(r2)
 4002094:	10bfffcc 	andi	r2,r2,65535
 4002098:	1885c83a 	sub	r2,r3,r2
 400209c:	2085383a 	mul	r2,r4,r2
 40020a0:	2889c83a 	sub	r4,r5,r2
 40020a4:	40036b80 	call	40036b8 <__floatsidf>
 40020a8:	1009883a 	mov	r4,r2
 40020ac:	180b883a 	mov	r5,r3
 40020b0:	e0bfff17 	ldw	r2,-4(fp)
 40020b4:	11000015 	stw	r4,0(r2)
 40020b8:	11400115 	stw	r5,4(r2)
                    ((displayPtr[1].x - displayPtr[2].x) * (screenPtr[0].y - screenPtr[2].y)) ;
    /* B((X0X2) (XD1XD2)(XD0XD2) (X1X2))K    */
    matrixPtr->Bn = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].x - displayPtr[2].x)) - 
 40020bc:	e0bffe17 	ldw	r2,-8(fp)
 40020c0:	1080000b 	ldhu	r2,0(r2)
 40020c4:	10ffffcc 	andi	r3,r2,65535
 40020c8:	e0bffe17 	ldw	r2,-8(fp)
 40020cc:	10800204 	addi	r2,r2,8
 40020d0:	1080000b 	ldhu	r2,0(r2)
 40020d4:	10bfffcc 	andi	r2,r2,65535
 40020d8:	1889c83a 	sub	r4,r3,r2
 40020dc:	e0bffd17 	ldw	r2,-12(fp)
 40020e0:	10800104 	addi	r2,r2,4
 40020e4:	1080000b 	ldhu	r2,0(r2)
 40020e8:	10ffffcc 	andi	r3,r2,65535
 40020ec:	e0bffd17 	ldw	r2,-12(fp)
 40020f0:	10800204 	addi	r2,r2,8
 40020f4:	1080000b 	ldhu	r2,0(r2)
 40020f8:	10bfffcc 	andi	r2,r2,65535
 40020fc:	1885c83a 	sub	r2,r3,r2
 4002100:	208b383a 	mul	r5,r4,r2
 4002104:	e0bffd17 	ldw	r2,-12(fp)
 4002108:	1080000b 	ldhu	r2,0(r2)
 400210c:	10ffffcc 	andi	r3,r2,65535
 4002110:	e0bffd17 	ldw	r2,-12(fp)
 4002114:	10800204 	addi	r2,r2,8
 4002118:	1080000b 	ldhu	r2,0(r2)
 400211c:	10bfffcc 	andi	r2,r2,65535
 4002120:	1889c83a 	sub	r4,r3,r2
 4002124:	e0bffe17 	ldw	r2,-8(fp)
 4002128:	10800104 	addi	r2,r2,4
 400212c:	1080000b 	ldhu	r2,0(r2)
 4002130:	10ffffcc 	andi	r3,r2,65535
 4002134:	e0bffe17 	ldw	r2,-8(fp)
 4002138:	10800204 	addi	r2,r2,8
 400213c:	1080000b 	ldhu	r2,0(r2)
 4002140:	10bfffcc 	andi	r2,r2,65535
 4002144:	1885c83a 	sub	r2,r3,r2
 4002148:	2085383a 	mul	r2,r4,r2
 400214c:	2889c83a 	sub	r4,r5,r2
 4002150:	40036b80 	call	40036b8 <__floatsidf>
 4002154:	1009883a 	mov	r4,r2
 4002158:	180b883a 	mov	r5,r3
 400215c:	e0bfff17 	ldw	r2,-4(fp)
 4002160:	11000215 	stw	r4,8(r2)
 4002164:	11400315 	stw	r5,12(r2)
                    ((displayPtr[0].x - displayPtr[2].x) * (screenPtr[1].x - screenPtr[2].x)) ;
    /* C(Y0(X2XD1X1XD2)+Y1(X0XD2X2XD0)+Y2(X1XD0X0XD1))K */
    matrixPtr->Cn = (screenPtr[2].x * displayPtr[1].x - screenPtr[1].x * displayPtr[2].x) * screenPtr[0].y +
 4002168:	e0bffe17 	ldw	r2,-8(fp)
 400216c:	10800204 	addi	r2,r2,8
 4002170:	1080000b 	ldhu	r2,0(r2)
 4002174:	10ffffcc 	andi	r3,r2,65535
 4002178:	e0bffd17 	ldw	r2,-12(fp)
 400217c:	10800104 	addi	r2,r2,4
 4002180:	1080000b 	ldhu	r2,0(r2)
 4002184:	10bfffcc 	andi	r2,r2,65535
 4002188:	1889383a 	mul	r4,r3,r2
 400218c:	e0bffe17 	ldw	r2,-8(fp)
 4002190:	10800104 	addi	r2,r2,4
 4002194:	1080000b 	ldhu	r2,0(r2)
 4002198:	10ffffcc 	andi	r3,r2,65535
 400219c:	e0bffd17 	ldw	r2,-12(fp)
 40021a0:	10800204 	addi	r2,r2,8
 40021a4:	1080000b 	ldhu	r2,0(r2)
 40021a8:	10bfffcc 	andi	r2,r2,65535
 40021ac:	1885383a 	mul	r2,r3,r2
 40021b0:	2087c83a 	sub	r3,r4,r2
 40021b4:	e0bffe17 	ldw	r2,-8(fp)
 40021b8:	1080008b 	ldhu	r2,2(r2)
 40021bc:	10bfffcc 	andi	r2,r2,65535
 40021c0:	188b383a 	mul	r5,r3,r2
 40021c4:	e0bffe17 	ldw	r2,-8(fp)
 40021c8:	1080000b 	ldhu	r2,0(r2)
 40021cc:	10ffffcc 	andi	r3,r2,65535
 40021d0:	e0bffd17 	ldw	r2,-12(fp)
 40021d4:	10800204 	addi	r2,r2,8
 40021d8:	1080000b 	ldhu	r2,0(r2)
 40021dc:	10bfffcc 	andi	r2,r2,65535
 40021e0:	1889383a 	mul	r4,r3,r2
 40021e4:	e0bffe17 	ldw	r2,-8(fp)
 40021e8:	10800204 	addi	r2,r2,8
 40021ec:	1080000b 	ldhu	r2,0(r2)
 40021f0:	10ffffcc 	andi	r3,r2,65535
 40021f4:	e0bffd17 	ldw	r2,-12(fp)
 40021f8:	1080000b 	ldhu	r2,0(r2)
 40021fc:	10bfffcc 	andi	r2,r2,65535
 4002200:	1885383a 	mul	r2,r3,r2
 4002204:	2087c83a 	sub	r3,r4,r2
 4002208:	e0bffe17 	ldw	r2,-8(fp)
 400220c:	10800104 	addi	r2,r2,4
 4002210:	1080008b 	ldhu	r2,2(r2)
 4002214:	10bfffcc 	andi	r2,r2,65535
 4002218:	1885383a 	mul	r2,r3,r2
 400221c:	288b883a 	add	r5,r5,r2
 4002220:	e0bffe17 	ldw	r2,-8(fp)
 4002224:	10800104 	addi	r2,r2,4
 4002228:	1080000b 	ldhu	r2,0(r2)
 400222c:	10ffffcc 	andi	r3,r2,65535
 4002230:	e0bffd17 	ldw	r2,-12(fp)
 4002234:	1080000b 	ldhu	r2,0(r2)
 4002238:	10bfffcc 	andi	r2,r2,65535
 400223c:	1889383a 	mul	r4,r3,r2
 4002240:	e0bffe17 	ldw	r2,-8(fp)
 4002244:	1080000b 	ldhu	r2,0(r2)
 4002248:	10ffffcc 	andi	r3,r2,65535
 400224c:	e0bffd17 	ldw	r2,-12(fp)
 4002250:	10800104 	addi	r2,r2,4
 4002254:	1080000b 	ldhu	r2,0(r2)
 4002258:	10bfffcc 	andi	r2,r2,65535
 400225c:	1885383a 	mul	r2,r3,r2
 4002260:	2087c83a 	sub	r3,r4,r2
 4002264:	e0bffe17 	ldw	r2,-8(fp)
 4002268:	10800204 	addi	r2,r2,8
 400226c:	1080008b 	ldhu	r2,2(r2)
 4002270:	10bfffcc 	andi	r2,r2,65535
 4002274:	1885383a 	mul	r2,r3,r2
 4002278:	2889883a 	add	r4,r5,r2
 400227c:	40036b80 	call	40036b8 <__floatsidf>
 4002280:	1009883a 	mov	r4,r2
 4002284:	180b883a 	mov	r5,r3
 4002288:	e0bfff17 	ldw	r2,-4(fp)
 400228c:	11000415 	stw	r4,16(r2)
 4002290:	11400515 	stw	r5,20(r2)
                    (screenPtr[0].x * displayPtr[2].x - screenPtr[2].x * displayPtr[0].x) * screenPtr[1].y +
                    (screenPtr[1].x * displayPtr[0].x - screenPtr[0].x * displayPtr[1].x) * screenPtr[2].y ;
    /* D((YD0YD2) (Y1Y2)(YD1YD2) (Y0Y2))K    */
    matrixPtr->Dn = ((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].y - screenPtr[2].y)) - 
 4002294:	e0bffd17 	ldw	r2,-12(fp)
 4002298:	1080008b 	ldhu	r2,2(r2)
 400229c:	10ffffcc 	andi	r3,r2,65535
 40022a0:	e0bffd17 	ldw	r2,-12(fp)
 40022a4:	10800204 	addi	r2,r2,8
 40022a8:	1080008b 	ldhu	r2,2(r2)
 40022ac:	10bfffcc 	andi	r2,r2,65535
 40022b0:	1889c83a 	sub	r4,r3,r2
 40022b4:	e0bffe17 	ldw	r2,-8(fp)
 40022b8:	10800104 	addi	r2,r2,4
 40022bc:	1080008b 	ldhu	r2,2(r2)
 40022c0:	10ffffcc 	andi	r3,r2,65535
 40022c4:	e0bffe17 	ldw	r2,-8(fp)
 40022c8:	10800204 	addi	r2,r2,8
 40022cc:	1080008b 	ldhu	r2,2(r2)
 40022d0:	10bfffcc 	andi	r2,r2,65535
 40022d4:	1885c83a 	sub	r2,r3,r2
 40022d8:	208b383a 	mul	r5,r4,r2
 40022dc:	e0bffd17 	ldw	r2,-12(fp)
 40022e0:	10800104 	addi	r2,r2,4
 40022e4:	1080008b 	ldhu	r2,2(r2)
 40022e8:	10ffffcc 	andi	r3,r2,65535
 40022ec:	e0bffd17 	ldw	r2,-12(fp)
 40022f0:	10800204 	addi	r2,r2,8
 40022f4:	1080008b 	ldhu	r2,2(r2)
 40022f8:	10bfffcc 	andi	r2,r2,65535
 40022fc:	1889c83a 	sub	r4,r3,r2
 4002300:	e0bffe17 	ldw	r2,-8(fp)
 4002304:	1080008b 	ldhu	r2,2(r2)
 4002308:	10ffffcc 	andi	r3,r2,65535
 400230c:	e0bffe17 	ldw	r2,-8(fp)
 4002310:	10800204 	addi	r2,r2,8
 4002314:	1080008b 	ldhu	r2,2(r2)
 4002318:	10bfffcc 	andi	r2,r2,65535
 400231c:	1885c83a 	sub	r2,r3,r2
 4002320:	2085383a 	mul	r2,r4,r2
 4002324:	2889c83a 	sub	r4,r5,r2
 4002328:	40036b80 	call	40036b8 <__floatsidf>
 400232c:	1009883a 	mov	r4,r2
 4002330:	180b883a 	mov	r5,r3
 4002334:	e0bfff17 	ldw	r2,-4(fp)
 4002338:	11000615 	stw	r4,24(r2)
 400233c:	11400715 	stw	r5,28(r2)
                    ((displayPtr[1].y - displayPtr[2].y) * (screenPtr[0].y - screenPtr[2].y)) ;
    /* E((X0X2) (YD1YD2)(YD0YD2) (X1X2))K    */
    matrixPtr->En = ((screenPtr[0].x - screenPtr[2].x) * (displayPtr[1].y - displayPtr[2].y)) - 
 4002340:	e0bffe17 	ldw	r2,-8(fp)
 4002344:	1080000b 	ldhu	r2,0(r2)
 4002348:	10ffffcc 	andi	r3,r2,65535
 400234c:	e0bffe17 	ldw	r2,-8(fp)
 4002350:	10800204 	addi	r2,r2,8
 4002354:	1080000b 	ldhu	r2,0(r2)
 4002358:	10bfffcc 	andi	r2,r2,65535
 400235c:	1889c83a 	sub	r4,r3,r2
 4002360:	e0bffd17 	ldw	r2,-12(fp)
 4002364:	10800104 	addi	r2,r2,4
 4002368:	1080008b 	ldhu	r2,2(r2)
 400236c:	10ffffcc 	andi	r3,r2,65535
 4002370:	e0bffd17 	ldw	r2,-12(fp)
 4002374:	10800204 	addi	r2,r2,8
 4002378:	1080008b 	ldhu	r2,2(r2)
 400237c:	10bfffcc 	andi	r2,r2,65535
 4002380:	1885c83a 	sub	r2,r3,r2
 4002384:	208b383a 	mul	r5,r4,r2
 4002388:	e0bffd17 	ldw	r2,-12(fp)
 400238c:	1080008b 	ldhu	r2,2(r2)
 4002390:	10ffffcc 	andi	r3,r2,65535
 4002394:	e0bffd17 	ldw	r2,-12(fp)
 4002398:	10800204 	addi	r2,r2,8
 400239c:	1080008b 	ldhu	r2,2(r2)
 40023a0:	10bfffcc 	andi	r2,r2,65535
 40023a4:	1889c83a 	sub	r4,r3,r2
 40023a8:	e0bffe17 	ldw	r2,-8(fp)
 40023ac:	10800104 	addi	r2,r2,4
 40023b0:	1080000b 	ldhu	r2,0(r2)
 40023b4:	10ffffcc 	andi	r3,r2,65535
 40023b8:	e0bffe17 	ldw	r2,-8(fp)
 40023bc:	10800204 	addi	r2,r2,8
 40023c0:	1080000b 	ldhu	r2,0(r2)
 40023c4:	10bfffcc 	andi	r2,r2,65535
 40023c8:	1885c83a 	sub	r2,r3,r2
 40023cc:	2085383a 	mul	r2,r4,r2
 40023d0:	2889c83a 	sub	r4,r5,r2
 40023d4:	40036b80 	call	40036b8 <__floatsidf>
 40023d8:	1009883a 	mov	r4,r2
 40023dc:	180b883a 	mov	r5,r3
 40023e0:	e0bfff17 	ldw	r2,-4(fp)
 40023e4:	11000815 	stw	r4,32(r2)
 40023e8:	11400915 	stw	r5,36(r2)
                    ((displayPtr[0].y - displayPtr[2].y) * (screenPtr[1].x - screenPtr[2].x)) ;
    /* F(Y0(X2YD1X1YD2)+Y1(X0YD2X2YD0)+Y2(X1YD0X0YD1))K */
    matrixPtr->Fn = (screenPtr[2].x * displayPtr[1].y - screenPtr[1].x * displayPtr[2].y) * screenPtr[0].y +
 40023ec:	e0bffe17 	ldw	r2,-8(fp)
 40023f0:	10800204 	addi	r2,r2,8
 40023f4:	1080000b 	ldhu	r2,0(r2)
 40023f8:	10ffffcc 	andi	r3,r2,65535
 40023fc:	e0bffd17 	ldw	r2,-12(fp)
 4002400:	10800104 	addi	r2,r2,4
 4002404:	1080008b 	ldhu	r2,2(r2)
 4002408:	10bfffcc 	andi	r2,r2,65535
 400240c:	1889383a 	mul	r4,r3,r2
 4002410:	e0bffe17 	ldw	r2,-8(fp)
 4002414:	10800104 	addi	r2,r2,4
 4002418:	1080000b 	ldhu	r2,0(r2)
 400241c:	10ffffcc 	andi	r3,r2,65535
 4002420:	e0bffd17 	ldw	r2,-12(fp)
 4002424:	10800204 	addi	r2,r2,8
 4002428:	1080008b 	ldhu	r2,2(r2)
 400242c:	10bfffcc 	andi	r2,r2,65535
 4002430:	1885383a 	mul	r2,r3,r2
 4002434:	2087c83a 	sub	r3,r4,r2
 4002438:	e0bffe17 	ldw	r2,-8(fp)
 400243c:	1080008b 	ldhu	r2,2(r2)
 4002440:	10bfffcc 	andi	r2,r2,65535
 4002444:	188b383a 	mul	r5,r3,r2
 4002448:	e0bffe17 	ldw	r2,-8(fp)
 400244c:	1080000b 	ldhu	r2,0(r2)
 4002450:	10ffffcc 	andi	r3,r2,65535
 4002454:	e0bffd17 	ldw	r2,-12(fp)
 4002458:	10800204 	addi	r2,r2,8
 400245c:	1080008b 	ldhu	r2,2(r2)
 4002460:	10bfffcc 	andi	r2,r2,65535
 4002464:	1889383a 	mul	r4,r3,r2
 4002468:	e0bffe17 	ldw	r2,-8(fp)
 400246c:	10800204 	addi	r2,r2,8
 4002470:	1080000b 	ldhu	r2,0(r2)
 4002474:	10ffffcc 	andi	r3,r2,65535
 4002478:	e0bffd17 	ldw	r2,-12(fp)
 400247c:	1080008b 	ldhu	r2,2(r2)
 4002480:	10bfffcc 	andi	r2,r2,65535
 4002484:	1885383a 	mul	r2,r3,r2
 4002488:	2087c83a 	sub	r3,r4,r2
 400248c:	e0bffe17 	ldw	r2,-8(fp)
 4002490:	10800104 	addi	r2,r2,4
 4002494:	1080008b 	ldhu	r2,2(r2)
 4002498:	10bfffcc 	andi	r2,r2,65535
 400249c:	1885383a 	mul	r2,r3,r2
 40024a0:	288b883a 	add	r5,r5,r2
 40024a4:	e0bffe17 	ldw	r2,-8(fp)
 40024a8:	10800104 	addi	r2,r2,4
 40024ac:	1080000b 	ldhu	r2,0(r2)
 40024b0:	10ffffcc 	andi	r3,r2,65535
 40024b4:	e0bffd17 	ldw	r2,-12(fp)
 40024b8:	1080008b 	ldhu	r2,2(r2)
 40024bc:	10bfffcc 	andi	r2,r2,65535
 40024c0:	1889383a 	mul	r4,r3,r2
 40024c4:	e0bffe17 	ldw	r2,-8(fp)
 40024c8:	1080000b 	ldhu	r2,0(r2)
 40024cc:	10ffffcc 	andi	r3,r2,65535
 40024d0:	e0bffd17 	ldw	r2,-12(fp)
 40024d4:	10800104 	addi	r2,r2,4
 40024d8:	1080008b 	ldhu	r2,2(r2)
 40024dc:	10bfffcc 	andi	r2,r2,65535
 40024e0:	1885383a 	mul	r2,r3,r2
 40024e4:	2087c83a 	sub	r3,r4,r2
 40024e8:	e0bffe17 	ldw	r2,-8(fp)
 40024ec:	10800204 	addi	r2,r2,8
 40024f0:	1080008b 	ldhu	r2,2(r2)
 40024f4:	10bfffcc 	andi	r2,r2,65535
 40024f8:	1885383a 	mul	r2,r3,r2
 40024fc:	2889883a 	add	r4,r5,r2
 4002500:	40036b80 	call	40036b8 <__floatsidf>
 4002504:	1009883a 	mov	r4,r2
 4002508:	180b883a 	mov	r5,r3
 400250c:	e0bfff17 	ldw	r2,-4(fp)
 4002510:	11000a15 	stw	r4,40(r2)
 4002514:	11400b15 	stw	r5,44(r2)
                    (screenPtr[0].x * displayPtr[2].y - screenPtr[2].x * displayPtr[0].y) * screenPtr[1].y +
                    (screenPtr[1].x * displayPtr[0].y - screenPtr[0].x * displayPtr[1].y) * screenPtr[2].y ;
  }
  return( retTHRESHOLD ) ;
 4002518:	e0bffc03 	ldbu	r2,-16(fp)
}
 400251c:	e037883a 	mov	sp,fp
 4002520:	dfc00117 	ldw	ra,4(sp)
 4002524:	df000017 	ldw	fp,0(sp)
 4002528:	dec00204 	addi	sp,sp,8
 400252c:	f800283a 	ret

04002530 <getDisplayPoint>:
* Attention      : None
*******************************************************************************/
alt_u8 getDisplayPoint(Coordinate * displayPtr,
                     Coordinate * screenPtr,
                     Matrix * matrixPtr )
{
 4002530:	defff604 	addi	sp,sp,-40
 4002534:	dfc00915 	stw	ra,36(sp)
 4002538:	df000815 	stw	fp,32(sp)
 400253c:	dcc00715 	stw	r19,28(sp)
 4002540:	dc800615 	stw	r18,24(sp)
 4002544:	dc400515 	stw	r17,20(sp)
 4002548:	dc000415 	stw	r16,16(sp)
 400254c:	df000404 	addi	fp,sp,16
 4002550:	e13ffd15 	stw	r4,-12(fp)
 4002554:	e17ffe15 	stw	r5,-8(fp)
 4002558:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 retTHRESHOLD =1 ;
 400255c:	00800044 	movi	r2,1
 4002560:	e0bffc05 	stb	r2,-16(fp)

  if( matrixPtr->Divider != 0 )
 4002564:	e13fff17 	ldw	r4,-4(fp)
 4002568:	20800c17 	ldw	r2,48(r4)
 400256c:	20c00d17 	ldw	r3,52(r4)
 4002570:	1009883a 	mov	r4,r2
 4002574:	180b883a 	mov	r5,r3
 4002578:	000d883a 	mov	r6,zero
 400257c:	000f883a 	mov	r7,zero
 4002580:	40035a80 	call	40035a8 <__nedf2>
 4002584:	1004c03a 	cmpne	r2,r2,zero
 4002588:	1000011e 	bne	r2,zero,4002590 <getDisplayPoint+0x60>
 400258c:	00009706 	br	40027ec <getDisplayPoint+0x2bc>
  {
    /* XD = AX+BY+C */        
    displayPtr->x = ( (matrixPtr->An * screenPtr->x) + 
 4002590:	e0bfff17 	ldw	r2,-4(fp)
 4002594:	14000017 	ldw	r16,0(r2)
 4002598:	14400117 	ldw	r17,4(r2)
 400259c:	e0bffe17 	ldw	r2,-8(fp)
 40025a0:	1080000b 	ldhu	r2,0(r2)
 40025a4:	113fffcc 	andi	r4,r2,65535
 40025a8:	40036b80 	call	40036b8 <__floatsidf>
 40025ac:	100f883a 	mov	r7,r2
 40025b0:	1811883a 	mov	r8,r3
 40025b4:	8009883a 	mov	r4,r16
 40025b8:	880b883a 	mov	r5,r17
 40025bc:	380d883a 	mov	r6,r7
 40025c0:	400f883a 	mov	r7,r8
 40025c4:	4002f040 	call	4002f04 <__muldf3>
 40025c8:	1009883a 	mov	r4,r2
 40025cc:	180b883a 	mov	r5,r3
 40025d0:	2025883a 	mov	r18,r4
 40025d4:	2827883a 	mov	r19,r5
 40025d8:	e0bfff17 	ldw	r2,-4(fp)
 40025dc:	14000217 	ldw	r16,8(r2)
 40025e0:	14400317 	ldw	r17,12(r2)
 40025e4:	e0bffe17 	ldw	r2,-8(fp)
 40025e8:	1080008b 	ldhu	r2,2(r2)
 40025ec:	113fffcc 	andi	r4,r2,65535
 40025f0:	40036b80 	call	40036b8 <__floatsidf>
 40025f4:	100f883a 	mov	r7,r2
 40025f8:	1811883a 	mov	r8,r3
 40025fc:	8009883a 	mov	r4,r16
 4002600:	880b883a 	mov	r5,r17
 4002604:	380d883a 	mov	r6,r7
 4002608:	400f883a 	mov	r7,r8
 400260c:	4002f040 	call	4002f04 <__muldf3>
 4002610:	1009883a 	mov	r4,r2
 4002614:	180b883a 	mov	r5,r3
 4002618:	2005883a 	mov	r2,r4
 400261c:	2807883a 	mov	r3,r5
 4002620:	9009883a 	mov	r4,r18
 4002624:	980b883a 	mov	r5,r19
 4002628:	100d883a 	mov	r6,r2
 400262c:	180f883a 	mov	r7,r3
 4002630:	4002e900 	call	4002e90 <__adddf3>
 4002634:	1009883a 	mov	r4,r2
 4002638:	180b883a 	mov	r5,r3
 400263c:	200d883a 	mov	r6,r4
 4002640:	280f883a 	mov	r7,r5
 4002644:	e13fff17 	ldw	r4,-4(fp)
 4002648:	20800417 	ldw	r2,16(r4)
 400264c:	20c00517 	ldw	r3,20(r4)
 4002650:	3009883a 	mov	r4,r6
 4002654:	380b883a 	mov	r5,r7
 4002658:	100d883a 	mov	r6,r2
 400265c:	180f883a 	mov	r7,r3
 4002660:	4002e900 	call	4002e90 <__adddf3>
 4002664:	1009883a 	mov	r4,r2
 4002668:	180b883a 	mov	r5,r3
 400266c:	200d883a 	mov	r6,r4
 4002670:	280f883a 	mov	r7,r5
 4002674:	e13fff17 	ldw	r4,-4(fp)
 4002678:	20800c17 	ldw	r2,48(r4)
 400267c:	20c00d17 	ldw	r3,52(r4)
 4002680:	3009883a 	mov	r4,r6
 4002684:	380b883a 	mov	r5,r7
 4002688:	100d883a 	mov	r6,r2
 400268c:	180f883a 	mov	r7,r3
 4002690:	40032c80 	call	40032c8 <__divdf3>
 4002694:	1009883a 	mov	r4,r2
 4002698:	180b883a 	mov	r5,r3
 400269c:	2005883a 	mov	r2,r4
 40026a0:	2807883a 	mov	r3,r5
 40026a4:	1009883a 	mov	r4,r2
 40026a8:	180b883a 	mov	r5,r3
 40026ac:	400295c0 	call	400295c <__fixunsdfsi>
 40026b0:	1007883a 	mov	r3,r2
 40026b4:	e0bffd17 	ldw	r2,-12(fp)
 40026b8:	10c0000d 	sth	r3,0(r2)
                      (matrixPtr->Bn * screenPtr->y) + 
                       matrixPtr->Cn 
                    ) / matrixPtr->Divider ;
    /* YD = DX+EY+F */        
    displayPtr->y = ( (matrixPtr->Dn * screenPtr->x) + 
 40026bc:	e0bfff17 	ldw	r2,-4(fp)
 40026c0:	14000617 	ldw	r16,24(r2)
 40026c4:	14400717 	ldw	r17,28(r2)
 40026c8:	e0bffe17 	ldw	r2,-8(fp)
 40026cc:	1080000b 	ldhu	r2,0(r2)
 40026d0:	113fffcc 	andi	r4,r2,65535
 40026d4:	40036b80 	call	40036b8 <__floatsidf>
 40026d8:	100f883a 	mov	r7,r2
 40026dc:	1811883a 	mov	r8,r3
 40026e0:	8009883a 	mov	r4,r16
 40026e4:	880b883a 	mov	r5,r17
 40026e8:	380d883a 	mov	r6,r7
 40026ec:	400f883a 	mov	r7,r8
 40026f0:	4002f040 	call	4002f04 <__muldf3>
 40026f4:	1009883a 	mov	r4,r2
 40026f8:	180b883a 	mov	r5,r3
 40026fc:	2025883a 	mov	r18,r4
 4002700:	2827883a 	mov	r19,r5
 4002704:	e0bfff17 	ldw	r2,-4(fp)
 4002708:	14000817 	ldw	r16,32(r2)
 400270c:	14400917 	ldw	r17,36(r2)
 4002710:	e0bffe17 	ldw	r2,-8(fp)
 4002714:	1080008b 	ldhu	r2,2(r2)
 4002718:	113fffcc 	andi	r4,r2,65535
 400271c:	40036b80 	call	40036b8 <__floatsidf>
 4002720:	100f883a 	mov	r7,r2
 4002724:	1811883a 	mov	r8,r3
 4002728:	8009883a 	mov	r4,r16
 400272c:	880b883a 	mov	r5,r17
 4002730:	380d883a 	mov	r6,r7
 4002734:	400f883a 	mov	r7,r8
 4002738:	4002f040 	call	4002f04 <__muldf3>
 400273c:	1009883a 	mov	r4,r2
 4002740:	180b883a 	mov	r5,r3
 4002744:	2005883a 	mov	r2,r4
 4002748:	2807883a 	mov	r3,r5
 400274c:	9009883a 	mov	r4,r18
 4002750:	980b883a 	mov	r5,r19
 4002754:	100d883a 	mov	r6,r2
 4002758:	180f883a 	mov	r7,r3
 400275c:	4002e900 	call	4002e90 <__adddf3>
 4002760:	1009883a 	mov	r4,r2
 4002764:	180b883a 	mov	r5,r3
 4002768:	200d883a 	mov	r6,r4
 400276c:	280f883a 	mov	r7,r5
 4002770:	e13fff17 	ldw	r4,-4(fp)
 4002774:	20800a17 	ldw	r2,40(r4)
 4002778:	20c00b17 	ldw	r3,44(r4)
 400277c:	3009883a 	mov	r4,r6
 4002780:	380b883a 	mov	r5,r7
 4002784:	100d883a 	mov	r6,r2
 4002788:	180f883a 	mov	r7,r3
 400278c:	4002e900 	call	4002e90 <__adddf3>
 4002790:	1009883a 	mov	r4,r2
 4002794:	180b883a 	mov	r5,r3
 4002798:	200d883a 	mov	r6,r4
 400279c:	280f883a 	mov	r7,r5
 40027a0:	e13fff17 	ldw	r4,-4(fp)
 40027a4:	20800c17 	ldw	r2,48(r4)
 40027a8:	20c00d17 	ldw	r3,52(r4)
 40027ac:	3009883a 	mov	r4,r6
 40027b0:	380b883a 	mov	r5,r7
 40027b4:	100d883a 	mov	r6,r2
 40027b8:	180f883a 	mov	r7,r3
 40027bc:	40032c80 	call	40032c8 <__divdf3>
 40027c0:	1009883a 	mov	r4,r2
 40027c4:	180b883a 	mov	r5,r3
 40027c8:	2005883a 	mov	r2,r4
 40027cc:	2807883a 	mov	r3,r5
 40027d0:	1009883a 	mov	r4,r2
 40027d4:	180b883a 	mov	r5,r3
 40027d8:	400295c0 	call	400295c <__fixunsdfsi>
 40027dc:	1007883a 	mov	r3,r2
 40027e0:	e0bffd17 	ldw	r2,-12(fp)
 40027e4:	10c0008d 	sth	r3,2(r2)
 40027e8:	00000106 	br	40027f0 <getDisplayPoint+0x2c0>
                       matrixPtr->Fn 
                    ) / matrixPtr->Divider ;
  }
  else
  {
    retTHRESHOLD = 0;
 40027ec:	e03ffc05 	stb	zero,-16(fp)
  }
  return(retTHRESHOLD);
 40027f0:	e0bffc03 	ldbu	r2,-16(fp)
} 
 40027f4:	e037883a 	mov	sp,fp
 40027f8:	dfc00517 	ldw	ra,20(sp)
 40027fc:	df000417 	ldw	fp,16(sp)
 4002800:	dcc00317 	ldw	r19,12(sp)
 4002804:	dc800217 	ldw	r18,8(sp)
 4002808:	dc400117 	ldw	r17,4(sp)
 400280c:	dc000017 	ldw	r16,0(sp)
 4002810:	dec00604 	addi	sp,sp,24
 4002814:	f800283a 	ret

04002818 <TouchPanel_Calibrate>:
* Output         : None
* Return         : None
* Attention      : None
*******************************************************************************/
void TouchPanel_Calibrate(void)
{
 4002818:	defffb04 	addi	sp,sp,-20
 400281c:	dfc00415 	stw	ra,16(sp)
 4002820:	df000315 	stw	fp,12(sp)
 4002824:	df000304 	addi	fp,sp,12
  alt_u8 i;
  Coordinate * Ptr;

  for(i=0;i<3;i++)
 4002828:	e03fff05 	stb	zero,-4(fp)
 400282c:	00003a06 	br	4002918 <TouchPanel_Calibrate+0x100>
  {
   LCD_Clear(Cyan);
 4002830:	011fffc4 	movi	r4,32767
 4002834:	4000bcc0 	call	4000bcc <LCD_Clear>
   GUI_Text(44,10,"Touch crosshair to calibrate",Red,White);
 4002838:	01810034 	movhi	r6,1024
 400283c:	319f1104 	addi	r6,r6,31812
 4002840:	00bfffd4 	movui	r2,65535
 4002844:	d8800015 	stw	r2,0(sp)
 4002848:	01000b04 	movi	r4,44
 400284c:	01400284 	movi	r5,10
 4002850:	01fe0014 	movui	r7,63488
 4002854:	40013d00 	call	40013d0 <GUI_Text>
   delay_ms(500);
 4002858:	01000234 	movhi	r4,8
 400285c:	21284804 	addi	r4,r4,-24288
 4002860:	4003fc00 	call	4003fc0 <usleep>
   DrawCross(DisplaySample[i].x,DisplaySample[i].y);
 4002864:	e0bfff03 	ldbu	r2,-4(fp)
 4002868:	00c10034 	movhi	r3,1024
 400286c:	18df6d04 	addi	r3,r3,32180
 4002870:	1085883a 	add	r2,r2,r2
 4002874:	1085883a 	add	r2,r2,r2
 4002878:	10c5883a 	add	r2,r2,r3
 400287c:	1080000b 	ldhu	r2,0(r2)
 4002880:	113fffcc 	andi	r4,r2,65535
 4002884:	e0bfff03 	ldbu	r2,-4(fp)
 4002888:	00c10034 	movhi	r3,1024
 400288c:	18df6d04 	addi	r3,r3,32180
 4002890:	1085883a 	add	r2,r2,r2
 4002894:	1085883a 	add	r2,r2,r2
 4002898:	10c5883a 	add	r2,r2,r3
 400289c:	10800084 	addi	r2,r2,2
 40028a0:	1080000b 	ldhu	r2,0(r2)
 40028a4:	117fffcc 	andi	r5,r2,65535
 40028a8:	400186c0 	call	400186c <DrawCross>
   do
   {
     Ptr=Read_Ads7846();
 40028ac:	4001b480 	call	4001b48 <Read_Ads7846>
 40028b0:	e0bffe15 	stw	r2,-8(fp)
   }
   while( Ptr == (void*)0 );
 40028b4:	e0bffe17 	ldw	r2,-8(fp)
 40028b8:	1005003a 	cmpeq	r2,r2,zero
 40028bc:	103ffb1e 	bne	r2,zero,40028ac <TouchPanel_Calibrate+0x94>
   ScreenSample[i].x= Ptr->x; ScreenSample[i].y= Ptr->y;
 40028c0:	e0ffff03 	ldbu	r3,-4(fp)
 40028c4:	e0bffe17 	ldw	r2,-8(fp)
 40028c8:	1140000b 	ldhu	r5,0(r2)
 40028cc:	01010074 	movhi	r4,1025
 40028d0:	21253b04 	addi	r4,r4,-27412
 40028d4:	18c5883a 	add	r2,r3,r3
 40028d8:	1085883a 	add	r2,r2,r2
 40028dc:	1105883a 	add	r2,r2,r4
 40028e0:	1140000d 	sth	r5,0(r2)
 40028e4:	e0ffff03 	ldbu	r3,-4(fp)
 40028e8:	e0bffe17 	ldw	r2,-8(fp)
 40028ec:	1140008b 	ldhu	r5,2(r2)
 40028f0:	01010074 	movhi	r4,1025
 40028f4:	21253b04 	addi	r4,r4,-27412
 40028f8:	18c5883a 	add	r2,r3,r3
 40028fc:	1085883a 	add	r2,r2,r2
 4002900:	1105883a 	add	r2,r2,r4
 4002904:	10800084 	addi	r2,r2,2
 4002908:	1140000d 	sth	r5,0(r2)
void TouchPanel_Calibrate(void)
{
  alt_u8 i;
  Coordinate * Ptr;

  for(i=0;i<3;i++)
 400290c:	e0bfff03 	ldbu	r2,-4(fp)
 4002910:	10800044 	addi	r2,r2,1
 4002914:	e0bfff05 	stb	r2,-4(fp)
 4002918:	e0bfff03 	ldbu	r2,-4(fp)
 400291c:	108000f0 	cmpltui	r2,r2,3
 4002920:	103fc31e 	bne	r2,zero,4002830 <TouchPanel_Calibrate+0x18>
     Ptr=Read_Ads7846();
   }
   while( Ptr == (void*)0 );
   ScreenSample[i].x= Ptr->x; ScreenSample[i].y= Ptr->y;
  }
  setCalibrationMatrix( &DisplaySample[0],&ScreenSample[0],&matrix );
 4002924:	01010034 	movhi	r4,1024
 4002928:	211f6d04 	addi	r4,r4,32180
 400292c:	01410074 	movhi	r5,1025
 4002930:	29653b04 	addi	r5,r5,-27412
 4002934:	01810074 	movhi	r6,1025
 4002938:	31a53e04 	addi	r6,r6,-27400
 400293c:	4001f0c0 	call	4001f0c <setCalibrationMatrix>
  LCD_Clear(RGB565CONVERT(200,200,120));
 4002940:	013393d4 	movui	r4,52815
 4002944:	4000bcc0 	call	4000bcc <LCD_Clear>
} 
 4002948:	e037883a 	mov	sp,fp
 400294c:	dfc00117 	ldw	ra,4(sp)
 4002950:	df000017 	ldw	fp,0(sp)
 4002954:	dec00204 	addi	sp,sp,8
 4002958:	f800283a 	ret

0400295c <__fixunsdfsi>:
 400295c:	defffb04 	addi	sp,sp,-20
 4002960:	dc400115 	stw	r17,4(sp)
 4002964:	dc000015 	stw	r16,0(sp)
 4002968:	04507834 	movhi	r17,16864
 400296c:	0021883a 	mov	r16,zero
 4002970:	800d883a 	mov	r6,r16
 4002974:	880f883a 	mov	r7,r17
 4002978:	dcc00315 	stw	r19,12(sp)
 400297c:	dc800215 	stw	r18,8(sp)
 4002980:	2827883a 	mov	r19,r5
 4002984:	2025883a 	mov	r18,r4
 4002988:	dfc00415 	stw	ra,16(sp)
 400298c:	40036300 	call	4003630 <__gedf2>
 4002990:	000d883a 	mov	r6,zero
 4002994:	880f883a 	mov	r7,r17
 4002998:	980b883a 	mov	r5,r19
 400299c:	9009883a 	mov	r4,r18
 40029a0:	10000d16 	blt	r2,zero,40029d8 <__fixunsdfsi+0x7c>
 40029a4:	4002e100 	call	4002e10 <__subdf3>
 40029a8:	180b883a 	mov	r5,r3
 40029ac:	1009883a 	mov	r4,r2
 40029b0:	40037b00 	call	40037b0 <__fixdfsi>
 40029b4:	00e00034 	movhi	r3,32768
 40029b8:	10c5883a 	add	r2,r2,r3
 40029bc:	dfc00417 	ldw	ra,16(sp)
 40029c0:	dcc00317 	ldw	r19,12(sp)
 40029c4:	dc800217 	ldw	r18,8(sp)
 40029c8:	dc400117 	ldw	r17,4(sp)
 40029cc:	dc000017 	ldw	r16,0(sp)
 40029d0:	dec00504 	addi	sp,sp,20
 40029d4:	f800283a 	ret
 40029d8:	980b883a 	mov	r5,r19
 40029dc:	9009883a 	mov	r4,r18
 40029e0:	40037b00 	call	40037b0 <__fixdfsi>
 40029e4:	dfc00417 	ldw	ra,16(sp)
 40029e8:	dcc00317 	ldw	r19,12(sp)
 40029ec:	dc800217 	ldw	r18,8(sp)
 40029f0:	dc400117 	ldw	r17,4(sp)
 40029f4:	dc000017 	ldw	r16,0(sp)
 40029f8:	dec00504 	addi	sp,sp,20
 40029fc:	f800283a 	ret

04002a00 <_fpadd_parts>:
 4002a00:	defff804 	addi	sp,sp,-32
 4002a04:	dcc00315 	stw	r19,12(sp)
 4002a08:	2027883a 	mov	r19,r4
 4002a0c:	21000017 	ldw	r4,0(r4)
 4002a10:	00c00044 	movi	r3,1
 4002a14:	dd400515 	stw	r21,20(sp)
 4002a18:	dd000415 	stw	r20,16(sp)
 4002a1c:	ddc00715 	stw	r23,28(sp)
 4002a20:	dd800615 	stw	r22,24(sp)
 4002a24:	dc800215 	stw	r18,8(sp)
 4002a28:	dc400115 	stw	r17,4(sp)
 4002a2c:	dc000015 	stw	r16,0(sp)
 4002a30:	282b883a 	mov	r21,r5
 4002a34:	3029883a 	mov	r20,r6
 4002a38:	1900632e 	bgeu	r3,r4,4002bc8 <_fpadd_parts+0x1c8>
 4002a3c:	28800017 	ldw	r2,0(r5)
 4002a40:	1880812e 	bgeu	r3,r2,4002c48 <_fpadd_parts+0x248>
 4002a44:	00c00104 	movi	r3,4
 4002a48:	20c0dc26 	beq	r4,r3,4002dbc <_fpadd_parts+0x3bc>
 4002a4c:	10c07e26 	beq	r2,r3,4002c48 <_fpadd_parts+0x248>
 4002a50:	00c00084 	movi	r3,2
 4002a54:	10c06726 	beq	r2,r3,4002bf4 <_fpadd_parts+0x1f4>
 4002a58:	20c07b26 	beq	r4,r3,4002c48 <_fpadd_parts+0x248>
 4002a5c:	9dc00217 	ldw	r23,8(r19)
 4002a60:	28c00217 	ldw	r3,8(r5)
 4002a64:	9c400317 	ldw	r17,12(r19)
 4002a68:	2bc00317 	ldw	r15,12(r5)
 4002a6c:	b8cdc83a 	sub	r6,r23,r3
 4002a70:	9c800417 	ldw	r18,16(r19)
 4002a74:	2c000417 	ldw	r16,16(r5)
 4002a78:	3009883a 	mov	r4,r6
 4002a7c:	30009716 	blt	r6,zero,4002cdc <_fpadd_parts+0x2dc>
 4002a80:	00800fc4 	movi	r2,63
 4002a84:	11806b16 	blt	r2,r6,4002c34 <_fpadd_parts+0x234>
 4002a88:	0100a40e 	bge	zero,r4,4002d1c <_fpadd_parts+0x31c>
 4002a8c:	35bff804 	addi	r22,r6,-32
 4002a90:	b000bc16 	blt	r22,zero,4002d84 <_fpadd_parts+0x384>
 4002a94:	8596d83a 	srl	r11,r16,r22
 4002a98:	0019883a 	mov	r12,zero
 4002a9c:	0013883a 	mov	r9,zero
 4002aa0:	01000044 	movi	r4,1
 4002aa4:	0015883a 	mov	r10,zero
 4002aa8:	b000be16 	blt	r22,zero,4002da4 <_fpadd_parts+0x3a4>
 4002aac:	2590983a 	sll	r8,r4,r22
 4002ab0:	000f883a 	mov	r7,zero
 4002ab4:	00bfffc4 	movi	r2,-1
 4002ab8:	3889883a 	add	r4,r7,r2
 4002abc:	408b883a 	add	r5,r8,r2
 4002ac0:	21cd803a 	cmpltu	r6,r4,r7
 4002ac4:	314b883a 	add	r5,r6,r5
 4002ac8:	7904703a 	and	r2,r15,r4
 4002acc:	8146703a 	and	r3,r16,r5
 4002ad0:	10c4b03a 	or	r2,r2,r3
 4002ad4:	10000226 	beq	r2,zero,4002ae0 <_fpadd_parts+0xe0>
 4002ad8:	02400044 	movi	r9,1
 4002adc:	0015883a 	mov	r10,zero
 4002ae0:	5a5eb03a 	or	r15,r11,r9
 4002ae4:	62a0b03a 	or	r16,r12,r10
 4002ae8:	99400117 	ldw	r5,4(r19)
 4002aec:	a8800117 	ldw	r2,4(r21)
 4002af0:	28806e26 	beq	r5,r2,4002cac <_fpadd_parts+0x2ac>
 4002af4:	28006626 	beq	r5,zero,4002c90 <_fpadd_parts+0x290>
 4002af8:	7c45c83a 	sub	r2,r15,r17
 4002afc:	7889803a 	cmpltu	r4,r15,r2
 4002b00:	8487c83a 	sub	r3,r16,r18
 4002b04:	1909c83a 	sub	r4,r3,r4
 4002b08:	100d883a 	mov	r6,r2
 4002b0c:	200f883a 	mov	r7,r4
 4002b10:	38007716 	blt	r7,zero,4002cf0 <_fpadd_parts+0x2f0>
 4002b14:	a5c00215 	stw	r23,8(r20)
 4002b18:	a1c00415 	stw	r7,16(r20)
 4002b1c:	a0000115 	stw	zero,4(r20)
 4002b20:	a1800315 	stw	r6,12(r20)
 4002b24:	a2000317 	ldw	r8,12(r20)
 4002b28:	a2400417 	ldw	r9,16(r20)
 4002b2c:	00bfffc4 	movi	r2,-1
 4002b30:	408b883a 	add	r5,r8,r2
 4002b34:	2a09803a 	cmpltu	r4,r5,r8
 4002b38:	488d883a 	add	r6,r9,r2
 4002b3c:	01c40034 	movhi	r7,4096
 4002b40:	39ffffc4 	addi	r7,r7,-1
 4002b44:	218d883a 	add	r6,r4,r6
 4002b48:	39801736 	bltu	r7,r6,4002ba8 <_fpadd_parts+0x1a8>
 4002b4c:	31c06526 	beq	r6,r7,4002ce4 <_fpadd_parts+0x2e4>
 4002b50:	a3000217 	ldw	r12,8(r20)
 4002b54:	4209883a 	add	r4,r8,r8
 4002b58:	00bfffc4 	movi	r2,-1
 4002b5c:	220f803a 	cmpltu	r7,r4,r8
 4002b60:	4a4b883a 	add	r5,r9,r9
 4002b64:	394f883a 	add	r7,r7,r5
 4002b68:	2095883a 	add	r10,r4,r2
 4002b6c:	3897883a 	add	r11,r7,r2
 4002b70:	510d803a 	cmpltu	r6,r10,r4
 4002b74:	6099883a 	add	r12,r12,r2
 4002b78:	32d7883a 	add	r11,r6,r11
 4002b7c:	00840034 	movhi	r2,4096
 4002b80:	10bfffc4 	addi	r2,r2,-1
 4002b84:	2011883a 	mov	r8,r4
 4002b88:	3813883a 	mov	r9,r7
 4002b8c:	a1000315 	stw	r4,12(r20)
 4002b90:	a1c00415 	stw	r7,16(r20)
 4002b94:	a3000215 	stw	r12,8(r20)
 4002b98:	12c00336 	bltu	r2,r11,4002ba8 <_fpadd_parts+0x1a8>
 4002b9c:	58bfed1e 	bne	r11,r2,4002b54 <_fpadd_parts+0x154>
 4002ba0:	00bfff84 	movi	r2,-2
 4002ba4:	12bfeb2e 	bgeu	r2,r10,4002b54 <_fpadd_parts+0x154>
 4002ba8:	a2800417 	ldw	r10,16(r20)
 4002bac:	008000c4 	movi	r2,3
 4002bb0:	00c80034 	movhi	r3,8192
 4002bb4:	18ffffc4 	addi	r3,r3,-1
 4002bb8:	a2400317 	ldw	r9,12(r20)
 4002bbc:	a0800015 	stw	r2,0(r20)
 4002bc0:	1a802336 	bltu	r3,r10,4002c50 <_fpadd_parts+0x250>
 4002bc4:	a027883a 	mov	r19,r20
 4002bc8:	9805883a 	mov	r2,r19
 4002bcc:	ddc00717 	ldw	r23,28(sp)
 4002bd0:	dd800617 	ldw	r22,24(sp)
 4002bd4:	dd400517 	ldw	r21,20(sp)
 4002bd8:	dd000417 	ldw	r20,16(sp)
 4002bdc:	dcc00317 	ldw	r19,12(sp)
 4002be0:	dc800217 	ldw	r18,8(sp)
 4002be4:	dc400117 	ldw	r17,4(sp)
 4002be8:	dc000017 	ldw	r16,0(sp)
 4002bec:	dec00804 	addi	sp,sp,32
 4002bf0:	f800283a 	ret
 4002bf4:	20fff41e 	bne	r4,r3,4002bc8 <_fpadd_parts+0x1c8>
 4002bf8:	31000015 	stw	r4,0(r6)
 4002bfc:	98800117 	ldw	r2,4(r19)
 4002c00:	30800115 	stw	r2,4(r6)
 4002c04:	98c00217 	ldw	r3,8(r19)
 4002c08:	30c00215 	stw	r3,8(r6)
 4002c0c:	98800317 	ldw	r2,12(r19)
 4002c10:	30800315 	stw	r2,12(r6)
 4002c14:	98c00417 	ldw	r3,16(r19)
 4002c18:	30c00415 	stw	r3,16(r6)
 4002c1c:	98800117 	ldw	r2,4(r19)
 4002c20:	28c00117 	ldw	r3,4(r5)
 4002c24:	3027883a 	mov	r19,r6
 4002c28:	10c4703a 	and	r2,r2,r3
 4002c2c:	30800115 	stw	r2,4(r6)
 4002c30:	003fe506 	br	4002bc8 <_fpadd_parts+0x1c8>
 4002c34:	1dc02616 	blt	r3,r23,4002cd0 <_fpadd_parts+0x2d0>
 4002c38:	0023883a 	mov	r17,zero
 4002c3c:	182f883a 	mov	r23,r3
 4002c40:	0025883a 	mov	r18,zero
 4002c44:	003fa806 	br	4002ae8 <_fpadd_parts+0xe8>
 4002c48:	a827883a 	mov	r19,r21
 4002c4c:	003fde06 	br	4002bc8 <_fpadd_parts+0x1c8>
 4002c50:	01800044 	movi	r6,1
 4002c54:	500497fa 	slli	r2,r10,31
 4002c58:	4808d07a 	srli	r4,r9,1
 4002c5c:	518ad83a 	srl	r5,r10,r6
 4002c60:	a2000217 	ldw	r8,8(r20)
 4002c64:	1108b03a 	or	r4,r2,r4
 4002c68:	0007883a 	mov	r3,zero
 4002c6c:	4984703a 	and	r2,r9,r6
 4002c70:	208cb03a 	or	r6,r4,r2
 4002c74:	28ceb03a 	or	r7,r5,r3
 4002c78:	42000044 	addi	r8,r8,1
 4002c7c:	a027883a 	mov	r19,r20
 4002c80:	a1c00415 	stw	r7,16(r20)
 4002c84:	a2000215 	stw	r8,8(r20)
 4002c88:	a1800315 	stw	r6,12(r20)
 4002c8c:	003fce06 	br	4002bc8 <_fpadd_parts+0x1c8>
 4002c90:	8bc5c83a 	sub	r2,r17,r15
 4002c94:	8889803a 	cmpltu	r4,r17,r2
 4002c98:	9407c83a 	sub	r3,r18,r16
 4002c9c:	1909c83a 	sub	r4,r3,r4
 4002ca0:	100d883a 	mov	r6,r2
 4002ca4:	200f883a 	mov	r7,r4
 4002ca8:	003f9906 	br	4002b10 <_fpadd_parts+0x110>
 4002cac:	7c45883a 	add	r2,r15,r17
 4002cb0:	13c9803a 	cmpltu	r4,r2,r15
 4002cb4:	8487883a 	add	r3,r16,r18
 4002cb8:	20c9883a 	add	r4,r4,r3
 4002cbc:	a1400115 	stw	r5,4(r20)
 4002cc0:	a5c00215 	stw	r23,8(r20)
 4002cc4:	a0800315 	stw	r2,12(r20)
 4002cc8:	a1000415 	stw	r4,16(r20)
 4002ccc:	003fb606 	br	4002ba8 <_fpadd_parts+0x1a8>
 4002cd0:	001f883a 	mov	r15,zero
 4002cd4:	0021883a 	mov	r16,zero
 4002cd8:	003f8306 	br	4002ae8 <_fpadd_parts+0xe8>
 4002cdc:	018dc83a 	sub	r6,zero,r6
 4002ce0:	003f6706 	br	4002a80 <_fpadd_parts+0x80>
 4002ce4:	00bfff84 	movi	r2,-2
 4002ce8:	117faf36 	bltu	r2,r5,4002ba8 <_fpadd_parts+0x1a8>
 4002cec:	003f9806 	br	4002b50 <_fpadd_parts+0x150>
 4002cf0:	0005883a 	mov	r2,zero
 4002cf4:	1189c83a 	sub	r4,r2,r6
 4002cf8:	1105803a 	cmpltu	r2,r2,r4
 4002cfc:	01cbc83a 	sub	r5,zero,r7
 4002d00:	2885c83a 	sub	r2,r5,r2
 4002d04:	01800044 	movi	r6,1
 4002d08:	a1800115 	stw	r6,4(r20)
 4002d0c:	a5c00215 	stw	r23,8(r20)
 4002d10:	a1000315 	stw	r4,12(r20)
 4002d14:	a0800415 	stw	r2,16(r20)
 4002d18:	003f8206 	br	4002b24 <_fpadd_parts+0x124>
 4002d1c:	203f7226 	beq	r4,zero,4002ae8 <_fpadd_parts+0xe8>
 4002d20:	35bff804 	addi	r22,r6,-32
 4002d24:	b9af883a 	add	r23,r23,r6
 4002d28:	b0003116 	blt	r22,zero,4002df0 <_fpadd_parts+0x3f0>
 4002d2c:	959ad83a 	srl	r13,r18,r22
 4002d30:	001d883a 	mov	r14,zero
 4002d34:	000f883a 	mov	r7,zero
 4002d38:	01000044 	movi	r4,1
 4002d3c:	0011883a 	mov	r8,zero
 4002d40:	b0002516 	blt	r22,zero,4002dd8 <_fpadd_parts+0x3d8>
 4002d44:	2594983a 	sll	r10,r4,r22
 4002d48:	0013883a 	mov	r9,zero
 4002d4c:	00bfffc4 	movi	r2,-1
 4002d50:	4889883a 	add	r4,r9,r2
 4002d54:	508b883a 	add	r5,r10,r2
 4002d58:	224d803a 	cmpltu	r6,r4,r9
 4002d5c:	314b883a 	add	r5,r6,r5
 4002d60:	8904703a 	and	r2,r17,r4
 4002d64:	9146703a 	and	r3,r18,r5
 4002d68:	10c4b03a 	or	r2,r2,r3
 4002d6c:	10000226 	beq	r2,zero,4002d78 <_fpadd_parts+0x378>
 4002d70:	01c00044 	movi	r7,1
 4002d74:	0011883a 	mov	r8,zero
 4002d78:	69e2b03a 	or	r17,r13,r7
 4002d7c:	7224b03a 	or	r18,r14,r8
 4002d80:	003f5906 	br	4002ae8 <_fpadd_parts+0xe8>
 4002d84:	8407883a 	add	r3,r16,r16
 4002d88:	008007c4 	movi	r2,31
 4002d8c:	1185c83a 	sub	r2,r2,r6
 4002d90:	1886983a 	sll	r3,r3,r2
 4002d94:	7996d83a 	srl	r11,r15,r6
 4002d98:	8198d83a 	srl	r12,r16,r6
 4002d9c:	1ad6b03a 	or	r11,r3,r11
 4002da0:	003f3e06 	br	4002a9c <_fpadd_parts+0x9c>
 4002da4:	2006d07a 	srli	r3,r4,1
 4002da8:	008007c4 	movi	r2,31
 4002dac:	1185c83a 	sub	r2,r2,r6
 4002db0:	1890d83a 	srl	r8,r3,r2
 4002db4:	218e983a 	sll	r7,r4,r6
 4002db8:	003f3e06 	br	4002ab4 <_fpadd_parts+0xb4>
 4002dbc:	113f821e 	bne	r2,r4,4002bc8 <_fpadd_parts+0x1c8>
 4002dc0:	28c00117 	ldw	r3,4(r5)
 4002dc4:	98800117 	ldw	r2,4(r19)
 4002dc8:	10ff7f26 	beq	r2,r3,4002bc8 <_fpadd_parts+0x1c8>
 4002dcc:	04c10034 	movhi	r19,1024
 4002dd0:	9cdf1904 	addi	r19,r19,31844
 4002dd4:	003f7c06 	br	4002bc8 <_fpadd_parts+0x1c8>
 4002dd8:	2006d07a 	srli	r3,r4,1
 4002ddc:	008007c4 	movi	r2,31
 4002de0:	1185c83a 	sub	r2,r2,r6
 4002de4:	1894d83a 	srl	r10,r3,r2
 4002de8:	2192983a 	sll	r9,r4,r6
 4002dec:	003fd706 	br	4002d4c <_fpadd_parts+0x34c>
 4002df0:	9487883a 	add	r3,r18,r18
 4002df4:	008007c4 	movi	r2,31
 4002df8:	1185c83a 	sub	r2,r2,r6
 4002dfc:	1886983a 	sll	r3,r3,r2
 4002e00:	899ad83a 	srl	r13,r17,r6
 4002e04:	919cd83a 	srl	r14,r18,r6
 4002e08:	1b5ab03a 	or	r13,r3,r13
 4002e0c:	003fc906 	br	4002d34 <_fpadd_parts+0x334>

04002e10 <__subdf3>:
 4002e10:	deffea04 	addi	sp,sp,-88
 4002e14:	dcc01415 	stw	r19,80(sp)
 4002e18:	dcc00404 	addi	r19,sp,16
 4002e1c:	2011883a 	mov	r8,r4
 4002e20:	2813883a 	mov	r9,r5
 4002e24:	dc401315 	stw	r17,76(sp)
 4002e28:	d809883a 	mov	r4,sp
 4002e2c:	980b883a 	mov	r5,r19
 4002e30:	dc400904 	addi	r17,sp,36
 4002e34:	dfc01515 	stw	ra,84(sp)
 4002e38:	da400115 	stw	r9,4(sp)
 4002e3c:	d9c00315 	stw	r7,12(sp)
 4002e40:	da000015 	stw	r8,0(sp)
 4002e44:	d9800215 	stw	r6,8(sp)
 4002e48:	4003cb40 	call	4003cb4 <__unpack_d>
 4002e4c:	d9000204 	addi	r4,sp,8
 4002e50:	880b883a 	mov	r5,r17
 4002e54:	4003cb40 	call	4003cb4 <__unpack_d>
 4002e58:	d8800a17 	ldw	r2,40(sp)
 4002e5c:	880b883a 	mov	r5,r17
 4002e60:	9809883a 	mov	r4,r19
 4002e64:	d9800e04 	addi	r6,sp,56
 4002e68:	1080005c 	xori	r2,r2,1
 4002e6c:	d8800a15 	stw	r2,40(sp)
 4002e70:	4002a000 	call	4002a00 <_fpadd_parts>
 4002e74:	1009883a 	mov	r4,r2
 4002e78:	40039a00 	call	40039a0 <__pack_d>
 4002e7c:	dfc01517 	ldw	ra,84(sp)
 4002e80:	dcc01417 	ldw	r19,80(sp)
 4002e84:	dc401317 	ldw	r17,76(sp)
 4002e88:	dec01604 	addi	sp,sp,88
 4002e8c:	f800283a 	ret

04002e90 <__adddf3>:
 4002e90:	deffea04 	addi	sp,sp,-88
 4002e94:	dcc01415 	stw	r19,80(sp)
 4002e98:	dcc00404 	addi	r19,sp,16
 4002e9c:	2011883a 	mov	r8,r4
 4002ea0:	2813883a 	mov	r9,r5
 4002ea4:	dc401315 	stw	r17,76(sp)
 4002ea8:	d809883a 	mov	r4,sp
 4002eac:	980b883a 	mov	r5,r19
 4002eb0:	dc400904 	addi	r17,sp,36
 4002eb4:	dfc01515 	stw	ra,84(sp)
 4002eb8:	da400115 	stw	r9,4(sp)
 4002ebc:	d9c00315 	stw	r7,12(sp)
 4002ec0:	da000015 	stw	r8,0(sp)
 4002ec4:	d9800215 	stw	r6,8(sp)
 4002ec8:	4003cb40 	call	4003cb4 <__unpack_d>
 4002ecc:	d9000204 	addi	r4,sp,8
 4002ed0:	880b883a 	mov	r5,r17
 4002ed4:	4003cb40 	call	4003cb4 <__unpack_d>
 4002ed8:	d9800e04 	addi	r6,sp,56
 4002edc:	9809883a 	mov	r4,r19
 4002ee0:	880b883a 	mov	r5,r17
 4002ee4:	4002a000 	call	4002a00 <_fpadd_parts>
 4002ee8:	1009883a 	mov	r4,r2
 4002eec:	40039a00 	call	40039a0 <__pack_d>
 4002ef0:	dfc01517 	ldw	ra,84(sp)
 4002ef4:	dcc01417 	ldw	r19,80(sp)
 4002ef8:	dc401317 	ldw	r17,76(sp)
 4002efc:	dec01604 	addi	sp,sp,88
 4002f00:	f800283a 	ret

04002f04 <__muldf3>:
 4002f04:	deffe004 	addi	sp,sp,-128
 4002f08:	dc401815 	stw	r17,96(sp)
 4002f0c:	dc400404 	addi	r17,sp,16
 4002f10:	2011883a 	mov	r8,r4
 4002f14:	2813883a 	mov	r9,r5
 4002f18:	dc001715 	stw	r16,92(sp)
 4002f1c:	d809883a 	mov	r4,sp
 4002f20:	880b883a 	mov	r5,r17
 4002f24:	dc000904 	addi	r16,sp,36
 4002f28:	dfc01f15 	stw	ra,124(sp)
 4002f2c:	da400115 	stw	r9,4(sp)
 4002f30:	d9c00315 	stw	r7,12(sp)
 4002f34:	da000015 	stw	r8,0(sp)
 4002f38:	d9800215 	stw	r6,8(sp)
 4002f3c:	ddc01e15 	stw	r23,120(sp)
 4002f40:	dd801d15 	stw	r22,116(sp)
 4002f44:	dd401c15 	stw	r21,112(sp)
 4002f48:	dd001b15 	stw	r20,108(sp)
 4002f4c:	dcc01a15 	stw	r19,104(sp)
 4002f50:	dc801915 	stw	r18,100(sp)
 4002f54:	4003cb40 	call	4003cb4 <__unpack_d>
 4002f58:	d9000204 	addi	r4,sp,8
 4002f5c:	800b883a 	mov	r5,r16
 4002f60:	4003cb40 	call	4003cb4 <__unpack_d>
 4002f64:	d9000417 	ldw	r4,16(sp)
 4002f68:	00800044 	movi	r2,1
 4002f6c:	1100102e 	bgeu	r2,r4,4002fb0 <__muldf3+0xac>
 4002f70:	d8c00917 	ldw	r3,36(sp)
 4002f74:	10c0062e 	bgeu	r2,r3,4002f90 <__muldf3+0x8c>
 4002f78:	00800104 	movi	r2,4
 4002f7c:	20800a26 	beq	r4,r2,4002fa8 <__muldf3+0xa4>
 4002f80:	1880cc26 	beq	r3,r2,40032b4 <__muldf3+0x3b0>
 4002f84:	00800084 	movi	r2,2
 4002f88:	20800926 	beq	r4,r2,4002fb0 <__muldf3+0xac>
 4002f8c:	1880191e 	bne	r3,r2,4002ff4 <__muldf3+0xf0>
 4002f90:	d8c00a17 	ldw	r3,40(sp)
 4002f94:	d8800517 	ldw	r2,20(sp)
 4002f98:	8009883a 	mov	r4,r16
 4002f9c:	10c4c03a 	cmpne	r2,r2,r3
 4002fa0:	d8800a15 	stw	r2,40(sp)
 4002fa4:	00000706 	br	4002fc4 <__muldf3+0xc0>
 4002fa8:	00800084 	movi	r2,2
 4002fac:	1880c326 	beq	r3,r2,40032bc <__muldf3+0x3b8>
 4002fb0:	d8800517 	ldw	r2,20(sp)
 4002fb4:	d8c00a17 	ldw	r3,40(sp)
 4002fb8:	8809883a 	mov	r4,r17
 4002fbc:	10c4c03a 	cmpne	r2,r2,r3
 4002fc0:	d8800515 	stw	r2,20(sp)
 4002fc4:	40039a00 	call	40039a0 <__pack_d>
 4002fc8:	dfc01f17 	ldw	ra,124(sp)
 4002fcc:	ddc01e17 	ldw	r23,120(sp)
 4002fd0:	dd801d17 	ldw	r22,116(sp)
 4002fd4:	dd401c17 	ldw	r21,112(sp)
 4002fd8:	dd001b17 	ldw	r20,108(sp)
 4002fdc:	dcc01a17 	ldw	r19,104(sp)
 4002fe0:	dc801917 	ldw	r18,100(sp)
 4002fe4:	dc401817 	ldw	r17,96(sp)
 4002fe8:	dc001717 	ldw	r16,92(sp)
 4002fec:	dec02004 	addi	sp,sp,128
 4002ff0:	f800283a 	ret
 4002ff4:	dd800717 	ldw	r22,28(sp)
 4002ff8:	dc800c17 	ldw	r18,48(sp)
 4002ffc:	002b883a 	mov	r21,zero
 4003000:	0023883a 	mov	r17,zero
 4003004:	a80b883a 	mov	r5,r21
 4003008:	b00d883a 	mov	r6,r22
 400300c:	880f883a 	mov	r7,r17
 4003010:	ddc00817 	ldw	r23,32(sp)
 4003014:	dcc00d17 	ldw	r19,52(sp)
 4003018:	9009883a 	mov	r4,r18
 400301c:	40038880 	call	4003888 <__muldi3>
 4003020:	001b883a 	mov	r13,zero
 4003024:	680f883a 	mov	r7,r13
 4003028:	b009883a 	mov	r4,r22
 400302c:	000b883a 	mov	r5,zero
 4003030:	980d883a 	mov	r6,r19
 4003034:	b82d883a 	mov	r22,r23
 4003038:	002f883a 	mov	r23,zero
 400303c:	db401615 	stw	r13,88(sp)
 4003040:	d8801315 	stw	r2,76(sp)
 4003044:	d8c01415 	stw	r3,80(sp)
 4003048:	dcc01515 	stw	r19,84(sp)
 400304c:	40038880 	call	4003888 <__muldi3>
 4003050:	b00d883a 	mov	r6,r22
 4003054:	000b883a 	mov	r5,zero
 4003058:	9009883a 	mov	r4,r18
 400305c:	b80f883a 	mov	r7,r23
 4003060:	1021883a 	mov	r16,r2
 4003064:	1823883a 	mov	r17,r3
 4003068:	40038880 	call	4003888 <__muldi3>
 400306c:	8085883a 	add	r2,r16,r2
 4003070:	140d803a 	cmpltu	r6,r2,r16
 4003074:	88c7883a 	add	r3,r17,r3
 4003078:	30cd883a 	add	r6,r6,r3
 400307c:	1029883a 	mov	r20,r2
 4003080:	302b883a 	mov	r21,r6
 4003084:	da801317 	ldw	r10,76(sp)
 4003088:	dac01417 	ldw	r11,80(sp)
 400308c:	db001517 	ldw	r12,84(sp)
 4003090:	db401617 	ldw	r13,88(sp)
 4003094:	3440612e 	bgeu	r6,r17,400321c <__muldf3+0x318>
 4003098:	0009883a 	mov	r4,zero
 400309c:	5105883a 	add	r2,r10,r4
 40030a0:	128d803a 	cmpltu	r6,r2,r10
 40030a4:	5d07883a 	add	r3,r11,r20
 40030a8:	30cd883a 	add	r6,r6,r3
 40030ac:	0021883a 	mov	r16,zero
 40030b0:	04400044 	movi	r17,1
 40030b4:	1025883a 	mov	r18,r2
 40030b8:	3027883a 	mov	r19,r6
 40030bc:	32c06236 	bltu	r6,r11,4003248 <__muldf3+0x344>
 40030c0:	59807a26 	beq	r11,r6,40032ac <__muldf3+0x3a8>
 40030c4:	680b883a 	mov	r5,r13
 40030c8:	b80f883a 	mov	r7,r23
 40030cc:	6009883a 	mov	r4,r12
 40030d0:	b00d883a 	mov	r6,r22
 40030d4:	40038880 	call	4003888 <__muldi3>
 40030d8:	1009883a 	mov	r4,r2
 40030dc:	000f883a 	mov	r7,zero
 40030e0:	1545883a 	add	r2,r2,r21
 40030e4:	1111803a 	cmpltu	r8,r2,r4
 40030e8:	19c7883a 	add	r3,r3,r7
 40030ec:	40c7883a 	add	r3,r8,r3
 40030f0:	88cb883a 	add	r5,r17,r3
 40030f4:	d8c00617 	ldw	r3,24(sp)
 40030f8:	8089883a 	add	r4,r16,r2
 40030fc:	d8800b17 	ldw	r2,44(sp)
 4003100:	18c00104 	addi	r3,r3,4
 4003104:	240d803a 	cmpltu	r6,r4,r16
 4003108:	10c7883a 	add	r3,r2,r3
 400310c:	2013883a 	mov	r9,r4
 4003110:	d8800a17 	ldw	r2,40(sp)
 4003114:	d9000517 	ldw	r4,20(sp)
 4003118:	314d883a 	add	r6,r6,r5
 400311c:	3015883a 	mov	r10,r6
 4003120:	2088c03a 	cmpne	r4,r4,r2
 4003124:	00880034 	movhi	r2,8192
 4003128:	10bfffc4 	addi	r2,r2,-1
 400312c:	d9000f15 	stw	r4,60(sp)
 4003130:	d8c01015 	stw	r3,64(sp)
 4003134:	1180162e 	bgeu	r2,r6,4003190 <__muldf3+0x28c>
 4003138:	1811883a 	mov	r8,r3
 400313c:	101f883a 	mov	r15,r2
 4003140:	980497fa 	slli	r2,r19,31
 4003144:	9016d07a 	srli	r11,r18,1
 4003148:	500697fa 	slli	r3,r10,31
 400314c:	480cd07a 	srli	r6,r9,1
 4003150:	500ed07a 	srli	r7,r10,1
 4003154:	12d6b03a 	or	r11,r2,r11
 4003158:	00800044 	movi	r2,1
 400315c:	198cb03a 	or	r6,r3,r6
 4003160:	4888703a 	and	r4,r9,r2
 4003164:	9818d07a 	srli	r12,r19,1
 4003168:	001b883a 	mov	r13,zero
 400316c:	03a00034 	movhi	r14,32768
 4003170:	3013883a 	mov	r9,r6
 4003174:	3815883a 	mov	r10,r7
 4003178:	4091883a 	add	r8,r8,r2
 400317c:	20000226 	beq	r4,zero,4003188 <__muldf3+0x284>
 4003180:	5b64b03a 	or	r18,r11,r13
 4003184:	63a6b03a 	or	r19,r12,r14
 4003188:	7abfed36 	bltu	r15,r10,4003140 <__muldf3+0x23c>
 400318c:	da001015 	stw	r8,64(sp)
 4003190:	00840034 	movhi	r2,4096
 4003194:	10bfffc4 	addi	r2,r2,-1
 4003198:	12801436 	bltu	r2,r10,40031ec <__muldf3+0x2e8>
 400319c:	da001017 	ldw	r8,64(sp)
 40031a0:	101f883a 	mov	r15,r2
 40031a4:	4a45883a 	add	r2,r9,r9
 40031a8:	124d803a 	cmpltu	r6,r2,r9
 40031ac:	5287883a 	add	r3,r10,r10
 40031b0:	9497883a 	add	r11,r18,r18
 40031b4:	5c8f803a 	cmpltu	r7,r11,r18
 40031b8:	9cd9883a 	add	r12,r19,r19
 40031bc:	01000044 	movi	r4,1
 40031c0:	30cd883a 	add	r6,r6,r3
 40031c4:	3b0f883a 	add	r7,r7,r12
 40031c8:	423fffc4 	addi	r8,r8,-1
 40031cc:	1013883a 	mov	r9,r2
 40031d0:	3015883a 	mov	r10,r6
 40031d4:	111ab03a 	or	r13,r2,r4
 40031d8:	98003016 	blt	r19,zero,400329c <__muldf3+0x398>
 40031dc:	5825883a 	mov	r18,r11
 40031e0:	3827883a 	mov	r19,r7
 40031e4:	7abfef2e 	bgeu	r15,r10,40031a4 <__muldf3+0x2a0>
 40031e8:	da001015 	stw	r8,64(sp)
 40031ec:	00803fc4 	movi	r2,255
 40031f0:	488e703a 	and	r7,r9,r2
 40031f4:	00802004 	movi	r2,128
 40031f8:	0007883a 	mov	r3,zero
 40031fc:	0011883a 	mov	r8,zero
 4003200:	38801826 	beq	r7,r2,4003264 <__muldf3+0x360>
 4003204:	008000c4 	movi	r2,3
 4003208:	d9000e04 	addi	r4,sp,56
 400320c:	da801215 	stw	r10,72(sp)
 4003210:	d8800e15 	stw	r2,56(sp)
 4003214:	da401115 	stw	r9,68(sp)
 4003218:	003f6a06 	br	4002fc4 <__muldf3+0xc0>
 400321c:	89802126 	beq	r17,r6,40032a4 <__muldf3+0x3a0>
 4003220:	0009883a 	mov	r4,zero
 4003224:	5105883a 	add	r2,r10,r4
 4003228:	128d803a 	cmpltu	r6,r2,r10
 400322c:	5d07883a 	add	r3,r11,r20
 4003230:	30cd883a 	add	r6,r6,r3
 4003234:	0021883a 	mov	r16,zero
 4003238:	0023883a 	mov	r17,zero
 400323c:	1025883a 	mov	r18,r2
 4003240:	3027883a 	mov	r19,r6
 4003244:	32ff9e2e 	bgeu	r6,r11,40030c0 <__muldf3+0x1bc>
 4003248:	00800044 	movi	r2,1
 400324c:	8089883a 	add	r4,r16,r2
 4003250:	240d803a 	cmpltu	r6,r4,r16
 4003254:	344d883a 	add	r6,r6,r17
 4003258:	2021883a 	mov	r16,r4
 400325c:	3023883a 	mov	r17,r6
 4003260:	003f9806 	br	40030c4 <__muldf3+0x1c0>
 4003264:	403fe71e 	bne	r8,zero,4003204 <__muldf3+0x300>
 4003268:	01004004 	movi	r4,256
 400326c:	4904703a 	and	r2,r9,r4
 4003270:	10c4b03a 	or	r2,r2,r3
 4003274:	103fe31e 	bne	r2,zero,4003204 <__muldf3+0x300>
 4003278:	94c4b03a 	or	r2,r18,r19
 400327c:	103fe126 	beq	r2,zero,4003204 <__muldf3+0x300>
 4003280:	49c5883a 	add	r2,r9,r7
 4003284:	1251803a 	cmpltu	r8,r2,r9
 4003288:	4291883a 	add	r8,r8,r10
 400328c:	013fc004 	movi	r4,-256
 4003290:	1112703a 	and	r9,r2,r4
 4003294:	4015883a 	mov	r10,r8
 4003298:	003fda06 	br	4003204 <__muldf3+0x300>
 400329c:	6813883a 	mov	r9,r13
 40032a0:	003fce06 	br	40031dc <__muldf3+0x2d8>
 40032a4:	143f7c36 	bltu	r2,r16,4003098 <__muldf3+0x194>
 40032a8:	003fdd06 	br	4003220 <__muldf3+0x31c>
 40032ac:	12bf852e 	bgeu	r2,r10,40030c4 <__muldf3+0x1c0>
 40032b0:	003fe506 	br	4003248 <__muldf3+0x344>
 40032b4:	00800084 	movi	r2,2
 40032b8:	20bf351e 	bne	r4,r2,4002f90 <__muldf3+0x8c>
 40032bc:	01010034 	movhi	r4,1024
 40032c0:	211f1904 	addi	r4,r4,31844
 40032c4:	003f3f06 	br	4002fc4 <__muldf3+0xc0>

040032c8 <__divdf3>:
 40032c8:	deffed04 	addi	sp,sp,-76
 40032cc:	dcc01115 	stw	r19,68(sp)
 40032d0:	dcc00404 	addi	r19,sp,16
 40032d4:	2011883a 	mov	r8,r4
 40032d8:	2813883a 	mov	r9,r5
 40032dc:	dc000e15 	stw	r16,56(sp)
 40032e0:	d809883a 	mov	r4,sp
 40032e4:	980b883a 	mov	r5,r19
 40032e8:	dc000904 	addi	r16,sp,36
 40032ec:	dfc01215 	stw	ra,72(sp)
 40032f0:	da400115 	stw	r9,4(sp)
 40032f4:	d9c00315 	stw	r7,12(sp)
 40032f8:	da000015 	stw	r8,0(sp)
 40032fc:	d9800215 	stw	r6,8(sp)
 4003300:	dc801015 	stw	r18,64(sp)
 4003304:	dc400f15 	stw	r17,60(sp)
 4003308:	4003cb40 	call	4003cb4 <__unpack_d>
 400330c:	d9000204 	addi	r4,sp,8
 4003310:	800b883a 	mov	r5,r16
 4003314:	4003cb40 	call	4003cb4 <__unpack_d>
 4003318:	d9000417 	ldw	r4,16(sp)
 400331c:	00800044 	movi	r2,1
 4003320:	11000b2e 	bgeu	r2,r4,4003350 <__divdf3+0x88>
 4003324:	d9400917 	ldw	r5,36(sp)
 4003328:	1140762e 	bgeu	r2,r5,4003504 <__divdf3+0x23c>
 400332c:	d8800517 	ldw	r2,20(sp)
 4003330:	d8c00a17 	ldw	r3,40(sp)
 4003334:	01800104 	movi	r6,4
 4003338:	10c4f03a 	xor	r2,r2,r3
 400333c:	d8800515 	stw	r2,20(sp)
 4003340:	21800226 	beq	r4,r6,400334c <__divdf3+0x84>
 4003344:	00800084 	movi	r2,2
 4003348:	2080141e 	bne	r4,r2,400339c <__divdf3+0xd4>
 400334c:	29000926 	beq	r5,r4,4003374 <__divdf3+0xac>
 4003350:	9809883a 	mov	r4,r19
 4003354:	40039a00 	call	40039a0 <__pack_d>
 4003358:	dfc01217 	ldw	ra,72(sp)
 400335c:	dcc01117 	ldw	r19,68(sp)
 4003360:	dc801017 	ldw	r18,64(sp)
 4003364:	dc400f17 	ldw	r17,60(sp)
 4003368:	dc000e17 	ldw	r16,56(sp)
 400336c:	dec01304 	addi	sp,sp,76
 4003370:	f800283a 	ret
 4003374:	01010034 	movhi	r4,1024
 4003378:	211f1904 	addi	r4,r4,31844
 400337c:	40039a00 	call	40039a0 <__pack_d>
 4003380:	dfc01217 	ldw	ra,72(sp)
 4003384:	dcc01117 	ldw	r19,68(sp)
 4003388:	dc801017 	ldw	r18,64(sp)
 400338c:	dc400f17 	ldw	r17,60(sp)
 4003390:	dc000e17 	ldw	r16,56(sp)
 4003394:	dec01304 	addi	sp,sp,76
 4003398:	f800283a 	ret
 400339c:	29805b26 	beq	r5,r6,400350c <__divdf3+0x244>
 40033a0:	28802d26 	beq	r5,r2,4003458 <__divdf3+0x190>
 40033a4:	d8c00617 	ldw	r3,24(sp)
 40033a8:	d8800b17 	ldw	r2,44(sp)
 40033ac:	d9c00817 	ldw	r7,32(sp)
 40033b0:	dc400d17 	ldw	r17,52(sp)
 40033b4:	188bc83a 	sub	r5,r3,r2
 40033b8:	d9800717 	ldw	r6,28(sp)
 40033bc:	dc000c17 	ldw	r16,48(sp)
 40033c0:	d9400615 	stw	r5,24(sp)
 40033c4:	3c403836 	bltu	r7,r17,40034a8 <__divdf3+0x1e0>
 40033c8:	89c03626 	beq	r17,r7,40034a4 <__divdf3+0x1dc>
 40033cc:	0015883a 	mov	r10,zero
 40033d0:	001d883a 	mov	r14,zero
 40033d4:	02c40034 	movhi	r11,4096
 40033d8:	001f883a 	mov	r15,zero
 40033dc:	003f883a 	mov	ra,zero
 40033e0:	04800f44 	movi	r18,61
 40033e4:	00000f06 	br	4003424 <__divdf3+0x15c>
 40033e8:	601d883a 	mov	r14,r12
 40033ec:	681f883a 	mov	r15,r13
 40033f0:	400d883a 	mov	r6,r8
 40033f4:	100f883a 	mov	r7,r2
 40033f8:	3191883a 	add	r8,r6,r6
 40033fc:	5808d07a 	srli	r4,r11,1
 4003400:	4185803a 	cmpltu	r2,r8,r6
 4003404:	39d3883a 	add	r9,r7,r7
 4003408:	28c6b03a 	or	r3,r5,r3
 400340c:	1245883a 	add	r2,r2,r9
 4003410:	1815883a 	mov	r10,r3
 4003414:	2017883a 	mov	r11,r4
 4003418:	400d883a 	mov	r6,r8
 400341c:	100f883a 	mov	r7,r2
 4003420:	fc801726 	beq	ra,r18,4003480 <__divdf3+0x1b8>
 4003424:	580a97fa 	slli	r5,r11,31
 4003428:	5006d07a 	srli	r3,r10,1
 400342c:	ffc00044 	addi	ra,ra,1
 4003430:	3c7ff136 	bltu	r7,r17,40033f8 <__divdf3+0x130>
 4003434:	3411c83a 	sub	r8,r6,r16
 4003438:	3205803a 	cmpltu	r2,r6,r8
 400343c:	3c53c83a 	sub	r9,r7,r17
 4003440:	7298b03a 	or	r12,r14,r10
 4003444:	7adab03a 	or	r13,r15,r11
 4003448:	4885c83a 	sub	r2,r9,r2
 400344c:	89ffe61e 	bne	r17,r7,40033e8 <__divdf3+0x120>
 4003450:	343fe936 	bltu	r6,r16,40033f8 <__divdf3+0x130>
 4003454:	003fe406 	br	40033e8 <__divdf3+0x120>
 4003458:	9809883a 	mov	r4,r19
 400345c:	d9800415 	stw	r6,16(sp)
 4003460:	40039a00 	call	40039a0 <__pack_d>
 4003464:	dfc01217 	ldw	ra,72(sp)
 4003468:	dcc01117 	ldw	r19,68(sp)
 400346c:	dc801017 	ldw	r18,64(sp)
 4003470:	dc400f17 	ldw	r17,60(sp)
 4003474:	dc000e17 	ldw	r16,56(sp)
 4003478:	dec01304 	addi	sp,sp,76
 400347c:	f800283a 	ret
 4003480:	00803fc4 	movi	r2,255
 4003484:	7090703a 	and	r8,r14,r2
 4003488:	00802004 	movi	r2,128
 400348c:	0007883a 	mov	r3,zero
 4003490:	0013883a 	mov	r9,zero
 4003494:	40800d26 	beq	r8,r2,40034cc <__divdf3+0x204>
 4003498:	dbc00815 	stw	r15,32(sp)
 400349c:	db800715 	stw	r14,28(sp)
 40034a0:	003fab06 	br	4003350 <__divdf3+0x88>
 40034a4:	343fc92e 	bgeu	r6,r16,40033cc <__divdf3+0x104>
 40034a8:	3185883a 	add	r2,r6,r6
 40034ac:	1189803a 	cmpltu	r4,r2,r6
 40034b0:	39c7883a 	add	r3,r7,r7
 40034b4:	20c9883a 	add	r4,r4,r3
 40034b8:	297fffc4 	addi	r5,r5,-1
 40034bc:	100d883a 	mov	r6,r2
 40034c0:	200f883a 	mov	r7,r4
 40034c4:	d9400615 	stw	r5,24(sp)
 40034c8:	003fc006 	br	40033cc <__divdf3+0x104>
 40034cc:	483ff21e 	bne	r9,zero,4003498 <__divdf3+0x1d0>
 40034d0:	01004004 	movi	r4,256
 40034d4:	7104703a 	and	r2,r14,r4
 40034d8:	10c4b03a 	or	r2,r2,r3
 40034dc:	103fee1e 	bne	r2,zero,4003498 <__divdf3+0x1d0>
 40034e0:	31c4b03a 	or	r2,r6,r7
 40034e4:	103fec26 	beq	r2,zero,4003498 <__divdf3+0x1d0>
 40034e8:	7205883a 	add	r2,r14,r8
 40034ec:	1391803a 	cmpltu	r8,r2,r14
 40034f0:	43d1883a 	add	r8,r8,r15
 40034f4:	013fc004 	movi	r4,-256
 40034f8:	111c703a 	and	r14,r2,r4
 40034fc:	401f883a 	mov	r15,r8
 4003500:	003fe506 	br	4003498 <__divdf3+0x1d0>
 4003504:	8009883a 	mov	r4,r16
 4003508:	003f9206 	br	4003354 <__divdf3+0x8c>
 400350c:	9809883a 	mov	r4,r19
 4003510:	d8000715 	stw	zero,28(sp)
 4003514:	d8000815 	stw	zero,32(sp)
 4003518:	d8000615 	stw	zero,24(sp)
 400351c:	003f8d06 	br	4003354 <__divdf3+0x8c>

04003520 <__eqdf2>:
 4003520:	deffef04 	addi	sp,sp,-68
 4003524:	dc400f15 	stw	r17,60(sp)
 4003528:	dc400404 	addi	r17,sp,16
 400352c:	2005883a 	mov	r2,r4
 4003530:	2807883a 	mov	r3,r5
 4003534:	dc000e15 	stw	r16,56(sp)
 4003538:	d809883a 	mov	r4,sp
 400353c:	880b883a 	mov	r5,r17
 4003540:	dc000904 	addi	r16,sp,36
 4003544:	d8c00115 	stw	r3,4(sp)
 4003548:	d8800015 	stw	r2,0(sp)
 400354c:	d9800215 	stw	r6,8(sp)
 4003550:	dfc01015 	stw	ra,64(sp)
 4003554:	d9c00315 	stw	r7,12(sp)
 4003558:	4003cb40 	call	4003cb4 <__unpack_d>
 400355c:	d9000204 	addi	r4,sp,8
 4003560:	800b883a 	mov	r5,r16
 4003564:	4003cb40 	call	4003cb4 <__unpack_d>
 4003568:	d8800417 	ldw	r2,16(sp)
 400356c:	00c00044 	movi	r3,1
 4003570:	180d883a 	mov	r6,r3
 4003574:	1880062e 	bgeu	r3,r2,4003590 <__eqdf2+0x70>
 4003578:	d8800917 	ldw	r2,36(sp)
 400357c:	8809883a 	mov	r4,r17
 4003580:	800b883a 	mov	r5,r16
 4003584:	1880022e 	bgeu	r3,r2,4003590 <__eqdf2+0x70>
 4003588:	4003dec0 	call	4003dec <__fpcmp_parts_d>
 400358c:	100d883a 	mov	r6,r2
 4003590:	3005883a 	mov	r2,r6
 4003594:	dfc01017 	ldw	ra,64(sp)
 4003598:	dc400f17 	ldw	r17,60(sp)
 400359c:	dc000e17 	ldw	r16,56(sp)
 40035a0:	dec01104 	addi	sp,sp,68
 40035a4:	f800283a 	ret

040035a8 <__nedf2>:
 40035a8:	deffef04 	addi	sp,sp,-68
 40035ac:	dc400f15 	stw	r17,60(sp)
 40035b0:	dc400404 	addi	r17,sp,16
 40035b4:	2005883a 	mov	r2,r4
 40035b8:	2807883a 	mov	r3,r5
 40035bc:	dc000e15 	stw	r16,56(sp)
 40035c0:	d809883a 	mov	r4,sp
 40035c4:	880b883a 	mov	r5,r17
 40035c8:	dc000904 	addi	r16,sp,36
 40035cc:	d8c00115 	stw	r3,4(sp)
 40035d0:	d8800015 	stw	r2,0(sp)
 40035d4:	d9800215 	stw	r6,8(sp)
 40035d8:	dfc01015 	stw	ra,64(sp)
 40035dc:	d9c00315 	stw	r7,12(sp)
 40035e0:	4003cb40 	call	4003cb4 <__unpack_d>
 40035e4:	d9000204 	addi	r4,sp,8
 40035e8:	800b883a 	mov	r5,r16
 40035ec:	4003cb40 	call	4003cb4 <__unpack_d>
 40035f0:	d8800417 	ldw	r2,16(sp)
 40035f4:	00c00044 	movi	r3,1
 40035f8:	180d883a 	mov	r6,r3
 40035fc:	1880062e 	bgeu	r3,r2,4003618 <__nedf2+0x70>
 4003600:	d8800917 	ldw	r2,36(sp)
 4003604:	8809883a 	mov	r4,r17
 4003608:	800b883a 	mov	r5,r16
 400360c:	1880022e 	bgeu	r3,r2,4003618 <__nedf2+0x70>
 4003610:	4003dec0 	call	4003dec <__fpcmp_parts_d>
 4003614:	100d883a 	mov	r6,r2
 4003618:	3005883a 	mov	r2,r6
 400361c:	dfc01017 	ldw	ra,64(sp)
 4003620:	dc400f17 	ldw	r17,60(sp)
 4003624:	dc000e17 	ldw	r16,56(sp)
 4003628:	dec01104 	addi	sp,sp,68
 400362c:	f800283a 	ret

04003630 <__gedf2>:
 4003630:	deffef04 	addi	sp,sp,-68
 4003634:	dc400f15 	stw	r17,60(sp)
 4003638:	dc400404 	addi	r17,sp,16
 400363c:	2005883a 	mov	r2,r4
 4003640:	2807883a 	mov	r3,r5
 4003644:	dc000e15 	stw	r16,56(sp)
 4003648:	d809883a 	mov	r4,sp
 400364c:	880b883a 	mov	r5,r17
 4003650:	dc000904 	addi	r16,sp,36
 4003654:	d8c00115 	stw	r3,4(sp)
 4003658:	d8800015 	stw	r2,0(sp)
 400365c:	d9800215 	stw	r6,8(sp)
 4003660:	dfc01015 	stw	ra,64(sp)
 4003664:	d9c00315 	stw	r7,12(sp)
 4003668:	4003cb40 	call	4003cb4 <__unpack_d>
 400366c:	d9000204 	addi	r4,sp,8
 4003670:	800b883a 	mov	r5,r16
 4003674:	4003cb40 	call	4003cb4 <__unpack_d>
 4003678:	d8800417 	ldw	r2,16(sp)
 400367c:	00c00044 	movi	r3,1
 4003680:	01bfffc4 	movi	r6,-1
 4003684:	1880062e 	bgeu	r3,r2,40036a0 <__gedf2+0x70>
 4003688:	d8800917 	ldw	r2,36(sp)
 400368c:	8809883a 	mov	r4,r17
 4003690:	800b883a 	mov	r5,r16
 4003694:	1880022e 	bgeu	r3,r2,40036a0 <__gedf2+0x70>
 4003698:	4003dec0 	call	4003dec <__fpcmp_parts_d>
 400369c:	100d883a 	mov	r6,r2
 40036a0:	3005883a 	mov	r2,r6
 40036a4:	dfc01017 	ldw	ra,64(sp)
 40036a8:	dc400f17 	ldw	r17,60(sp)
 40036ac:	dc000e17 	ldw	r16,56(sp)
 40036b0:	dec01104 	addi	sp,sp,68
 40036b4:	f800283a 	ret

040036b8 <__floatsidf>:
 40036b8:	2006d7fa 	srli	r3,r4,31
 40036bc:	defff604 	addi	sp,sp,-40
 40036c0:	008000c4 	movi	r2,3
 40036c4:	dfc00915 	stw	ra,36(sp)
 40036c8:	dcc00815 	stw	r19,32(sp)
 40036cc:	dc800715 	stw	r18,28(sp)
 40036d0:	dc400615 	stw	r17,24(sp)
 40036d4:	dc000515 	stw	r16,20(sp)
 40036d8:	d8800015 	stw	r2,0(sp)
 40036dc:	d8c00115 	stw	r3,4(sp)
 40036e0:	20000f1e 	bne	r4,zero,4003720 <__floatsidf+0x68>
 40036e4:	00800084 	movi	r2,2
 40036e8:	d8800015 	stw	r2,0(sp)
 40036ec:	d809883a 	mov	r4,sp
 40036f0:	40039a00 	call	40039a0 <__pack_d>
 40036f4:	1009883a 	mov	r4,r2
 40036f8:	180b883a 	mov	r5,r3
 40036fc:	2005883a 	mov	r2,r4
 4003700:	2807883a 	mov	r3,r5
 4003704:	dfc00917 	ldw	ra,36(sp)
 4003708:	dcc00817 	ldw	r19,32(sp)
 400370c:	dc800717 	ldw	r18,28(sp)
 4003710:	dc400617 	ldw	r17,24(sp)
 4003714:	dc000517 	ldw	r16,20(sp)
 4003718:	dec00a04 	addi	sp,sp,40
 400371c:	f800283a 	ret
 4003720:	00800f04 	movi	r2,60
 4003724:	1807003a 	cmpeq	r3,r3,zero
 4003728:	d8800215 	stw	r2,8(sp)
 400372c:	18001126 	beq	r3,zero,4003774 <__floatsidf+0xbc>
 4003730:	0027883a 	mov	r19,zero
 4003734:	2025883a 	mov	r18,r4
 4003738:	d9000315 	stw	r4,12(sp)
 400373c:	dcc00415 	stw	r19,16(sp)
 4003740:	40039200 	call	4003920 <__clzsi2>
 4003744:	11000744 	addi	r4,r2,29
 4003748:	013fe80e 	bge	zero,r4,40036ec <__floatsidf+0x34>
 400374c:	10bfff44 	addi	r2,r2,-3
 4003750:	10000c16 	blt	r2,zero,4003784 <__floatsidf+0xcc>
 4003754:	90a2983a 	sll	r17,r18,r2
 4003758:	0021883a 	mov	r16,zero
 400375c:	d8800217 	ldw	r2,8(sp)
 4003760:	dc400415 	stw	r17,16(sp)
 4003764:	dc000315 	stw	r16,12(sp)
 4003768:	1105c83a 	sub	r2,r2,r4
 400376c:	d8800215 	stw	r2,8(sp)
 4003770:	003fde06 	br	40036ec <__floatsidf+0x34>
 4003774:	00a00034 	movhi	r2,32768
 4003778:	20800a26 	beq	r4,r2,40037a4 <__floatsidf+0xec>
 400377c:	0109c83a 	sub	r4,zero,r4
 4003780:	003feb06 	br	4003730 <__floatsidf+0x78>
 4003784:	9006d07a 	srli	r3,r18,1
 4003788:	008007c4 	movi	r2,31
 400378c:	1105c83a 	sub	r2,r2,r4
 4003790:	1886d83a 	srl	r3,r3,r2
 4003794:	9922983a 	sll	r17,r19,r4
 4003798:	9120983a 	sll	r16,r18,r4
 400379c:	1c62b03a 	or	r17,r3,r17
 40037a0:	003fee06 	br	400375c <__floatsidf+0xa4>
 40037a4:	0009883a 	mov	r4,zero
 40037a8:	01707834 	movhi	r5,49632
 40037ac:	003fd306 	br	40036fc <__floatsidf+0x44>

040037b0 <__fixdfsi>:
 40037b0:	defff804 	addi	sp,sp,-32
 40037b4:	2005883a 	mov	r2,r4
 40037b8:	2807883a 	mov	r3,r5
 40037bc:	d809883a 	mov	r4,sp
 40037c0:	d9400204 	addi	r5,sp,8
 40037c4:	d8c00115 	stw	r3,4(sp)
 40037c8:	d8800015 	stw	r2,0(sp)
 40037cc:	dfc00715 	stw	ra,28(sp)
 40037d0:	4003cb40 	call	4003cb4 <__unpack_d>
 40037d4:	d8c00217 	ldw	r3,8(sp)
 40037d8:	00800084 	movi	r2,2
 40037dc:	1880051e 	bne	r3,r2,40037f4 <__fixdfsi+0x44>
 40037e0:	0007883a 	mov	r3,zero
 40037e4:	1805883a 	mov	r2,r3
 40037e8:	dfc00717 	ldw	ra,28(sp)
 40037ec:	dec00804 	addi	sp,sp,32
 40037f0:	f800283a 	ret
 40037f4:	00800044 	movi	r2,1
 40037f8:	10fff92e 	bgeu	r2,r3,40037e0 <__fixdfsi+0x30>
 40037fc:	00800104 	movi	r2,4
 4003800:	18800426 	beq	r3,r2,4003814 <__fixdfsi+0x64>
 4003804:	d8c00417 	ldw	r3,16(sp)
 4003808:	183ff516 	blt	r3,zero,40037e0 <__fixdfsi+0x30>
 400380c:	00800784 	movi	r2,30
 4003810:	10c0080e 	bge	r2,r3,4003834 <__fixdfsi+0x84>
 4003814:	d8800317 	ldw	r2,12(sp)
 4003818:	1000121e 	bne	r2,zero,4003864 <__fixdfsi+0xb4>
 400381c:	00e00034 	movhi	r3,32768
 4003820:	18ffffc4 	addi	r3,r3,-1
 4003824:	1805883a 	mov	r2,r3
 4003828:	dfc00717 	ldw	ra,28(sp)
 400382c:	dec00804 	addi	sp,sp,32
 4003830:	f800283a 	ret
 4003834:	00800f04 	movi	r2,60
 4003838:	10d1c83a 	sub	r8,r2,r3
 400383c:	40bff804 	addi	r2,r8,-32
 4003840:	d9800517 	ldw	r6,20(sp)
 4003844:	d9c00617 	ldw	r7,24(sp)
 4003848:	10000816 	blt	r2,zero,400386c <__fixdfsi+0xbc>
 400384c:	3888d83a 	srl	r4,r7,r2
 4003850:	d8800317 	ldw	r2,12(sp)
 4003854:	2007883a 	mov	r3,r4
 4003858:	103fe226 	beq	r2,zero,40037e4 <__fixdfsi+0x34>
 400385c:	0107c83a 	sub	r3,zero,r4
 4003860:	003fe006 	br	40037e4 <__fixdfsi+0x34>
 4003864:	00e00034 	movhi	r3,32768
 4003868:	003fde06 	br	40037e4 <__fixdfsi+0x34>
 400386c:	39c7883a 	add	r3,r7,r7
 4003870:	008007c4 	movi	r2,31
 4003874:	1205c83a 	sub	r2,r2,r8
 4003878:	1886983a 	sll	r3,r3,r2
 400387c:	3208d83a 	srl	r4,r6,r8
 4003880:	1908b03a 	or	r4,r3,r4
 4003884:	003ff206 	br	4003850 <__fixdfsi+0xa0>

04003888 <__muldi3>:
 4003888:	2011883a 	mov	r8,r4
 400388c:	427fffcc 	andi	r9,r8,65535
 4003890:	4018d43a 	srli	r12,r8,16
 4003894:	32bfffcc 	andi	r10,r6,65535
 4003898:	3016d43a 	srli	r11,r6,16
 400389c:	4a85383a 	mul	r2,r9,r10
 40038a0:	6295383a 	mul	r10,r12,r10
 40038a4:	4ad3383a 	mul	r9,r9,r11
 40038a8:	113fffcc 	andi	r4,r2,65535
 40038ac:	1004d43a 	srli	r2,r2,16
 40038b0:	4a93883a 	add	r9,r9,r10
 40038b4:	3807883a 	mov	r3,r7
 40038b8:	1245883a 	add	r2,r2,r9
 40038bc:	280f883a 	mov	r7,r5
 40038c0:	180b883a 	mov	r5,r3
 40038c4:	1006943a 	slli	r3,r2,16
 40038c8:	defffd04 	addi	sp,sp,-12
 40038cc:	dc800215 	stw	r18,8(sp)
 40038d0:	1907883a 	add	r3,r3,r4
 40038d4:	dc400115 	stw	r17,4(sp)
 40038d8:	dc000015 	stw	r16,0(sp)
 40038dc:	4165383a 	mul	r18,r8,r5
 40038e0:	31e3383a 	mul	r17,r6,r7
 40038e4:	1012d43a 	srli	r9,r2,16
 40038e8:	62d9383a 	mul	r12,r12,r11
 40038ec:	181f883a 	mov	r15,r3
 40038f0:	1280022e 	bgeu	r2,r10,40038fc <__muldi3+0x74>
 40038f4:	00800074 	movhi	r2,1
 40038f8:	6099883a 	add	r12,r12,r2
 40038fc:	624d883a 	add	r6,r12,r9
 4003900:	9187883a 	add	r3,r18,r6
 4003904:	88c7883a 	add	r3,r17,r3
 4003908:	7805883a 	mov	r2,r15
 400390c:	dc800217 	ldw	r18,8(sp)
 4003910:	dc400117 	ldw	r17,4(sp)
 4003914:	dc000017 	ldw	r16,0(sp)
 4003918:	dec00304 	addi	sp,sp,12
 400391c:	f800283a 	ret

04003920 <__clzsi2>:
 4003920:	00bfffd4 	movui	r2,65535
 4003924:	11000e36 	bltu	r2,r4,4003960 <__clzsi2+0x40>
 4003928:	00803fc4 	movi	r2,255
 400392c:	01400204 	movi	r5,8
 4003930:	0007883a 	mov	r3,zero
 4003934:	11001036 	bltu	r2,r4,4003978 <__clzsi2+0x58>
 4003938:	000b883a 	mov	r5,zero
 400393c:	20c6d83a 	srl	r3,r4,r3
 4003940:	00810034 	movhi	r2,1024
 4003944:	109f1e04 	addi	r2,r2,31864
 4003948:	1887883a 	add	r3,r3,r2
 400394c:	18800003 	ldbu	r2,0(r3)
 4003950:	00c00804 	movi	r3,32
 4003954:	2885883a 	add	r2,r5,r2
 4003958:	1885c83a 	sub	r2,r3,r2
 400395c:	f800283a 	ret
 4003960:	01400404 	movi	r5,16
 4003964:	00804034 	movhi	r2,256
 4003968:	10bfffc4 	addi	r2,r2,-1
 400396c:	2807883a 	mov	r3,r5
 4003970:	113ff22e 	bgeu	r2,r4,400393c <__clzsi2+0x1c>
 4003974:	01400604 	movi	r5,24
 4003978:	2807883a 	mov	r3,r5
 400397c:	20c6d83a 	srl	r3,r4,r3
 4003980:	00810034 	movhi	r2,1024
 4003984:	109f1e04 	addi	r2,r2,31864
 4003988:	1887883a 	add	r3,r3,r2
 400398c:	18800003 	ldbu	r2,0(r3)
 4003990:	00c00804 	movi	r3,32
 4003994:	2885883a 	add	r2,r5,r2
 4003998:	1885c83a 	sub	r2,r3,r2
 400399c:	f800283a 	ret

040039a0 <__pack_d>:
 40039a0:	20c00017 	ldw	r3,0(r4)
 40039a4:	defffd04 	addi	sp,sp,-12
 40039a8:	dc000015 	stw	r16,0(sp)
 40039ac:	dc800215 	stw	r18,8(sp)
 40039b0:	dc400115 	stw	r17,4(sp)
 40039b4:	00800044 	movi	r2,1
 40039b8:	22000317 	ldw	r8,12(r4)
 40039bc:	001f883a 	mov	r15,zero
 40039c0:	22400417 	ldw	r9,16(r4)
 40039c4:	24000117 	ldw	r16,4(r4)
 40039c8:	10c0552e 	bgeu	r2,r3,4003b20 <__pack_d+0x180>
 40039cc:	00800104 	movi	r2,4
 40039d0:	18804f26 	beq	r3,r2,4003b10 <__pack_d+0x170>
 40039d4:	00800084 	movi	r2,2
 40039d8:	18800226 	beq	r3,r2,40039e4 <__pack_d+0x44>
 40039dc:	4244b03a 	or	r2,r8,r9
 40039e0:	10001a1e 	bne	r2,zero,4003a4c <__pack_d+0xac>
 40039e4:	000d883a 	mov	r6,zero
 40039e8:	000f883a 	mov	r7,zero
 40039ec:	0011883a 	mov	r8,zero
 40039f0:	00800434 	movhi	r2,16
 40039f4:	10bfffc4 	addi	r2,r2,-1
 40039f8:	301d883a 	mov	r14,r6
 40039fc:	3884703a 	and	r2,r7,r2
 4003a00:	400a953a 	slli	r5,r8,20
 4003a04:	79bffc2c 	andhi	r6,r15,65520
 4003a08:	308cb03a 	or	r6,r6,r2
 4003a0c:	00e00434 	movhi	r3,32784
 4003a10:	18ffffc4 	addi	r3,r3,-1
 4003a14:	800497fa 	slli	r2,r16,31
 4003a18:	30c6703a 	and	r3,r6,r3
 4003a1c:	1946b03a 	or	r3,r3,r5
 4003a20:	01600034 	movhi	r5,32768
 4003a24:	297fffc4 	addi	r5,r5,-1
 4003a28:	194a703a 	and	r5,r3,r5
 4003a2c:	288ab03a 	or	r5,r5,r2
 4003a30:	2807883a 	mov	r3,r5
 4003a34:	7005883a 	mov	r2,r14
 4003a38:	dc800217 	ldw	r18,8(sp)
 4003a3c:	dc400117 	ldw	r17,4(sp)
 4003a40:	dc000017 	ldw	r16,0(sp)
 4003a44:	dec00304 	addi	sp,sp,12
 4003a48:	f800283a 	ret
 4003a4c:	21000217 	ldw	r4,8(r4)
 4003a50:	00bf0084 	movi	r2,-1022
 4003a54:	20803f16 	blt	r4,r2,4003b54 <__pack_d+0x1b4>
 4003a58:	0080ffc4 	movi	r2,1023
 4003a5c:	11002c16 	blt	r2,r4,4003b10 <__pack_d+0x170>
 4003a60:	00803fc4 	movi	r2,255
 4003a64:	408c703a 	and	r6,r8,r2
 4003a68:	00802004 	movi	r2,128
 4003a6c:	0007883a 	mov	r3,zero
 4003a70:	000f883a 	mov	r7,zero
 4003a74:	2280ffc4 	addi	r10,r4,1023
 4003a78:	30801e26 	beq	r6,r2,4003af4 <__pack_d+0x154>
 4003a7c:	00801fc4 	movi	r2,127
 4003a80:	4089883a 	add	r4,r8,r2
 4003a84:	220d803a 	cmpltu	r6,r4,r8
 4003a88:	324d883a 	add	r6,r6,r9
 4003a8c:	2011883a 	mov	r8,r4
 4003a90:	3013883a 	mov	r9,r6
 4003a94:	00880034 	movhi	r2,8192
 4003a98:	10bfffc4 	addi	r2,r2,-1
 4003a9c:	12400d36 	bltu	r2,r9,4003ad4 <__pack_d+0x134>
 4003aa0:	4804963a 	slli	r2,r9,24
 4003aa4:	400cd23a 	srli	r6,r8,8
 4003aa8:	480ed23a 	srli	r7,r9,8
 4003aac:	013fffc4 	movi	r4,-1
 4003ab0:	118cb03a 	or	r6,r2,r6
 4003ab4:	01400434 	movhi	r5,16
 4003ab8:	297fffc4 	addi	r5,r5,-1
 4003abc:	3104703a 	and	r2,r6,r4
 4003ac0:	3946703a 	and	r3,r7,r5
 4003ac4:	5201ffcc 	andi	r8,r10,2047
 4003ac8:	100d883a 	mov	r6,r2
 4003acc:	180f883a 	mov	r7,r3
 4003ad0:	003fc706 	br	40039f0 <__pack_d+0x50>
 4003ad4:	480897fa 	slli	r4,r9,31
 4003ad8:	4004d07a 	srli	r2,r8,1
 4003adc:	4806d07a 	srli	r3,r9,1
 4003ae0:	52800044 	addi	r10,r10,1
 4003ae4:	2084b03a 	or	r2,r4,r2
 4003ae8:	1011883a 	mov	r8,r2
 4003aec:	1813883a 	mov	r9,r3
 4003af0:	003feb06 	br	4003aa0 <__pack_d+0x100>
 4003af4:	383fe11e 	bne	r7,zero,4003a7c <__pack_d+0xdc>
 4003af8:	01004004 	movi	r4,256
 4003afc:	4104703a 	and	r2,r8,r4
 4003b00:	10c4b03a 	or	r2,r2,r3
 4003b04:	103fe326 	beq	r2,zero,4003a94 <__pack_d+0xf4>
 4003b08:	3005883a 	mov	r2,r6
 4003b0c:	003fdc06 	br	4003a80 <__pack_d+0xe0>
 4003b10:	000d883a 	mov	r6,zero
 4003b14:	000f883a 	mov	r7,zero
 4003b18:	0201ffc4 	movi	r8,2047
 4003b1c:	003fb406 	br	40039f0 <__pack_d+0x50>
 4003b20:	0005883a 	mov	r2,zero
 4003b24:	00c00234 	movhi	r3,8
 4003b28:	408cb03a 	or	r6,r8,r2
 4003b2c:	48ceb03a 	or	r7,r9,r3
 4003b30:	013fffc4 	movi	r4,-1
 4003b34:	01400434 	movhi	r5,16
 4003b38:	297fffc4 	addi	r5,r5,-1
 4003b3c:	3104703a 	and	r2,r6,r4
 4003b40:	3946703a 	and	r3,r7,r5
 4003b44:	100d883a 	mov	r6,r2
 4003b48:	180f883a 	mov	r7,r3
 4003b4c:	0201ffc4 	movi	r8,2047
 4003b50:	003fa706 	br	40039f0 <__pack_d+0x50>
 4003b54:	1109c83a 	sub	r4,r2,r4
 4003b58:	00800e04 	movi	r2,56
 4003b5c:	11004316 	blt	r2,r4,4003c6c <__pack_d+0x2cc>
 4003b60:	21fff804 	addi	r7,r4,-32
 4003b64:	38004516 	blt	r7,zero,4003c7c <__pack_d+0x2dc>
 4003b68:	49d8d83a 	srl	r12,r9,r7
 4003b6c:	001b883a 	mov	r13,zero
 4003b70:	0023883a 	mov	r17,zero
 4003b74:	01400044 	movi	r5,1
 4003b78:	0025883a 	mov	r18,zero
 4003b7c:	38004716 	blt	r7,zero,4003c9c <__pack_d+0x2fc>
 4003b80:	29d6983a 	sll	r11,r5,r7
 4003b84:	0015883a 	mov	r10,zero
 4003b88:	00bfffc4 	movi	r2,-1
 4003b8c:	5089883a 	add	r4,r10,r2
 4003b90:	588b883a 	add	r5,r11,r2
 4003b94:	228d803a 	cmpltu	r6,r4,r10
 4003b98:	314b883a 	add	r5,r6,r5
 4003b9c:	4104703a 	and	r2,r8,r4
 4003ba0:	4946703a 	and	r3,r9,r5
 4003ba4:	10c4b03a 	or	r2,r2,r3
 4003ba8:	10000226 	beq	r2,zero,4003bb4 <__pack_d+0x214>
 4003bac:	04400044 	movi	r17,1
 4003bb0:	0025883a 	mov	r18,zero
 4003bb4:	00803fc4 	movi	r2,255
 4003bb8:	644eb03a 	or	r7,r12,r17
 4003bbc:	3892703a 	and	r9,r7,r2
 4003bc0:	00802004 	movi	r2,128
 4003bc4:	6c90b03a 	or	r8,r13,r18
 4003bc8:	0015883a 	mov	r10,zero
 4003bcc:	48801626 	beq	r9,r2,4003c28 <__pack_d+0x288>
 4003bd0:	01001fc4 	movi	r4,127
 4003bd4:	3905883a 	add	r2,r7,r4
 4003bd8:	11cd803a 	cmpltu	r6,r2,r7
 4003bdc:	320d883a 	add	r6,r6,r8
 4003be0:	100f883a 	mov	r7,r2
 4003be4:	00840034 	movhi	r2,4096
 4003be8:	10bfffc4 	addi	r2,r2,-1
 4003bec:	3011883a 	mov	r8,r6
 4003bf0:	0007883a 	mov	r3,zero
 4003bf4:	11801b36 	bltu	r2,r6,4003c64 <__pack_d+0x2c4>
 4003bf8:	4004963a 	slli	r2,r8,24
 4003bfc:	3808d23a 	srli	r4,r7,8
 4003c00:	400ad23a 	srli	r5,r8,8
 4003c04:	1813883a 	mov	r9,r3
 4003c08:	1108b03a 	or	r4,r2,r4
 4003c0c:	00bfffc4 	movi	r2,-1
 4003c10:	00c00434 	movhi	r3,16
 4003c14:	18ffffc4 	addi	r3,r3,-1
 4003c18:	208c703a 	and	r6,r4,r2
 4003c1c:	28ce703a 	and	r7,r5,r3
 4003c20:	4a01ffcc 	andi	r8,r9,2047
 4003c24:	003f7206 	br	40039f0 <__pack_d+0x50>
 4003c28:	503fe91e 	bne	r10,zero,4003bd0 <__pack_d+0x230>
 4003c2c:	01004004 	movi	r4,256
 4003c30:	3904703a 	and	r2,r7,r4
 4003c34:	0007883a 	mov	r3,zero
 4003c38:	10c4b03a 	or	r2,r2,r3
 4003c3c:	10000626 	beq	r2,zero,4003c58 <__pack_d+0x2b8>
 4003c40:	3a45883a 	add	r2,r7,r9
 4003c44:	11cd803a 	cmpltu	r6,r2,r7
 4003c48:	320d883a 	add	r6,r6,r8
 4003c4c:	100f883a 	mov	r7,r2
 4003c50:	3011883a 	mov	r8,r6
 4003c54:	0007883a 	mov	r3,zero
 4003c58:	00840034 	movhi	r2,4096
 4003c5c:	10bfffc4 	addi	r2,r2,-1
 4003c60:	123fe52e 	bgeu	r2,r8,4003bf8 <__pack_d+0x258>
 4003c64:	00c00044 	movi	r3,1
 4003c68:	003fe306 	br	4003bf8 <__pack_d+0x258>
 4003c6c:	0009883a 	mov	r4,zero
 4003c70:	0013883a 	mov	r9,zero
 4003c74:	000b883a 	mov	r5,zero
 4003c78:	003fe406 	br	4003c0c <__pack_d+0x26c>
 4003c7c:	4a47883a 	add	r3,r9,r9
 4003c80:	008007c4 	movi	r2,31
 4003c84:	1105c83a 	sub	r2,r2,r4
 4003c88:	1886983a 	sll	r3,r3,r2
 4003c8c:	4118d83a 	srl	r12,r8,r4
 4003c90:	491ad83a 	srl	r13,r9,r4
 4003c94:	1b18b03a 	or	r12,r3,r12
 4003c98:	003fb506 	br	4003b70 <__pack_d+0x1d0>
 4003c9c:	2806d07a 	srli	r3,r5,1
 4003ca0:	008007c4 	movi	r2,31
 4003ca4:	1105c83a 	sub	r2,r2,r4
 4003ca8:	1896d83a 	srl	r11,r3,r2
 4003cac:	2914983a 	sll	r10,r5,r4
 4003cb0:	003fb506 	br	4003b88 <__pack_d+0x1e8>

04003cb4 <__unpack_d>:
 4003cb4:	20c00117 	ldw	r3,4(r4)
 4003cb8:	22400017 	ldw	r9,0(r4)
 4003cbc:	00800434 	movhi	r2,16
 4003cc0:	10bfffc4 	addi	r2,r2,-1
 4003cc4:	1808d53a 	srli	r4,r3,20
 4003cc8:	180cd7fa 	srli	r6,r3,31
 4003ccc:	1894703a 	and	r10,r3,r2
 4003cd0:	2201ffcc 	andi	r8,r4,2047
 4003cd4:	281b883a 	mov	r13,r5
 4003cd8:	4817883a 	mov	r11,r9
 4003cdc:	29800115 	stw	r6,4(r5)
 4003ce0:	5019883a 	mov	r12,r10
 4003ce4:	40001e1e 	bne	r8,zero,4003d60 <__unpack_d+0xac>
 4003ce8:	4a84b03a 	or	r2,r9,r10
 4003cec:	10001926 	beq	r2,zero,4003d54 <__unpack_d+0xa0>
 4003cf0:	4804d63a 	srli	r2,r9,24
 4003cf4:	500c923a 	slli	r6,r10,8
 4003cf8:	013f0084 	movi	r4,-1022
 4003cfc:	00c40034 	movhi	r3,4096
 4003d00:	18ffffc4 	addi	r3,r3,-1
 4003d04:	118cb03a 	or	r6,r2,r6
 4003d08:	008000c4 	movi	r2,3
 4003d0c:	480a923a 	slli	r5,r9,8
 4003d10:	68800015 	stw	r2,0(r13)
 4003d14:	69000215 	stw	r4,8(r13)
 4003d18:	19800b36 	bltu	r3,r6,4003d48 <__unpack_d+0x94>
 4003d1c:	200f883a 	mov	r7,r4
 4003d20:	1811883a 	mov	r8,r3
 4003d24:	2945883a 	add	r2,r5,r5
 4003d28:	1149803a 	cmpltu	r4,r2,r5
 4003d2c:	3187883a 	add	r3,r6,r6
 4003d30:	20c9883a 	add	r4,r4,r3
 4003d34:	100b883a 	mov	r5,r2
 4003d38:	200d883a 	mov	r6,r4
 4003d3c:	39ffffc4 	addi	r7,r7,-1
 4003d40:	413ff82e 	bgeu	r8,r4,4003d24 <__unpack_d+0x70>
 4003d44:	69c00215 	stw	r7,8(r13)
 4003d48:	69800415 	stw	r6,16(r13)
 4003d4c:	69400315 	stw	r5,12(r13)
 4003d50:	f800283a 	ret
 4003d54:	00800084 	movi	r2,2
 4003d58:	28800015 	stw	r2,0(r5)
 4003d5c:	f800283a 	ret
 4003d60:	0081ffc4 	movi	r2,2047
 4003d64:	40800f26 	beq	r8,r2,4003da4 <__unpack_d+0xf0>
 4003d68:	480cd63a 	srli	r6,r9,24
 4003d6c:	5006923a 	slli	r3,r10,8
 4003d70:	4804923a 	slli	r2,r9,8
 4003d74:	0009883a 	mov	r4,zero
 4003d78:	30c6b03a 	or	r3,r6,r3
 4003d7c:	01440034 	movhi	r5,4096
 4003d80:	110cb03a 	or	r6,r2,r4
 4003d84:	423f0044 	addi	r8,r8,-1023
 4003d88:	194eb03a 	or	r7,r3,r5
 4003d8c:	008000c4 	movi	r2,3
 4003d90:	69c00415 	stw	r7,16(r13)
 4003d94:	6a000215 	stw	r8,8(r13)
 4003d98:	68800015 	stw	r2,0(r13)
 4003d9c:	69800315 	stw	r6,12(r13)
 4003da0:	f800283a 	ret
 4003da4:	4a84b03a 	or	r2,r9,r10
 4003da8:	1000031e 	bne	r2,zero,4003db8 <__unpack_d+0x104>
 4003dac:	00800104 	movi	r2,4
 4003db0:	28800015 	stw	r2,0(r5)
 4003db4:	f800283a 	ret
 4003db8:	0009883a 	mov	r4,zero
 4003dbc:	01400234 	movhi	r5,8
 4003dc0:	4904703a 	and	r2,r9,r4
 4003dc4:	5146703a 	and	r3,r10,r5
 4003dc8:	10c4b03a 	or	r2,r2,r3
 4003dcc:	10000526 	beq	r2,zero,4003de4 <__unpack_d+0x130>
 4003dd0:	00800044 	movi	r2,1
 4003dd4:	68800015 	stw	r2,0(r13)
 4003dd8:	6b000415 	stw	r12,16(r13)
 4003ddc:	6ac00315 	stw	r11,12(r13)
 4003de0:	f800283a 	ret
 4003de4:	68000015 	stw	zero,0(r13)
 4003de8:	003ffb06 	br	4003dd8 <__unpack_d+0x124>

04003dec <__fpcmp_parts_d>:
 4003dec:	21800017 	ldw	r6,0(r4)
 4003df0:	00c00044 	movi	r3,1
 4003df4:	19800a2e 	bgeu	r3,r6,4003e20 <__fpcmp_parts_d+0x34>
 4003df8:	28800017 	ldw	r2,0(r5)
 4003dfc:	1880082e 	bgeu	r3,r2,4003e20 <__fpcmp_parts_d+0x34>
 4003e00:	00c00104 	movi	r3,4
 4003e04:	30c02626 	beq	r6,r3,4003ea0 <__fpcmp_parts_d+0xb4>
 4003e08:	10c02226 	beq	r2,r3,4003e94 <__fpcmp_parts_d+0xa8>
 4003e0c:	00c00084 	movi	r3,2
 4003e10:	30c00526 	beq	r6,r3,4003e28 <__fpcmp_parts_d+0x3c>
 4003e14:	10c0071e 	bne	r2,r3,4003e34 <__fpcmp_parts_d+0x48>
 4003e18:	20800117 	ldw	r2,4(r4)
 4003e1c:	1000091e 	bne	r2,zero,4003e44 <__fpcmp_parts_d+0x58>
 4003e20:	00800044 	movi	r2,1
 4003e24:	f800283a 	ret
 4003e28:	10c01a1e 	bne	r2,r3,4003e94 <__fpcmp_parts_d+0xa8>
 4003e2c:	0005883a 	mov	r2,zero
 4003e30:	f800283a 	ret
 4003e34:	22000117 	ldw	r8,4(r4)
 4003e38:	28800117 	ldw	r2,4(r5)
 4003e3c:	40800326 	beq	r8,r2,4003e4c <__fpcmp_parts_d+0x60>
 4003e40:	403ff726 	beq	r8,zero,4003e20 <__fpcmp_parts_d+0x34>
 4003e44:	00bfffc4 	movi	r2,-1
 4003e48:	f800283a 	ret
 4003e4c:	20c00217 	ldw	r3,8(r4)
 4003e50:	28800217 	ldw	r2,8(r5)
 4003e54:	10fffa16 	blt	r2,r3,4003e40 <__fpcmp_parts_d+0x54>
 4003e58:	18800916 	blt	r3,r2,4003e80 <__fpcmp_parts_d+0x94>
 4003e5c:	21c00417 	ldw	r7,16(r4)
 4003e60:	28c00417 	ldw	r3,16(r5)
 4003e64:	21800317 	ldw	r6,12(r4)
 4003e68:	28800317 	ldw	r2,12(r5)
 4003e6c:	19fff436 	bltu	r3,r7,4003e40 <__fpcmp_parts_d+0x54>
 4003e70:	38c00526 	beq	r7,r3,4003e88 <__fpcmp_parts_d+0x9c>
 4003e74:	38c00236 	bltu	r7,r3,4003e80 <__fpcmp_parts_d+0x94>
 4003e78:	19ffec1e 	bne	r3,r7,4003e2c <__fpcmp_parts_d+0x40>
 4003e7c:	30bfeb2e 	bgeu	r6,r2,4003e2c <__fpcmp_parts_d+0x40>
 4003e80:	403fe71e 	bne	r8,zero,4003e20 <__fpcmp_parts_d+0x34>
 4003e84:	003fef06 	br	4003e44 <__fpcmp_parts_d+0x58>
 4003e88:	11bffa2e 	bgeu	r2,r6,4003e74 <__fpcmp_parts_d+0x88>
 4003e8c:	403fe426 	beq	r8,zero,4003e20 <__fpcmp_parts_d+0x34>
 4003e90:	003fec06 	br	4003e44 <__fpcmp_parts_d+0x58>
 4003e94:	28800117 	ldw	r2,4(r5)
 4003e98:	103fe11e 	bne	r2,zero,4003e20 <__fpcmp_parts_d+0x34>
 4003e9c:	003fe906 	br	4003e44 <__fpcmp_parts_d+0x58>
 4003ea0:	11bfdd1e 	bne	r2,r6,4003e18 <__fpcmp_parts_d+0x2c>
 4003ea4:	28c00117 	ldw	r3,4(r5)
 4003ea8:	20800117 	ldw	r2,4(r4)
 4003eac:	1885c83a 	sub	r2,r3,r2
 4003eb0:	f800283a 	ret

04003eb4 <memcpy>:
 4003eb4:	01c003c4 	movi	r7,15
 4003eb8:	2007883a 	mov	r3,r4
 4003ebc:	3980032e 	bgeu	r7,r6,4003ecc <memcpy+0x18>
 4003ec0:	2904b03a 	or	r2,r5,r4
 4003ec4:	108000cc 	andi	r2,r2,3
 4003ec8:	10000926 	beq	r2,zero,4003ef0 <memcpy+0x3c>
 4003ecc:	30000626 	beq	r6,zero,4003ee8 <memcpy+0x34>
 4003ed0:	30cd883a 	add	r6,r6,r3
 4003ed4:	28800003 	ldbu	r2,0(r5)
 4003ed8:	29400044 	addi	r5,r5,1
 4003edc:	18800005 	stb	r2,0(r3)
 4003ee0:	18c00044 	addi	r3,r3,1
 4003ee4:	30fffb1e 	bne	r6,r3,4003ed4 <memcpy+0x20>
 4003ee8:	2005883a 	mov	r2,r4
 4003eec:	f800283a 	ret
 4003ef0:	3811883a 	mov	r8,r7
 4003ef4:	200f883a 	mov	r7,r4
 4003ef8:	28c00017 	ldw	r3,0(r5)
 4003efc:	31bffc04 	addi	r6,r6,-16
 4003f00:	38c00015 	stw	r3,0(r7)
 4003f04:	28800117 	ldw	r2,4(r5)
 4003f08:	38800115 	stw	r2,4(r7)
 4003f0c:	28c00217 	ldw	r3,8(r5)
 4003f10:	38c00215 	stw	r3,8(r7)
 4003f14:	28800317 	ldw	r2,12(r5)
 4003f18:	29400404 	addi	r5,r5,16
 4003f1c:	38800315 	stw	r2,12(r7)
 4003f20:	39c00404 	addi	r7,r7,16
 4003f24:	41bff436 	bltu	r8,r6,4003ef8 <memcpy+0x44>
 4003f28:	008000c4 	movi	r2,3
 4003f2c:	1180072e 	bgeu	r2,r6,4003f4c <memcpy+0x98>
 4003f30:	1007883a 	mov	r3,r2
 4003f34:	28800017 	ldw	r2,0(r5)
 4003f38:	31bfff04 	addi	r6,r6,-4
 4003f3c:	29400104 	addi	r5,r5,4
 4003f40:	38800015 	stw	r2,0(r7)
 4003f44:	39c00104 	addi	r7,r7,4
 4003f48:	19bffa36 	bltu	r3,r6,4003f34 <memcpy+0x80>
 4003f4c:	3807883a 	mov	r3,r7
 4003f50:	003fde06 	br	4003ecc <memcpy+0x18>

04003f54 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 4003f54:	defffd04 	addi	sp,sp,-12
 4003f58:	dfc00215 	stw	ra,8(sp)
 4003f5c:	df000115 	stw	fp,4(sp)
 4003f60:	df000104 	addi	fp,sp,4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 4003f64:	0009883a 	mov	r4,zero
 4003f68:	4003ff00 	call	4003ff0 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 4003f6c:	40040240 	call	4004024 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 4003f70:	01010034 	movhi	r4,1024
 4003f74:	211f5e04 	addi	r4,r4,32120
 4003f78:	01410034 	movhi	r5,1024
 4003f7c:	295f5e04 	addi	r5,r5,32120
 4003f80:	01810034 	movhi	r6,1024
 4003f84:	319f5e04 	addi	r6,r6,32120
 4003f88:	40068ac0 	call	40068ac <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 4003f8c:	40063840 	call	4006384 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 4003f90:	01010034 	movhi	r4,1024
 4003f94:	2118fa04 	addi	r4,r4,25576
 4003f98:	40070780 	call	4007078 <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 4003f9c:	d1201017 	ldw	r4,-32704(gp)
 4003fa0:	d1601117 	ldw	r5,-32700(gp)
 4003fa4:	d1a01217 	ldw	r6,-32696(gp)
 4003fa8:	40014980 	call	4001498 <main>
 4003fac:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 4003fb0:	01000044 	movi	r4,1
 4003fb4:	40060e80 	call	40060e8 <close>
  exit (result);
 4003fb8:	e13fff17 	ldw	r4,-4(fp)
 4003fbc:	400708c0 	call	400708c <exit>

04003fc0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 4003fc0:	defffd04 	addi	sp,sp,-12
 4003fc4:	dfc00215 	stw	ra,8(sp)
 4003fc8:	df000115 	stw	fp,4(sp)
 4003fcc:	df000104 	addi	fp,sp,4
 4003fd0:	e13fff15 	stw	r4,-4(fp)
  return alt_busy_sleep(us);
 4003fd4:	e13fff17 	ldw	r4,-4(fp)
 4003fd8:	4005f9c0 	call	4005f9c <alt_busy_sleep>
}
 4003fdc:	e037883a 	mov	sp,fp
 4003fe0:	dfc00117 	ldw	ra,4(sp)
 4003fe4:	df000017 	ldw	fp,0(sp)
 4003fe8:	dec00204 	addi	sp,sp,8
 4003fec:	f800283a 	ret

04003ff0 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 4003ff0:	defffd04 	addi	sp,sp,-12
 4003ff4:	dfc00215 	stw	ra,8(sp)
 4003ff8:	df000115 	stw	fp,4(sp)
 4003ffc:	df000104 	addi	fp,sp,4
 4004000:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( CPU, cpu);
 4004004:	4006dec0 	call	4006dec <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 4004008:	00800044 	movi	r2,1
 400400c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 4004010:	e037883a 	mov	sp,fp
 4004014:	dfc00117 	ldw	ra,4(sp)
 4004018:	df000017 	ldw	fp,0(sp)
 400401c:	dec00204 	addi	sp,sp,8
 4004020:	f800283a 	ret

04004024 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 4004024:	defffe04 	addi	sp,sp,-8
 4004028:	dfc00115 	stw	ra,4(sp)
 400402c:	df000015 	stw	fp,0(sp)
 4004030:	d839883a 	mov	fp,sp
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS, epcs);
 4004034:	01010034 	movhi	r4,1024
 4004038:	211f7004 	addi	r4,r4,32192
 400403c:	40040ac0 	call	40040ac <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 4004040:	01010034 	movhi	r4,1024
 4004044:	211fac04 	addi	r4,r4,32432
 4004048:	000b883a 	mov	r5,zero
 400404c:	01800044 	movi	r6,1
 4004050:	4004bd80 	call	4004bd8 <altera_avalon_jtag_uart_init>
 4004054:	01010034 	movhi	r4,1024
 4004058:	211fa204 	addi	r4,r4,32392
 400405c:	40040740 	call	4004074 <alt_dev_reg>
    ALTERA_AVALON_SPI_INIT ( SPI_TOUCH, spi_touch);
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID, sysid);
}
 4004060:	e037883a 	mov	sp,fp
 4004064:	dfc00117 	ldw	ra,4(sp)
 4004068:	df000017 	ldw	fp,0(sp)
 400406c:	dec00204 	addi	sp,sp,8
 4004070:	f800283a 	ret

04004074 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 4004074:	defffd04 	addi	sp,sp,-12
 4004078:	dfc00215 	stw	ra,8(sp)
 400407c:	df000115 	stw	fp,4(sp)
 4004080:	df000104 	addi	fp,sp,4
 4004084:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 4004088:	e13fff17 	ldw	r4,-4(fp)
 400408c:	01410074 	movhi	r5,1025
 4004090:	29652604 	addi	r5,r5,-27496
 4004094:	40062700 	call	4006270 <alt_dev_llist_insert>
}
 4004098:	e037883a 	mov	sp,fp
 400409c:	dfc00117 	ldw	ra,4(sp)
 40040a0:	df000017 	ldw	fp,0(sp)
 40040a4:	dec00204 	addi	sp,sp,8
 40040a8:	f800283a 	ret

040040ac <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
 40040ac:	defffc04 	addi	sp,sp,-16
 40040b0:	dfc00315 	stw	ra,12(sp)
 40040b4:	df000215 	stw	fp,8(sp)
 40040b8:	df000204 	addi	fp,sp,8
 40040bc:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 40040c0:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
 40040c4:	e13fff17 	ldw	r4,-4(fp)
 40040c8:	40041380 	call	4004138 <alt_epcs_flash_query>
 40040cc:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
 40040d0:	e0bffe17 	ldw	r2,-8(fp)
 40040d4:	1004c03a 	cmpne	r2,r2,zero
 40040d8:	1000031e 	bne	r2,zero,40040e8 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
 40040dc:	e13fff17 	ldw	r4,-4(fp)
 40040e0:	40041000 	call	4004100 <alt_flash_device_register>
 40040e4:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
 40040e8:	e0bffe17 	ldw	r2,-8(fp)
}
 40040ec:	e037883a 	mov	sp,fp
 40040f0:	dfc00117 	ldw	ra,4(sp)
 40040f4:	df000017 	ldw	fp,0(sp)
 40040f8:	dec00204 	addi	sp,sp,8
 40040fc:	f800283a 	ret

04004100 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 4004100:	defffd04 	addi	sp,sp,-12
 4004104:	dfc00215 	stw	ra,8(sp)
 4004108:	df000115 	stw	fp,4(sp)
 400410c:	df000104 	addi	fp,sp,4
 4004110:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 4004114:	e13fff17 	ldw	r4,-4(fp)
 4004118:	01410074 	movhi	r5,1025
 400411c:	29652a04 	addi	r5,r5,-27480
 4004120:	40062700 	call	4006270 <alt_dev_llist_insert>
}
 4004124:	e037883a 	mov	sp,fp
 4004128:	dfc00117 	ldw	ra,4(sp)
 400412c:	df000017 	ldw	fp,0(sp)
 4004130:	dec00204 	addi	sp,sp,8
 4004134:	f800283a 	ret

04004138 <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
 4004138:	defffc04 	addi	sp,sp,-16
 400413c:	dfc00315 	stw	ra,12(sp)
 4004140:	df000215 	stw	fp,8(sp)
 4004144:	df000204 	addi	fp,sp,8
 4004148:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 400414c:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
 4004150:	e0bfff17 	ldw	r2,-4(fp)
 4004154:	10003115 	stw	zero,196(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
 4004158:	e0bfff17 	ldw	r2,-4(fp)
 400415c:	11002d17 	ldw	r4,180(r2)
 4004160:	4005cac0 	call	4005cac <epcs_read_electronic_signature>
 4004164:	10c03fcc 	andi	r3,r2,255
 4004168:	e0bfff17 	ldw	r2,-4(fp)
 400416c:	10c02f15 	stw	r3,188(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
 4004170:	e0bfff17 	ldw	r2,-4(fp)
 4004174:	10802f17 	ldw	r2,188(r2)
 4004178:	10800598 	cmpnei	r2,r2,22
 400417c:	10000a1e 	bne	r2,zero,40041a8 <alt_epcs_flash_query+0x70>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 4004180:	e0ffff17 	ldw	r3,-4(fp)
 4004184:	00802034 	movhi	r2,128
 4004188:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 128;
 400418c:	e0ffff17 	ldw	r3,-4(fp)
 4004190:	00802004 	movi	r2,128
 4004194:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 4004198:	e0ffff17 	ldw	r3,-4(fp)
 400419c:	00800074 	movhi	r2,1
 40041a0:	18801015 	stw	r2,64(r3)
 40041a4:	00007306 	br	4004374 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
 40041a8:	e0bfff17 	ldw	r2,-4(fp)
 40041ac:	10802f17 	ldw	r2,188(r2)
 40041b0:	10800518 	cmpnei	r2,r2,20
 40041b4:	10000a1e 	bne	r2,zero,40041e0 <alt_epcs_flash_query+0xa8>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 40041b8:	e0ffff17 	ldw	r3,-4(fp)
 40041bc:	00800834 	movhi	r2,32
 40041c0:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 32;
 40041c4:	e0ffff17 	ldw	r3,-4(fp)
 40041c8:	00800804 	movi	r2,32
 40041cc:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 40041d0:	e0ffff17 	ldw	r3,-4(fp)
 40041d4:	00800074 	movhi	r2,1
 40041d8:	18801015 	stw	r2,64(r3)
 40041dc:	00006506 	br	4004374 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
 40041e0:	e0bfff17 	ldw	r2,-4(fp)
 40041e4:	10802f17 	ldw	r2,188(r2)
 40041e8:	108004d8 	cmpnei	r2,r2,19
 40041ec:	10000a1e 	bne	r2,zero,4004218 <alt_epcs_flash_query+0xe0>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
 40041f0:	e0ffff17 	ldw	r3,-4(fp)
 40041f4:	00800434 	movhi	r2,16
 40041f8:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 16;
 40041fc:	e0ffff17 	ldw	r3,-4(fp)
 4004200:	00800404 	movi	r2,16
 4004204:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 4004208:	e0ffff17 	ldw	r3,-4(fp)
 400420c:	00800074 	movhi	r2,1
 4004210:	18801015 	stw	r2,64(r3)
 4004214:	00005706 	br	4004374 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
 4004218:	e0bfff17 	ldw	r2,-4(fp)
 400421c:	10802f17 	ldw	r2,188(r2)
 4004220:	10800498 	cmpnei	r2,r2,18
 4004224:	10000a1e 	bne	r2,zero,4004250 <alt_epcs_flash_query+0x118>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
 4004228:	e0ffff17 	ldw	r3,-4(fp)
 400422c:	00800234 	movhi	r2,8
 4004230:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 8;
 4004234:	e0ffff17 	ldw	r3,-4(fp)
 4004238:	00800204 	movi	r2,8
 400423c:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 65536;
 4004240:	e0ffff17 	ldw	r3,-4(fp)
 4004244:	00800074 	movhi	r2,1
 4004248:	18801015 	stw	r2,64(r3)
 400424c:	00004906 	br	4004374 <alt_epcs_flash_query+0x23c>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
 4004250:	e0bfff17 	ldw	r2,-4(fp)
 4004254:	10802f17 	ldw	r2,188(r2)
 4004258:	10800418 	cmpnei	r2,r2,16
 400425c:	10000a1e 	bne	r2,zero,4004288 <alt_epcs_flash_query+0x150>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
 4004260:	e0ffff17 	ldw	r3,-4(fp)
 4004264:	008000b4 	movhi	r2,2
 4004268:	18800e15 	stw	r2,56(r3)
    flash->dev.region_info[0].number_of_blocks = 4;
 400426c:	e0ffff17 	ldw	r3,-4(fp)
 4004270:	00800104 	movi	r2,4
 4004274:	18800f15 	stw	r2,60(r3)
    flash->dev.region_info[0].block_size = 32768;
 4004278:	e0ffff17 	ldw	r3,-4(fp)
 400427c:	00a00014 	movui	r2,32768
 4004280:	18801015 	stw	r2,64(r3)
 4004284:	00003b06 	br	4004374 <alt_epcs_flash_query+0x23c>
  {
    /* 
     * Read electronic signature doesn't work for the EPCS128; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
 4004288:	e0bfff17 	ldw	r2,-4(fp)
 400428c:	11002d17 	ldw	r4,180(r2)
 4004290:	4005d180 	call	4005d18 <epcs_read_device_id>
 4004294:	1007883a 	mov	r3,r2
 4004298:	e0bfff17 	ldw	r2,-4(fp)
 400429c:	10c02f15 	stw	r3,188(r2)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
 40042a0:	e0bfff17 	ldw	r2,-4(fp)
 40042a4:	10c02f17 	ldw	r3,188(r2)
 40042a8:	00804034 	movhi	r2,256
 40042ac:	10bfffc4 	addi	r2,r2,-1
 40042b0:	1886703a 	and	r3,r3,r2
 40042b4:	00800874 	movhi	r2,33
 40042b8:	10ae8604 	addi	r2,r2,-17896
 40042bc:	18800a1e 	bne	r3,r2,40042e8 <alt_epcs_flash_query+0x1b0>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 40042c0:	e0ffff17 	ldw	r3,-4(fp)
 40042c4:	00804034 	movhi	r2,256
 40042c8:	18800e15 	stw	r2,56(r3)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
 40042cc:	e0ffff17 	ldw	r3,-4(fp)
 40042d0:	00804004 	movi	r2,256
 40042d4:	18800f15 	stw	r2,60(r3)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 40042d8:	e0ffff17 	ldw	r3,-4(fp)
 40042dc:	00800074 	movhi	r2,1
 40042e0:	18801015 	stw	r2,64(r3)
 40042e4:	00002306 	br	4004374 <alt_epcs_flash_query+0x23c>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
 40042e8:	e0bfff17 	ldw	r2,-4(fp)
 40042ec:	10802f17 	ldw	r2,188(r2)
 40042f0:	10803fcc 	andi	r2,r2,255
 40042f4:	10800618 	cmpnei	r2,r2,24
 40042f8:	10000a1e 	bne	r2,zero,4004324 <alt_epcs_flash_query+0x1ec>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 40042fc:	e0ffff17 	ldw	r3,-4(fp)
 4004300:	00804034 	movhi	r2,256
 4004304:	18800e15 	stw	r2,56(r3)
      flash->dev.region_info[0].number_of_blocks = 64;
 4004308:	e0ffff17 	ldw	r3,-4(fp)
 400430c:	00801004 	movi	r2,64
 4004310:	18800f15 	stw	r2,60(r3)
      flash->dev.region_info[0].block_size = 262144;
 4004314:	e0ffff17 	ldw	r3,-4(fp)
 4004318:	00800134 	movhi	r2,4
 400431c:	18801015 	stw	r2,64(r3)
 4004320:	00001406 	br	4004374 <alt_epcs_flash_query+0x23c>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
 4004324:	e0bfff17 	ldw	r2,-4(fp)
 4004328:	10802f17 	ldw	r2,188(r2)
 400432c:	10803fcc 	andi	r2,r2,255
 4004330:	10800658 	cmpnei	r2,r2,25
 4004334:	10000d1e 	bne	r2,zero,400436c <alt_epcs_flash_query+0x234>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
 4004338:	e0ffff17 	ldw	r3,-4(fp)
 400433c:	00808034 	movhi	r2,512
 4004340:	18800e15 	stw	r2,56(r3)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
 4004344:	e0ffff17 	ldw	r3,-4(fp)
 4004348:	00808004 	movi	r2,512
 400434c:	18800f15 	stw	r2,60(r3)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 4004350:	e0ffff17 	ldw	r3,-4(fp)
 4004354:	00800074 	movhi	r2,1
 4004358:	18801015 	stw	r2,64(r3)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
 400435c:	e0ffff17 	ldw	r3,-4(fp)
 4004360:	00800044 	movi	r2,1
 4004364:	18803115 	stw	r2,196(r3)
 4004368:	00000206 	br	4004374 <alt_epcs_flash_query+0x23c>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
 400436c:	00bffb44 	movi	r2,-19
 4004370:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
 4004374:	e0bfff17 	ldw	r2,-4(fp)
 4004378:	10800e17 	ldw	r2,56(r2)
 400437c:	1007883a 	mov	r3,r2
 4004380:	e0bfff17 	ldw	r2,-4(fp)
 4004384:	10c02e15 	stw	r3,184(r2)
  flash->dev.number_of_regions = 1;
 4004388:	e0ffff17 	ldw	r3,-4(fp)
 400438c:	00800044 	movi	r2,1
 4004390:	18800c15 	stw	r2,48(r3)
  flash->dev.region_info[0].offset = 0;
 4004394:	e0bfff17 	ldw	r2,-4(fp)
 4004398:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
 400439c:	e0ffff17 	ldw	r3,-4(fp)
 40043a0:	00804004 	movi	r2,256
 40043a4:	18803015 	stw	r2,192(r3)

  /* Consider clearing all BP bits here. */
  return ret_code;
 40043a8:	e0bffe17 	ldw	r2,-8(fp)
}
 40043ac:	e037883a 	mov	sp,fp
 40043b0:	dfc00117 	ldw	ra,4(sp)
 40043b4:	df000017 	ldw	fp,0(sp)
 40043b8:	dec00204 	addi	sp,sp,8
 40043bc:	f800283a 	ret

040043c0 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
 40043c0:	deffeb04 	addi	sp,sp,-84
 40043c4:	dfc01415 	stw	ra,80(sp)
 40043c8:	df001315 	stw	fp,76(sp)
 40043cc:	df001304 	addi	fp,sp,76
 40043d0:	e13ff915 	stw	r4,-28(fp)
 40043d4:	e17ffa15 	stw	r5,-24(fp)
 40043d8:	e1bffb15 	stw	r6,-20(fp)
 40043dc:	e1fffc15 	stw	r7,-16(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
 40043e0:	00800804 	movi	r2,32
 40043e4:	e0bff015 	stw	r2,-64(fp)
  int current_offset = 0;
 40043e8:	e03fef15 	stw	zero,-68(fp)

  while (n > 0)
 40043ec:	00002c06 	br	40044a0 <alt_epcs_flash_memcmp+0xe0>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
 40043f0:	e0bff017 	ldw	r2,-64(fp)
 40043f4:	e0bfff15 	stw	r2,-4(fp)
 40043f8:	e0fffc17 	ldw	r3,-16(fp)
 40043fc:	e0fffe15 	stw	r3,-8(fp)
 4004400:	e0bfff17 	ldw	r2,-4(fp)
 4004404:	e0fffe17 	ldw	r3,-8(fp)
 4004408:	10c0022e 	bgeu	r2,r3,4004414 <alt_epcs_flash_memcmp+0x54>
 400440c:	e0bfff17 	ldw	r2,-4(fp)
 4004410:	e0bffe15 	stw	r2,-8(fp)
 4004414:	e0fffe17 	ldw	r3,-8(fp)
 4004418:	e0ffee15 	stw	r3,-72(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
 400441c:	e0fffb17 	ldw	r3,-20(fp)
 4004420:	e0bfef17 	ldw	r2,-68(fp)
 4004424:	188b883a 	add	r5,r3,r2
 4004428:	e1bff104 	addi	r6,fp,-60
 400442c:	e13ff917 	ldw	r4,-28(fp)
 4004430:	e1ffee17 	ldw	r7,-72(fp)
 4004434:	40049f80 	call	40049f8 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
 4004438:	1004403a 	cmpge	r2,r2,zero
 400443c:	1000031e 	bne	r2,zero,400444c <alt_epcs_flash_memcmp+0x8c>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
 4004440:	00bfffc4 	movi	r2,-1
 4004444:	e0bffd15 	stw	r2,-12(fp)
 4004448:	00001906 	br	40044b0 <alt_epcs_flash_memcmp+0xf0>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
 400444c:	e0fffa17 	ldw	r3,-24(fp)
 4004450:	e0bfef17 	ldw	r2,-68(fp)
 4004454:	1889883a 	add	r4,r3,r2
 4004458:	e1bfee17 	ldw	r6,-72(fp)
 400445c:	e17ff104 	addi	r5,fp,-60
 4004460:	40070c40 	call	40070c4 <memcmp>
 4004464:	e0bfed15 	stw	r2,-76(fp)
    if (this_chunk_cmp)
 4004468:	e0bfed17 	ldw	r2,-76(fp)
 400446c:	1005003a 	cmpeq	r2,r2,zero
 4004470:	1000031e 	bne	r2,zero,4004480 <alt_epcs_flash_memcmp+0xc0>
    {
      return this_chunk_cmp;
 4004474:	e0ffed17 	ldw	r3,-76(fp)
 4004478:	e0fffd15 	stw	r3,-12(fp)
 400447c:	00000c06 	br	40044b0 <alt_epcs_flash_memcmp+0xf0>
    }

    n -= this_chunk_size;
 4004480:	e0ffee17 	ldw	r3,-72(fp)
 4004484:	e0bffc17 	ldw	r2,-16(fp)
 4004488:	10c5c83a 	sub	r2,r2,r3
 400448c:	e0bffc15 	stw	r2,-16(fp)
    current_offset += this_chunk_size;
 4004490:	e0ffef17 	ldw	r3,-68(fp)
 4004494:	e0bfee17 	ldw	r2,-72(fp)
 4004498:	1885883a 	add	r2,r3,r2
 400449c:	e0bfef15 	stw	r2,-68(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
 40044a0:	e0bffc17 	ldw	r2,-16(fp)
 40044a4:	1004c03a 	cmpne	r2,r2,zero
 40044a8:	103fd11e 	bne	r2,zero,40043f0 <alt_epcs_flash_memcmp+0x30>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
 40044ac:	e03ffd15 	stw	zero,-12(fp)
 40044b0:	e0bffd17 	ldw	r2,-12(fp)
}
 40044b4:	e037883a 	mov	sp,fp
 40044b8:	dfc00117 	ldw	ra,4(sp)
 40044bc:	df000017 	ldw	fp,0(sp)
 40044c0:	dec00204 	addi	sp,sp,8
 40044c4:	f800283a 	ret

040044c8 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
 40044c8:	defff204 	addi	sp,sp,-56
 40044cc:	dfc00d15 	stw	ra,52(sp)
 40044d0:	df000c15 	stw	fp,48(sp)
 40044d4:	df000c04 	addi	fp,sp,48
 40044d8:	e13ffa15 	stw	r4,-24(fp)
 40044dc:	e17ffb15 	stw	r5,-20(fp)
 40044e0:	e1bffc15 	stw	r6,-16(fp)
 40044e4:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 40044e8:	e03ff915 	stw	zero,-28(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 40044ec:	e03ff815 	stw	zero,-32(fp)
 40044f0:	00008b06 	br	4004720 <alt_epcs_flash_write+0x258>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 40044f4:	e0bff817 	ldw	r2,-32(fp)
 40044f8:	e0fffa17 	ldw	r3,-24(fp)
 40044fc:	1004913a 	slli	r2,r2,4
 4004500:	10c5883a 	add	r2,r2,r3
 4004504:	10800d04 	addi	r2,r2,52
 4004508:	10c00017 	ldw	r3,0(r2)
 400450c:	e0bffb17 	ldw	r2,-20(fp)
 4004510:	10c08016 	blt	r2,r3,4004714 <alt_epcs_flash_write+0x24c>
 4004514:	e0bff817 	ldw	r2,-32(fp)
 4004518:	e0fffa17 	ldw	r3,-24(fp)
 400451c:	1004913a 	slli	r2,r2,4
 4004520:	10c5883a 	add	r2,r2,r3
 4004524:	10800d04 	addi	r2,r2,52
 4004528:	11000017 	ldw	r4,0(r2)
 400452c:	e0bff817 	ldw	r2,-32(fp)
 4004530:	e0fffa17 	ldw	r3,-24(fp)
 4004534:	1004913a 	slli	r2,r2,4
 4004538:	10c5883a 	add	r2,r2,r3
 400453c:	10800e04 	addi	r2,r2,56
 4004540:	10800017 	ldw	r2,0(r2)
 4004544:	2087883a 	add	r3,r4,r2
 4004548:	e0bffb17 	ldw	r2,-20(fp)
 400454c:	10c0710e 	bge	r2,r3,4004714 <alt_epcs_flash_write+0x24c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
 4004550:	e0bff817 	ldw	r2,-32(fp)
 4004554:	e0fffa17 	ldw	r3,-24(fp)
 4004558:	1004913a 	slli	r2,r2,4
 400455c:	10c5883a 	add	r2,r2,r3
 4004560:	10800d04 	addi	r2,r2,52
 4004564:	10800017 	ldw	r2,0(r2)
 4004568:	e0bff515 	stw	r2,-44(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 400456c:	e03ff715 	stw	zero,-36(fp)
 4004570:	00006006 	br	40046f4 <alt_epcs_flash_write+0x22c>
      {
        if ((offset >= current_offset ) &&
 4004574:	e0fffb17 	ldw	r3,-20(fp)
 4004578:	e0bff517 	ldw	r2,-44(fp)
 400457c:	18805116 	blt	r3,r2,40046c4 <alt_epcs_flash_write+0x1fc>
 4004580:	e0bff817 	ldw	r2,-32(fp)
 4004584:	e0fffa17 	ldw	r3,-24(fp)
 4004588:	1004913a 	slli	r2,r2,4
 400458c:	10c5883a 	add	r2,r2,r3
 4004590:	10801004 	addi	r2,r2,64
 4004594:	10c00017 	ldw	r3,0(r2)
 4004598:	e0bff517 	ldw	r2,-44(fp)
 400459c:	1887883a 	add	r3,r3,r2
 40045a0:	e0bffb17 	ldw	r2,-20(fp)
 40045a4:	10c0470e 	bge	r2,r3,40046c4 <alt_epcs_flash_write+0x1fc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
 40045a8:	e0bff817 	ldw	r2,-32(fp)
 40045ac:	e0fffa17 	ldw	r3,-24(fp)
 40045b0:	1004913a 	slli	r2,r2,4
 40045b4:	10c5883a 	add	r2,r2,r3
 40045b8:	10801004 	addi	r2,r2,64
 40045bc:	10c00017 	ldw	r3,0(r2)
 40045c0:	e0bff517 	ldw	r2,-44(fp)
 40045c4:	1887883a 	add	r3,r3,r2
 40045c8:	e0bffb17 	ldw	r2,-20(fp)
 40045cc:	1885c83a 	sub	r2,r3,r2
 40045d0:	e0bff615 	stw	r2,-40(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
 40045d4:	e0bff617 	ldw	r2,-40(fp)
 40045d8:	e0bfff15 	stw	r2,-4(fp)
 40045dc:	e0fffd17 	ldw	r3,-12(fp)
 40045e0:	e0fffe15 	stw	r3,-8(fp)
 40045e4:	e0bfff17 	ldw	r2,-4(fp)
 40045e8:	e0fffe17 	ldw	r3,-8(fp)
 40045ec:	10c0020e 	bge	r2,r3,40045f8 <alt_epcs_flash_write+0x130>
 40045f0:	e0bfff17 	ldw	r2,-4(fp)
 40045f4:	e0bffe15 	stw	r2,-8(fp)
 40045f8:	e0fffe17 	ldw	r3,-8(fp)
 40045fc:	e0fff615 	stw	r3,-40(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
 4004600:	e1fff617 	ldw	r7,-40(fp)
 4004604:	e13ffa17 	ldw	r4,-24(fp)
 4004608:	e17ffc17 	ldw	r5,-16(fp)
 400460c:	e1bffb17 	ldw	r6,-20(fp)
 4004610:	40043c00 	call	40043c0 <alt_epcs_flash_memcmp>
 4004614:	1005003a 	cmpeq	r2,r2,zero
 4004618:	1000131e 	bne	r2,zero,4004668 <alt_epcs_flash_write+0x1a0>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
 400461c:	e0bffa17 	ldw	r2,-24(fp)
 4004620:	10800817 	ldw	r2,32(r2)
 4004624:	e13ffa17 	ldw	r4,-24(fp)
 4004628:	e17ff517 	ldw	r5,-44(fp)
 400462c:	103ee83a 	callr	r2
 4004630:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 4004634:	e0bff917 	ldw	r2,-28(fp)
 4004638:	1004c03a 	cmpne	r2,r2,zero
 400463c:	10000a1e 	bne	r2,zero,4004668 <alt_epcs_flash_write+0x1a0>
            {
              ret_code = (*flash_info->write_block)(
 4004640:	e0bffa17 	ldw	r2,-24(fp)
 4004644:	10c00917 	ldw	r3,36(r2)
 4004648:	e0bff617 	ldw	r2,-40(fp)
 400464c:	d8800015 	stw	r2,0(sp)
 4004650:	e13ffa17 	ldw	r4,-24(fp)
 4004654:	e17ff517 	ldw	r5,-44(fp)
 4004658:	e1bffb17 	ldw	r6,-20(fp)
 400465c:	e1fffc17 	ldw	r7,-16(fp)
 4004660:	183ee83a 	callr	r3
 4004664:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
 4004668:	e0fffd17 	ldw	r3,-12(fp)
 400466c:	e0bff617 	ldw	r2,-40(fp)
 4004670:	18802f26 	beq	r3,r2,4004730 <alt_epcs_flash_write+0x268>
 4004674:	e0bff917 	ldw	r2,-28(fp)
 4004678:	1004c03a 	cmpne	r2,r2,zero
 400467c:	10002c1e 	bne	r2,zero,4004730 <alt_epcs_flash_write+0x268>
          {
            goto finished;
          }

          length -= data_to_write;
 4004680:	e0fffd17 	ldw	r3,-12(fp)
 4004684:	e0bff617 	ldw	r2,-40(fp)
 4004688:	1885c83a 	sub	r2,r3,r2
 400468c:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
 4004690:	e0bff817 	ldw	r2,-32(fp)
 4004694:	e0fffa17 	ldw	r3,-24(fp)
 4004698:	1004913a 	slli	r2,r2,4
 400469c:	10c5883a 	add	r2,r2,r3
 40046a0:	10801004 	addi	r2,r2,64
 40046a4:	10c00017 	ldw	r3,0(r2)
 40046a8:	e0bff517 	ldw	r2,-44(fp)
 40046ac:	1885883a 	add	r2,r3,r2
 40046b0:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 40046b4:	e0fffc17 	ldw	r3,-16(fp)
 40046b8:	e0bff617 	ldw	r2,-40(fp)
 40046bc:	1885883a 	add	r2,r3,r2
 40046c0:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
 40046c4:	e0bff817 	ldw	r2,-32(fp)
 40046c8:	e0fffa17 	ldw	r3,-24(fp)
 40046cc:	1004913a 	slli	r2,r2,4
 40046d0:	10c5883a 	add	r2,r2,r3
 40046d4:	10801004 	addi	r2,r2,64
 40046d8:	10c00017 	ldw	r3,0(r2)
 40046dc:	e0bff517 	ldw	r2,-44(fp)
 40046e0:	10c5883a 	add	r2,r2,r3
 40046e4:	e0bff515 	stw	r2,-44(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 40046e8:	e0bff717 	ldw	r2,-36(fp)
 40046ec:	10800044 	addi	r2,r2,1
 40046f0:	e0bff715 	stw	r2,-36(fp)
 40046f4:	e0bff817 	ldw	r2,-32(fp)
 40046f8:	e0fffa17 	ldw	r3,-24(fp)
 40046fc:	1004913a 	slli	r2,r2,4
 4004700:	10c5883a 	add	r2,r2,r3
 4004704:	10800f04 	addi	r2,r2,60
 4004708:	10c00017 	ldw	r3,0(r2)
 400470c:	e0bff717 	ldw	r2,-36(fp)
 4004710:	10ff9816 	blt	r2,r3,4004574 <alt_epcs_flash_write+0xac>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 4004714:	e0bff817 	ldw	r2,-32(fp)
 4004718:	10800044 	addi	r2,r2,1
 400471c:	e0bff815 	stw	r2,-32(fp)
 4004720:	e0bffa17 	ldw	r2,-24(fp)
 4004724:	10c00c17 	ldw	r3,48(r2)
 4004728:	e0bff817 	ldw	r2,-32(fp)
 400472c:	10ff7116 	blt	r2,r3,40044f4 <alt_epcs_flash_write+0x2c>
      }
    }
  }

finished:
  return ret_code;
 4004730:	e0bff917 	ldw	r2,-28(fp)
}
 4004734:	e037883a 	mov	sp,fp
 4004738:	dfc00117 	ldw	ra,4(sp)
 400473c:	df000017 	ldw	fp,0(sp)
 4004740:	dec00204 	addi	sp,sp,8
 4004744:	f800283a 	ret

04004748 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
 4004748:	defffa04 	addi	sp,sp,-24
 400474c:	df000515 	stw	fp,20(sp)
 4004750:	df000504 	addi	fp,sp,20
 4004754:	e13ffd15 	stw	r4,-12(fp)
 4004758:	e17ffe15 	stw	r5,-8(fp)
 400475c:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 4004760:	e03ffc15 	stw	zero,-16(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
 4004764:	e0bffd17 	ldw	r2,-12(fp)
 4004768:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 400476c:	e0bffb17 	ldw	r2,-20(fp)
 4004770:	10c00c17 	ldw	r3,48(r2)
 4004774:	e0bfff17 	ldw	r2,-4(fp)
 4004778:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 400477c:	e0bffb17 	ldw	r2,-20(fp)
 4004780:	10800c17 	ldw	r2,48(r2)
 4004784:	1004c03a 	cmpne	r2,r2,zero
 4004788:	1000031e 	bne	r2,zero,4004798 <alt_epcs_flash_get_info+0x50>
  {
    ret_code = -EIO;
 400478c:	00bffec4 	movi	r2,-5
 4004790:	e0bffc15 	stw	r2,-16(fp)
 4004794:	00000b06 	br	40047c4 <alt_epcs_flash_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 4004798:	e0bffb17 	ldw	r2,-20(fp)
 400479c:	10800c17 	ldw	r2,48(r2)
 40047a0:	10800250 	cmplti	r2,r2,9
 40047a4:	1000031e 	bne	r2,zero,40047b4 <alt_epcs_flash_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 40047a8:	00bffd04 	movi	r2,-12
 40047ac:	e0bffc15 	stw	r2,-16(fp)
 40047b0:	00000406 	br	40047c4 <alt_epcs_flash_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 40047b4:	e0bffb17 	ldw	r2,-20(fp)
 40047b8:	10c00d04 	addi	r3,r2,52
 40047bc:	e0bffe17 	ldw	r2,-8(fp)
 40047c0:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 40047c4:	e0bffc17 	ldw	r2,-16(fp)
}
 40047c8:	e037883a 	mov	sp,fp
 40047cc:	df000017 	ldw	fp,0(sp)
 40047d0:	dec00104 	addi	sp,sp,4
 40047d4:	f800283a 	ret

040047d8 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
 40047d8:	defffa04 	addi	sp,sp,-24
 40047dc:	dfc00515 	stw	ra,20(sp)
 40047e0:	df000415 	stw	fp,16(sp)
 40047e4:	df000404 	addi	fp,sp,16
 40047e8:	e13ffe15 	stw	r4,-8(fp)
 40047ec:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 40047f0:	e03ffd15 	stw	zero,-12(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 40047f4:	e0bffe17 	ldw	r2,-8(fp)
 40047f8:	e0bffc15 	stw	r2,-16(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
 40047fc:	e13ffe17 	ldw	r4,-8(fp)
 4004800:	e17fff17 	ldw	r5,-4(fp)
 4004804:	40048480 	call	4004848 <alt_epcs_test_address>
 4004808:	e0bffd15 	stw	r2,-12(fp)

  if (ret_code >= 0)
 400480c:	e0bffd17 	ldw	r2,-12(fp)
 4004810:	1004803a 	cmplt	r2,r2,zero
 4004814:	1000061e 	bne	r2,zero,4004830 <alt_epcs_flash_erase_block+0x58>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
 4004818:	e0bffc17 	ldw	r2,-16(fp)
 400481c:	11002d17 	ldw	r4,180(r2)
 4004820:	e17fff17 	ldw	r5,-4(fp)
 4004824:	e0bffc17 	ldw	r2,-16(fp)
 4004828:	11803117 	ldw	r6,196(r2)
 400482c:	40057d40 	call	40057d4 <epcs_sector_erase>
  }
  return ret_code;
 4004830:	e0bffd17 	ldw	r2,-12(fp)
}
 4004834:	e037883a 	mov	sp,fp
 4004838:	dfc00117 	ldw	ra,4(sp)
 400483c:	df000017 	ldw	fp,0(sp)
 4004840:	dec00204 	addi	sp,sp,8
 4004844:	f800283a 	ret

04004848 <alt_epcs_test_address>:
}


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
 4004848:	defff904 	addi	sp,sp,-28
 400484c:	df000615 	stw	fp,24(sp)
 4004850:	df000604 	addi	fp,sp,24
 4004854:	e13ffe15 	stw	r4,-8(fp)
 4004858:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 400485c:	e03ffd15 	stw	zero,-12(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 4004860:	e0bffe17 	ldw	r2,-8(fp)
 4004864:	e0bffc15 	stw	r2,-16(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
 4004868:	e0bffc17 	ldw	r2,-16(fp)
 400486c:	10800c17 	ldw	r2,48(r2)
 4004870:	10bfffc4 	addi	r2,r2,-1
 4004874:	e0bffb15 	stw	r2,-20(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
 4004878:	e0bffb17 	ldw	r2,-20(fp)
 400487c:	e0fffc17 	ldw	r3,-16(fp)
 4004880:	1004913a 	slli	r2,r2,4
 4004884:	10c5883a 	add	r2,r2,r3
 4004888:	10800d04 	addi	r2,r2,52
 400488c:	11000017 	ldw	r4,0(r2)
 4004890:	e0bffb17 	ldw	r2,-20(fp)
 4004894:	e0fffc17 	ldw	r3,-16(fp)
 4004898:	1004913a 	slli	r2,r2,4
 400489c:	10c5883a 	add	r2,r2,r3
 40048a0:	10800e04 	addi	r2,r2,56
 40048a4:	10800017 	ldw	r2,0(r2)
 40048a8:	2085883a 	add	r2,r4,r2
 40048ac:	10bfffc4 	addi	r2,r2,-1
 40048b0:	e0bffa15 	stw	r2,-24(fp)

  if (offset > last_device_address)
 40048b4:	e0ffff17 	ldw	r3,-4(fp)
 40048b8:	e0bffa17 	ldw	r2,-24(fp)
 40048bc:	10c0022e 	bgeu	r2,r3,40048c8 <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
 40048c0:	00bffec4 	movi	r2,-5
 40048c4:	e0bffd15 	stw	r2,-12(fp)
  }
  return ret_code;
 40048c8:	e0bffd17 	ldw	r2,-12(fp)
}
 40048cc:	e037883a 	mov	sp,fp
 40048d0:	df000017 	ldw	fp,0(sp)
 40048d4:	dec00104 	addi	sp,sp,4
 40048d8:	f800283a 	ret

040048dc <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
 40048dc:	defff204 	addi	sp,sp,-56
 40048e0:	dfc00d15 	stw	ra,52(sp)
 40048e4:	df000c15 	stw	fp,48(sp)
 40048e8:	df000c04 	addi	fp,sp,48
 40048ec:	e13ffa15 	stw	r4,-24(fp)
 40048f0:	e17ffb15 	stw	r5,-20(fp)
 40048f4:	e1bffc15 	stw	r6,-16(fp)
 40048f8:	e1fffd15 	stw	r7,-12(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 40048fc:	e0bffa17 	ldw	r2,-24(fp)
 4004900:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
 4004904:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
 4004908:	e13ffa17 	ldw	r4,-24(fp)
 400490c:	e17ffc17 	ldw	r5,-16(fp)
 4004910:	40048480 	call	4004848 <alt_epcs_test_address>
 4004914:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
 4004918:	e0bff917 	ldw	r2,-28(fp)
 400491c:	1004803a 	cmplt	r2,r2,zero
 4004920:	10002f1e 	bne	r2,zero,40049e0 <alt_epcs_flash_write_block+0x104>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 4004924:	00002b06 	br	40049d4 <alt_epcs_flash_write_block+0xf8>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
 4004928:	e0bff817 	ldw	r2,-32(fp)
 400492c:	10c03017 	ldw	r3,192(r2)
 4004930:	e0bffc17 	ldw	r2,-16(fp)
 4004934:	1887883a 	add	r3,r3,r2
 4004938:	e0bff817 	ldw	r2,-32(fp)
 400493c:	10803017 	ldw	r2,192(r2)
 4004940:	0085c83a 	sub	r2,zero,r2
 4004944:	1884703a 	and	r2,r3,r2
 4004948:	e0bff515 	stw	r2,-44(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
 400494c:	e0fff517 	ldw	r3,-44(fp)
 4004950:	e0bffc17 	ldw	r2,-16(fp)
 4004954:	1885c83a 	sub	r2,r3,r2
 4004958:	e0c00217 	ldw	r3,8(fp)
 400495c:	e0ffff15 	stw	r3,-4(fp)
 4004960:	e0bffe15 	stw	r2,-8(fp)
 4004964:	e0bfff17 	ldw	r2,-4(fp)
 4004968:	e0fffe17 	ldw	r3,-8(fp)
 400496c:	10c0020e 	bge	r2,r3,4004978 <alt_epcs_flash_write_block+0x9c>
 4004970:	e0bfff17 	ldw	r2,-4(fp)
 4004974:	e0bffe15 	stw	r2,-8(fp)
 4004978:	e0fffe17 	ldw	r3,-8(fp)
 400497c:	e0fff615 	stw	r3,-40(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 4004980:	e0bff817 	ldw	r2,-32(fp)
 4004984:	11002d17 	ldw	r4,180(r2)
 4004988:	e0fffd17 	ldw	r3,-12(fp)
 400498c:	e0bff717 	ldw	r2,-36(fp)
 4004990:	188d883a 	add	r6,r3,r2
 4004994:	e0bff817 	ldw	r2,-32(fp)
 4004998:	10803117 	ldw	r2,196(r2)
 400499c:	d8800015 	stw	r2,0(sp)
 40049a0:	e17ffc17 	ldw	r5,-16(fp)
 40049a4:	e1fff617 	ldw	r7,-40(fp)
 40049a8:	4005b3c0 	call	4005b3c <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
 40049ac:	e0c00217 	ldw	r3,8(fp)
 40049b0:	e0bff617 	ldw	r2,-40(fp)
 40049b4:	1885c83a 	sub	r2,r3,r2
 40049b8:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
 40049bc:	e0fff717 	ldw	r3,-36(fp)
 40049c0:	e0bff617 	ldw	r2,-40(fp)
 40049c4:	1885883a 	add	r2,r3,r2
 40049c8:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
 40049cc:	e0bff517 	ldw	r2,-44(fp)
 40049d0:	e0bffc15 	stw	r2,-16(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 40049d4:	e0800217 	ldw	r2,8(fp)
 40049d8:	1004c03a 	cmpne	r2,r2,zero
 40049dc:	103fd21e 	bne	r2,zero,4004928 <alt_epcs_flash_write_block+0x4c>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
 40049e0:	e0bff917 	ldw	r2,-28(fp)
}
 40049e4:	e037883a 	mov	sp,fp
 40049e8:	dfc00117 	ldw	ra,4(sp)
 40049ec:	df000017 	ldw	fp,0(sp)
 40049f0:	dec00204 	addi	sp,sp,8
 40049f4:	f800283a 	ret

040049f8 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
 40049f8:	defff704 	addi	sp,sp,-36
 40049fc:	dfc00815 	stw	ra,32(sp)
 4004a00:	df000715 	stw	fp,28(sp)
 4004a04:	df000704 	addi	fp,sp,28
 4004a08:	e13ffc15 	stw	r4,-16(fp)
 4004a0c:	e17ffd15 	stw	r5,-12(fp)
 4004a10:	e1bffe15 	stw	r6,-8(fp)
 4004a14:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 4004a18:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 4004a1c:	e0bffc17 	ldw	r2,-16(fp)
 4004a20:	e0bffa15 	stw	r2,-24(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
 4004a24:	e13ffc17 	ldw	r4,-16(fp)
 4004a28:	e17ffd17 	ldw	r5,-12(fp)
 4004a2c:	40048480 	call	4004848 <alt_epcs_test_address>
 4004a30:	e0bffb15 	stw	r2,-20(fp)

  if (ret_code >= 0)
 4004a34:	e0bffb17 	ldw	r2,-20(fp)
 4004a38:	1004803a 	cmplt	r2,r2,zero
 4004a3c:	10000e1e 	bne	r2,zero,4004a78 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 4004a40:	e0bffa17 	ldw	r2,-24(fp)
 4004a44:	11002d17 	ldw	r4,180(r2)
 4004a48:	e1bffe17 	ldw	r6,-8(fp)
 4004a4c:	e0bffa17 	ldw	r2,-24(fp)
 4004a50:	10803117 	ldw	r2,196(r2)
 4004a54:	d8800015 	stw	r2,0(sp)
 4004a58:	e17ffd17 	ldw	r5,-12(fp)
 4004a5c:	e1ffff17 	ldw	r7,-4(fp)
 4004a60:	400593c0 	call	400593c <epcs_read_buffer>
 4004a64:	e0bffb15 	stw	r2,-20(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
 4004a68:	e0fffb17 	ldw	r3,-20(fp)
 4004a6c:	e0bfff17 	ldw	r2,-4(fp)
 4004a70:	1880011e 	bne	r3,r2,4004a78 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
 4004a74:	e03ffb15 	stw	zero,-20(fp)
    }
  }
  return ret_code;
 4004a78:	e0bffb17 	ldw	r2,-20(fp)
}
 4004a7c:	e037883a 	mov	sp,fp
 4004a80:	dfc00117 	ldw	ra,4(sp)
 4004a84:	df000017 	ldw	fp,0(sp)
 4004a88:	dec00204 	addi	sp,sp,8
 4004a8c:	f800283a 	ret

04004a90 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 4004a90:	defffa04 	addi	sp,sp,-24
 4004a94:	dfc00515 	stw	ra,20(sp)
 4004a98:	df000415 	stw	fp,16(sp)
 4004a9c:	df000404 	addi	fp,sp,16
 4004aa0:	e13ffd15 	stw	r4,-12(fp)
 4004aa4:	e17ffe15 	stw	r5,-8(fp)
 4004aa8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4004aac:	e0bffd17 	ldw	r2,-12(fp)
 4004ab0:	10800017 	ldw	r2,0(r2)
 4004ab4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 4004ab8:	e0bffc17 	ldw	r2,-16(fp)
 4004abc:	11000a04 	addi	r4,r2,40
 4004ac0:	e0bffd17 	ldw	r2,-12(fp)
 4004ac4:	11c00217 	ldw	r7,8(r2)
 4004ac8:	e17ffe17 	ldw	r5,-8(fp)
 4004acc:	e1bfff17 	ldw	r6,-4(fp)
 4004ad0:	40050d80 	call	40050d8 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 4004ad4:	e037883a 	mov	sp,fp
 4004ad8:	dfc00117 	ldw	ra,4(sp)
 4004adc:	df000017 	ldw	fp,0(sp)
 4004ae0:	dec00204 	addi	sp,sp,8
 4004ae4:	f800283a 	ret

04004ae8 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 4004ae8:	defffa04 	addi	sp,sp,-24
 4004aec:	dfc00515 	stw	ra,20(sp)
 4004af0:	df000415 	stw	fp,16(sp)
 4004af4:	df000404 	addi	fp,sp,16
 4004af8:	e13ffd15 	stw	r4,-12(fp)
 4004afc:	e17ffe15 	stw	r5,-8(fp)
 4004b00:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4004b04:	e0bffd17 	ldw	r2,-12(fp)
 4004b08:	10800017 	ldw	r2,0(r2)
 4004b0c:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 4004b10:	e0bffc17 	ldw	r2,-16(fp)
 4004b14:	11000a04 	addi	r4,r2,40
 4004b18:	e0bffd17 	ldw	r2,-12(fp)
 4004b1c:	11c00217 	ldw	r7,8(r2)
 4004b20:	e17ffe17 	ldw	r5,-8(fp)
 4004b24:	e1bfff17 	ldw	r6,-4(fp)
 4004b28:	40052fc0 	call	40052fc <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 4004b2c:	e037883a 	mov	sp,fp
 4004b30:	dfc00117 	ldw	ra,4(sp)
 4004b34:	df000017 	ldw	fp,0(sp)
 4004b38:	dec00204 	addi	sp,sp,8
 4004b3c:	f800283a 	ret

04004b40 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 4004b40:	defffc04 	addi	sp,sp,-16
 4004b44:	dfc00315 	stw	ra,12(sp)
 4004b48:	df000215 	stw	fp,8(sp)
 4004b4c:	df000204 	addi	fp,sp,8
 4004b50:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 4004b54:	e0bfff17 	ldw	r2,-4(fp)
 4004b58:	10800017 	ldw	r2,0(r2)
 4004b5c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 4004b60:	e0bffe17 	ldw	r2,-8(fp)
 4004b64:	11000a04 	addi	r4,r2,40
 4004b68:	e0bfff17 	ldw	r2,-4(fp)
 4004b6c:	11400217 	ldw	r5,8(r2)
 4004b70:	4004f700 	call	4004f70 <altera_avalon_jtag_uart_close>
}
 4004b74:	e037883a 	mov	sp,fp
 4004b78:	dfc00117 	ldw	ra,4(sp)
 4004b7c:	df000017 	ldw	fp,0(sp)
 4004b80:	dec00204 	addi	sp,sp,8
 4004b84:	f800283a 	ret

04004b88 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 4004b88:	defffa04 	addi	sp,sp,-24
 4004b8c:	dfc00515 	stw	ra,20(sp)
 4004b90:	df000415 	stw	fp,16(sp)
 4004b94:	df000404 	addi	fp,sp,16
 4004b98:	e13ffd15 	stw	r4,-12(fp)
 4004b9c:	e17ffe15 	stw	r5,-8(fp)
 4004ba0:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 4004ba4:	e0bffd17 	ldw	r2,-12(fp)
 4004ba8:	10800017 	ldw	r2,0(r2)
 4004bac:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 4004bb0:	e0bffc17 	ldw	r2,-16(fp)
 4004bb4:	11000a04 	addi	r4,r2,40
 4004bb8:	e17ffe17 	ldw	r5,-8(fp)
 4004bbc:	e1bfff17 	ldw	r6,-4(fp)
 4004bc0:	4004fe40 	call	4004fe4 <altera_avalon_jtag_uart_ioctl>
}
 4004bc4:	e037883a 	mov	sp,fp
 4004bc8:	dfc00117 	ldw	ra,4(sp)
 4004bcc:	df000017 	ldw	fp,0(sp)
 4004bd0:	dec00204 	addi	sp,sp,8
 4004bd4:	f800283a 	ret

04004bd8 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 4004bd8:	defffa04 	addi	sp,sp,-24
 4004bdc:	dfc00515 	stw	ra,20(sp)
 4004be0:	df000415 	stw	fp,16(sp)
 4004be4:	df000404 	addi	fp,sp,16
 4004be8:	e13ffd15 	stw	r4,-12(fp)
 4004bec:	e17ffe15 	stw	r5,-8(fp)
 4004bf0:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
  ALT_SEM_CREATE(&sp->read_lock, 1);
  ALT_SEM_CREATE(&sp->write_lock, 1);

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4004bf4:	e0fffd17 	ldw	r3,-12(fp)
 4004bf8:	00800044 	movi	r2,1
 4004bfc:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 4004c00:	e0bffd17 	ldw	r2,-12(fp)
 4004c04:	10800017 	ldw	r2,0(r2)
 4004c08:	11000104 	addi	r4,r2,4
 4004c0c:	e0bffd17 	ldw	r2,-12(fp)
 4004c10:	10800817 	ldw	r2,32(r2)
 4004c14:	1007883a 	mov	r3,r2
 4004c18:	2005883a 	mov	r2,r4
 4004c1c:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 4004c20:	e13ffe17 	ldw	r4,-8(fp)
 4004c24:	e17fff17 	ldw	r5,-4(fp)
 4004c28:	d8000015 	stw	zero,0(sp)
 4004c2c:	01810034 	movhi	r6,1024
 4004c30:	31932604 	addi	r6,r6,19608
 4004c34:	e1fffd17 	ldw	r7,-12(fp)
 4004c38:	400651c0 	call	400651c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 4004c3c:	e0bffd17 	ldw	r2,-12(fp)
 4004c40:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 4004c44:	e0bffd17 	ldw	r2,-12(fp)
 4004c48:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 4004c4c:	00810074 	movhi	r2,1025
 4004c50:	10a53804 	addi	r2,r2,-27424
 4004c54:	10800017 	ldw	r2,0(r2)
 4004c58:	100b883a 	mov	r5,r2
 4004c5c:	01810034 	movhi	r6,1024
 4004c60:	3193b004 	addi	r6,r6,20160
 4004c64:	e1fffd17 	ldw	r7,-12(fp)
 4004c68:	4005e480 	call	4005e48 <alt_alarm_start>
 4004c6c:	1004403a 	cmpge	r2,r2,zero
 4004c70:	1000041e 	bne	r2,zero,4004c84 <altera_avalon_jtag_uart_init+0xac>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 4004c74:	e0fffd17 	ldw	r3,-12(fp)
 4004c78:	00a00034 	movhi	r2,32768
 4004c7c:	10bfffc4 	addi	r2,r2,-1
 4004c80:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 4004c84:	e037883a 	mov	sp,fp
 4004c88:	dfc00117 	ldw	ra,4(sp)
 4004c8c:	df000017 	ldw	fp,0(sp)
 4004c90:	dec00204 	addi	sp,sp,8
 4004c94:	f800283a 	ret

04004c98 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 4004c98:	defff804 	addi	sp,sp,-32
 4004c9c:	df000715 	stw	fp,28(sp)
 4004ca0:	df000704 	addi	fp,sp,28
 4004ca4:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 4004ca8:	e0bfff17 	ldw	r2,-4(fp)
 4004cac:	e0bffe15 	stw	r2,-8(fp)
  unsigned int base = sp->base;
 4004cb0:	e0bffe17 	ldw	r2,-8(fp)
 4004cb4:	10800017 	ldw	r2,0(r2)
 4004cb8:	e0bffd15 	stw	r2,-12(fp)
 4004cbc:	00000006 	br	4004cc0 <altera_avalon_jtag_uart_irq+0x28>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4004cc0:	e0bffd17 	ldw	r2,-12(fp)
 4004cc4:	10800104 	addi	r2,r2,4
 4004cc8:	10800037 	ldwio	r2,0(r2)
 4004ccc:	e0bffc15 	stw	r2,-16(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 4004cd0:	e0bffc17 	ldw	r2,-16(fp)
 4004cd4:	1080c00c 	andi	r2,r2,768
 4004cd8:	1005003a 	cmpeq	r2,r2,zero
 4004cdc:	1000741e 	bne	r2,zero,4004eb0 <altera_avalon_jtag_uart_irq+0x218>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 4004ce0:	e0bffc17 	ldw	r2,-16(fp)
 4004ce4:	1080400c 	andi	r2,r2,256
 4004ce8:	1005003a 	cmpeq	r2,r2,zero
 4004cec:	1000351e 	bne	r2,zero,4004dc4 <altera_avalon_jtag_uart_irq+0x12c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 4004cf0:	00800074 	movhi	r2,1
 4004cf4:	e0bffb15 	stw	r2,-20(fp)
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4004cf8:	e0bffe17 	ldw	r2,-8(fp)
 4004cfc:	10800a17 	ldw	r2,40(r2)
 4004d00:	10800044 	addi	r2,r2,1
 4004d04:	1081ffcc 	andi	r2,r2,2047
 4004d08:	e0bffa15 	stw	r2,-24(fp)
        if (next == sp->rx_out)
 4004d0c:	e0bffe17 	ldw	r2,-8(fp)
 4004d10:	10c00b17 	ldw	r3,44(r2)
 4004d14:	e0bffa17 	ldw	r2,-24(fp)
 4004d18:	18801626 	beq	r3,r2,4004d74 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 4004d1c:	e0bffd17 	ldw	r2,-12(fp)
 4004d20:	10800037 	ldwio	r2,0(r2)
 4004d24:	e0bffb15 	stw	r2,-20(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 4004d28:	e0bffb17 	ldw	r2,-20(fp)
 4004d2c:	10a0000c 	andi	r2,r2,32768
 4004d30:	1005003a 	cmpeq	r2,r2,zero
 4004d34:	10000f1e 	bne	r2,zero,4004d74 <altera_avalon_jtag_uart_irq+0xdc>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 4004d38:	e0bffe17 	ldw	r2,-8(fp)
 4004d3c:	10c00a17 	ldw	r3,40(r2)
 4004d40:	e0bffb17 	ldw	r2,-20(fp)
 4004d44:	1009883a 	mov	r4,r2
 4004d48:	e0bffe17 	ldw	r2,-8(fp)
 4004d4c:	1885883a 	add	r2,r3,r2
 4004d50:	10800e04 	addi	r2,r2,56
 4004d54:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4004d58:	e0bffe17 	ldw	r2,-8(fp)
 4004d5c:	10800a17 	ldw	r2,40(r2)
 4004d60:	10800044 	addi	r2,r2,1
 4004d64:	10c1ffcc 	andi	r3,r2,2047
 4004d68:	e0bffe17 	ldw	r2,-8(fp)
 4004d6c:	10c00a15 	stw	r3,40(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 4004d70:	003fe106 	br	4004cf8 <altera_avalon_jtag_uart_irq+0x60>

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 4004d74:	e0bffb17 	ldw	r2,-20(fp)
 4004d78:	10bfffec 	andhi	r2,r2,65535
 4004d7c:	1005003a 	cmpeq	r2,r2,zero
 4004d80:	1000101e 	bne	r2,zero,4004dc4 <altera_avalon_jtag_uart_irq+0x12c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 4004d84:	e0bffe17 	ldw	r2,-8(fp)
 4004d88:	10c00817 	ldw	r3,32(r2)
 4004d8c:	00bfff84 	movi	r2,-2
 4004d90:	1886703a 	and	r3,r3,r2
 4004d94:	e0bffe17 	ldw	r2,-8(fp)
 4004d98:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 4004d9c:	e0bffd17 	ldw	r2,-12(fp)
 4004da0:	11000104 	addi	r4,r2,4
 4004da4:	e0bffe17 	ldw	r2,-8(fp)
 4004da8:	10800817 	ldw	r2,32(r2)
 4004dac:	1007883a 	mov	r3,r2
 4004db0:	2005883a 	mov	r2,r4
 4004db4:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4004db8:	e0bffd17 	ldw	r2,-12(fp)
 4004dbc:	10800104 	addi	r2,r2,4
 4004dc0:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 4004dc4:	e0bffc17 	ldw	r2,-16(fp)
 4004dc8:	1080800c 	andi	r2,r2,512
 4004dcc:	1005003a 	cmpeq	r2,r2,zero
 4004dd0:	103fbb1e 	bne	r2,zero,4004cc0 <altera_avalon_jtag_uart_irq+0x28>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 4004dd4:	e0bffc17 	ldw	r2,-16(fp)
 4004dd8:	10bfffec 	andhi	r2,r2,65535
 4004ddc:	1004d43a 	srli	r2,r2,16
 4004de0:	e0bff915 	stw	r2,-28(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 4004de4:	00001506 	br	4004e3c <altera_avalon_jtag_uart_irq+0x1a4>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 4004de8:	e13ffd17 	ldw	r4,-12(fp)
 4004dec:	e0bffe17 	ldw	r2,-8(fp)
 4004df0:	10c00d17 	ldw	r3,52(r2)
 4004df4:	e0bffe17 	ldw	r2,-8(fp)
 4004df8:	1885883a 	add	r2,r3,r2
 4004dfc:	10820e04 	addi	r2,r2,2104
 4004e00:	10800003 	ldbu	r2,0(r2)
 4004e04:	10c03fcc 	andi	r3,r2,255
 4004e08:	18c0201c 	xori	r3,r3,128
 4004e0c:	18ffe004 	addi	r3,r3,-128
 4004e10:	2005883a 	mov	r2,r4
 4004e14:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 4004e18:	e0bffe17 	ldw	r2,-8(fp)
 4004e1c:	10800d17 	ldw	r2,52(r2)
 4004e20:	10800044 	addi	r2,r2,1
 4004e24:	10c1ffcc 	andi	r3,r2,2047
 4004e28:	e0bffe17 	ldw	r2,-8(fp)
 4004e2c:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
 4004e30:	e0bff917 	ldw	r2,-28(fp)
 4004e34:	10bfffc4 	addi	r2,r2,-1
 4004e38:	e0bff915 	stw	r2,-28(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 4004e3c:	e0bff917 	ldw	r2,-28(fp)
 4004e40:	1005003a 	cmpeq	r2,r2,zero
 4004e44:	1000051e 	bne	r2,zero,4004e5c <altera_avalon_jtag_uart_irq+0x1c4>
 4004e48:	e0bffe17 	ldw	r2,-8(fp)
 4004e4c:	10c00d17 	ldw	r3,52(r2)
 4004e50:	e0bffe17 	ldw	r2,-8(fp)
 4004e54:	10800c17 	ldw	r2,48(r2)
 4004e58:	18bfe31e 	bne	r3,r2,4004de8 <altera_avalon_jtag_uart_irq+0x150>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 4004e5c:	e0bff917 	ldw	r2,-28(fp)
 4004e60:	1005003a 	cmpeq	r2,r2,zero
 4004e64:	103f961e 	bne	r2,zero,4004cc0 <altera_avalon_jtag_uart_irq+0x28>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4004e68:	e0bffe17 	ldw	r2,-8(fp)
 4004e6c:	10c00817 	ldw	r3,32(r2)
 4004e70:	00bfff44 	movi	r2,-3
 4004e74:	1886703a 	and	r3,r3,r2
 4004e78:	e0bffe17 	ldw	r2,-8(fp)
 4004e7c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4004e80:	e0bffe17 	ldw	r2,-8(fp)
 4004e84:	10800017 	ldw	r2,0(r2)
 4004e88:	11000104 	addi	r4,r2,4
 4004e8c:	e0bffe17 	ldw	r2,-8(fp)
 4004e90:	10800817 	ldw	r2,32(r2)
 4004e94:	1007883a 	mov	r3,r2
 4004e98:	2005883a 	mov	r2,r4
 4004e9c:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 4004ea0:	e0bffd17 	ldw	r2,-12(fp)
 4004ea4:	10800104 	addi	r2,r2,4
 4004ea8:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 4004eac:	003f8406 	br	4004cc0 <altera_avalon_jtag_uart_irq+0x28>
}
 4004eb0:	e037883a 	mov	sp,fp
 4004eb4:	df000017 	ldw	fp,0(sp)
 4004eb8:	dec00104 	addi	sp,sp,4
 4004ebc:	f800283a 	ret

04004ec0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 4004ec0:	defffc04 	addi	sp,sp,-16
 4004ec4:	df000315 	stw	fp,12(sp)
 4004ec8:	df000304 	addi	fp,sp,12
 4004ecc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 4004ed0:	e0bfff17 	ldw	r2,-4(fp)
 4004ed4:	e0bffe15 	stw	r2,-8(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 4004ed8:	e0bffe17 	ldw	r2,-8(fp)
 4004edc:	10800017 	ldw	r2,0(r2)
 4004ee0:	10800104 	addi	r2,r2,4
 4004ee4:	10800037 	ldwio	r2,0(r2)
 4004ee8:	e0bffd15 	stw	r2,-12(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 4004eec:	e0bffd17 	ldw	r2,-12(fp)
 4004ef0:	1081000c 	andi	r2,r2,1024
 4004ef4:	1005003a 	cmpeq	r2,r2,zero
 4004ef8:	10000c1e 	bne	r2,zero,4004f2c <altera_avalon_jtag_uart_timeout+0x6c>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 4004efc:	e0bffe17 	ldw	r2,-8(fp)
 4004f00:	10800017 	ldw	r2,0(r2)
 4004f04:	11000104 	addi	r4,r2,4
 4004f08:	e0bffe17 	ldw	r2,-8(fp)
 4004f0c:	10800817 	ldw	r2,32(r2)
 4004f10:	10810014 	ori	r2,r2,1024
 4004f14:	1007883a 	mov	r3,r2
 4004f18:	2005883a 	mov	r2,r4
 4004f1c:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 4004f20:	e0bffe17 	ldw	r2,-8(fp)
 4004f24:	10000915 	stw	zero,36(r2)
 4004f28:	00000a06 	br	4004f54 <altera_avalon_jtag_uart_timeout+0x94>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 4004f2c:	e0bffe17 	ldw	r2,-8(fp)
 4004f30:	10c00917 	ldw	r3,36(r2)
 4004f34:	00a00034 	movhi	r2,32768
 4004f38:	10bfff04 	addi	r2,r2,-4
 4004f3c:	10c00536 	bltu	r2,r3,4004f54 <altera_avalon_jtag_uart_timeout+0x94>
    sp->host_inactive++;
 4004f40:	e0bffe17 	ldw	r2,-8(fp)
 4004f44:	10800917 	ldw	r2,36(r2)
 4004f48:	10c00044 	addi	r3,r2,1
 4004f4c:	e0bffe17 	ldw	r2,-8(fp)
 4004f50:	10c00915 	stw	r3,36(r2)
 4004f54:	00810074 	movhi	r2,1025
 4004f58:	10a53804 	addi	r2,r2,-27424
 4004f5c:	10800017 	ldw	r2,0(r2)
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
    }
  }

  return alt_ticks_per_second();
}
 4004f60:	e037883a 	mov	sp,fp
 4004f64:	df000017 	ldw	fp,0(sp)
 4004f68:	dec00104 	addi	sp,sp,4
 4004f6c:	f800283a 	ret

04004f70 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 4004f70:	defffc04 	addi	sp,sp,-16
 4004f74:	df000315 	stw	fp,12(sp)
 4004f78:	df000304 	addi	fp,sp,12
 4004f7c:	e13ffd15 	stw	r4,-12(fp)
 4004f80:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4004f84:	00000706 	br	4004fa4 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 4004f88:	e0bffe17 	ldw	r2,-8(fp)
 4004f8c:	1090000c 	andi	r2,r2,16384
 4004f90:	1005003a 	cmpeq	r2,r2,zero
 4004f94:	1000031e 	bne	r2,zero,4004fa4 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 4004f98:	00bffd44 	movi	r2,-11
 4004f9c:	e0bfff15 	stw	r2,-4(fp)
 4004fa0:	00000b06 	br	4004fd0 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 4004fa4:	e0bffd17 	ldw	r2,-12(fp)
 4004fa8:	10c00d17 	ldw	r3,52(r2)
 4004fac:	e0bffd17 	ldw	r2,-12(fp)
 4004fb0:	10800c17 	ldw	r2,48(r2)
 4004fb4:	18800526 	beq	r3,r2,4004fcc <altera_avalon_jtag_uart_close+0x5c>
 4004fb8:	e0bffd17 	ldw	r2,-12(fp)
 4004fbc:	10c00917 	ldw	r3,36(r2)
 4004fc0:	e0bffd17 	ldw	r2,-12(fp)
 4004fc4:	10800117 	ldw	r2,4(r2)
 4004fc8:	18bfef36 	bltu	r3,r2,4004f88 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 4004fcc:	e03fff15 	stw	zero,-4(fp)
 4004fd0:	e0bfff17 	ldw	r2,-4(fp)
}
 4004fd4:	e037883a 	mov	sp,fp
 4004fd8:	df000017 	ldw	fp,0(sp)
 4004fdc:	dec00104 	addi	sp,sp,4
 4004fe0:	f800283a 	ret

04004fe4 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 4004fe4:	defff804 	addi	sp,sp,-32
 4004fe8:	df000715 	stw	fp,28(sp)
 4004fec:	df000704 	addi	fp,sp,28
 4004ff0:	e13ffb15 	stw	r4,-20(fp)
 4004ff4:	e17ffc15 	stw	r5,-16(fp)
 4004ff8:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 4004ffc:	00bff9c4 	movi	r2,-25
 4005000:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 4005004:	e0bffc17 	ldw	r2,-16(fp)
 4005008:	e0bfff15 	stw	r2,-4(fp)
 400500c:	e0ffff17 	ldw	r3,-4(fp)
 4005010:	189a8060 	cmpeqi	r2,r3,27137
 4005014:	1000041e 	bne	r2,zero,4005028 <altera_avalon_jtag_uart_ioctl+0x44>
 4005018:	e0ffff17 	ldw	r3,-4(fp)
 400501c:	189a80a0 	cmpeqi	r2,r3,27138
 4005020:	10001b1e 	bne	r2,zero,4005090 <altera_avalon_jtag_uart_ioctl+0xac>
 4005024:	00002706 	br	40050c4 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 4005028:	e0bffb17 	ldw	r2,-20(fp)
 400502c:	10c00117 	ldw	r3,4(r2)
 4005030:	00a00034 	movhi	r2,32768
 4005034:	10bfffc4 	addi	r2,r2,-1
 4005038:	18802226 	beq	r3,r2,40050c4 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 400503c:	e0bffd17 	ldw	r2,-12(fp)
 4005040:	10800017 	ldw	r2,0(r2)
 4005044:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 4005048:	e0bff917 	ldw	r2,-28(fp)
 400504c:	10800090 	cmplti	r2,r2,2
 4005050:	1000071e 	bne	r2,zero,4005070 <altera_avalon_jtag_uart_ioctl+0x8c>
 4005054:	e0fff917 	ldw	r3,-28(fp)
 4005058:	00a00034 	movhi	r2,32768
 400505c:	10bfffc4 	addi	r2,r2,-1
 4005060:	18800326 	beq	r3,r2,4005070 <altera_avalon_jtag_uart_ioctl+0x8c>
 4005064:	e0bff917 	ldw	r2,-28(fp)
 4005068:	e0bffe15 	stw	r2,-8(fp)
 400506c:	00000306 	br	400507c <altera_avalon_jtag_uart_ioctl+0x98>
 4005070:	00e00034 	movhi	r3,32768
 4005074:	18ffff84 	addi	r3,r3,-2
 4005078:	e0fffe15 	stw	r3,-8(fp)
 400507c:	e0bffb17 	ldw	r2,-20(fp)
 4005080:	e0fffe17 	ldw	r3,-8(fp)
 4005084:	10c00115 	stw	r3,4(r2)
      rc = 0;
 4005088:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 400508c:	00000d06 	br	40050c4 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 4005090:	e0bffb17 	ldw	r2,-20(fp)
 4005094:	10c00117 	ldw	r3,4(r2)
 4005098:	00a00034 	movhi	r2,32768
 400509c:	10bfffc4 	addi	r2,r2,-1
 40050a0:	18800826 	beq	r3,r2,40050c4 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 40050a4:	e13ffd17 	ldw	r4,-12(fp)
 40050a8:	e0bffb17 	ldw	r2,-20(fp)
 40050ac:	10c00917 	ldw	r3,36(r2)
 40050b0:	e0bffb17 	ldw	r2,-20(fp)
 40050b4:	10800117 	ldw	r2,4(r2)
 40050b8:	1885803a 	cmpltu	r2,r3,r2
 40050bc:	20800015 	stw	r2,0(r4)
      rc = 0;
 40050c0:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 40050c4:	e0bffa17 	ldw	r2,-24(fp)
}
 40050c8:	e037883a 	mov	sp,fp
 40050cc:	df000017 	ldw	fp,0(sp)
 40050d0:	dec00104 	addi	sp,sp,4
 40050d4:	f800283a 	ret

040050d8 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 40050d8:	defff204 	addi	sp,sp,-56
 40050dc:	dfc00d15 	stw	ra,52(sp)
 40050e0:	df000c15 	stw	fp,48(sp)
 40050e4:	df000c04 	addi	fp,sp,48
 40050e8:	e13ffb15 	stw	r4,-20(fp)
 40050ec:	e17ffc15 	stw	r5,-16(fp)
 40050f0:	e1bffd15 	stw	r6,-12(fp)
 40050f4:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 40050f8:	e0bffc17 	ldw	r2,-16(fp)
 40050fc:	e0bffa15 	stw	r2,-24(fp)
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 4005100:	00004806 	br	4005224 <altera_avalon_jtag_uart_read+0x14c>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 4005104:	e0bffb17 	ldw	r2,-20(fp)
 4005108:	10800a17 	ldw	r2,40(r2)
 400510c:	e0bff715 	stw	r2,-36(fp)
      out = sp->rx_out;
 4005110:	e0bffb17 	ldw	r2,-20(fp)
 4005114:	10800b17 	ldw	r2,44(r2)
 4005118:	e0bff615 	stw	r2,-40(fp)

      if (in >= out)
 400511c:	e0fff717 	ldw	r3,-36(fp)
 4005120:	e0bff617 	ldw	r2,-40(fp)
 4005124:	18800536 	bltu	r3,r2,400513c <altera_avalon_jtag_uart_read+0x64>
        n = in - out;
 4005128:	e0bff717 	ldw	r2,-36(fp)
 400512c:	e0fff617 	ldw	r3,-40(fp)
 4005130:	10c5c83a 	sub	r2,r2,r3
 4005134:	e0bff815 	stw	r2,-32(fp)
 4005138:	00000406 	br	400514c <altera_avalon_jtag_uart_read+0x74>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 400513c:	00820004 	movi	r2,2048
 4005140:	e0fff617 	ldw	r3,-40(fp)
 4005144:	10c5c83a 	sub	r2,r2,r3
 4005148:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 400514c:	e0bff817 	ldw	r2,-32(fp)
 4005150:	1005003a 	cmpeq	r2,r2,zero
 4005154:	10001f1e 	bne	r2,zero,40051d4 <altera_avalon_jtag_uart_read+0xfc>
        break; /* No more data available */

      if (n > space)
 4005158:	e0fffd17 	ldw	r3,-12(fp)
 400515c:	e0bff817 	ldw	r2,-32(fp)
 4005160:	1880022e 	bgeu	r3,r2,400516c <altera_avalon_jtag_uart_read+0x94>
        n = space;
 4005164:	e0bffd17 	ldw	r2,-12(fp)
 4005168:	e0bff815 	stw	r2,-32(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 400516c:	e0bffb17 	ldw	r2,-20(fp)
 4005170:	10c00e04 	addi	r3,r2,56
 4005174:	e0bff617 	ldw	r2,-40(fp)
 4005178:	1887883a 	add	r3,r3,r2
 400517c:	e0bffa17 	ldw	r2,-24(fp)
 4005180:	1009883a 	mov	r4,r2
 4005184:	180b883a 	mov	r5,r3
 4005188:	e1bff817 	ldw	r6,-32(fp)
 400518c:	4003eb40 	call	4003eb4 <memcpy>
      ptr   += n;
 4005190:	e0fff817 	ldw	r3,-32(fp)
 4005194:	e0bffa17 	ldw	r2,-24(fp)
 4005198:	10c5883a 	add	r2,r2,r3
 400519c:	e0bffa15 	stw	r2,-24(fp)
      space -= n;
 40051a0:	e0fffd17 	ldw	r3,-12(fp)
 40051a4:	e0bff817 	ldw	r2,-32(fp)
 40051a8:	1885c83a 	sub	r2,r3,r2
 40051ac:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40051b0:	e0fff617 	ldw	r3,-40(fp)
 40051b4:	e0bff817 	ldw	r2,-32(fp)
 40051b8:	1885883a 	add	r2,r3,r2
 40051bc:	10c1ffcc 	andi	r3,r2,2047
 40051c0:	e0bffb17 	ldw	r2,-20(fp)
 40051c4:	10c00b15 	stw	r3,44(r2)
    }
    while (space > 0);
 40051c8:	e0bffd17 	ldw	r2,-12(fp)
 40051cc:	10800048 	cmpgei	r2,r2,1
 40051d0:	103fcc1e 	bne	r2,zero,4005104 <altera_avalon_jtag_uart_read+0x2c>

    /* If we read any data then return it */
    if (ptr != buffer)
 40051d4:	e0fffa17 	ldw	r3,-24(fp)
 40051d8:	e0bffc17 	ldw	r2,-16(fp)
 40051dc:	1880141e 	bne	r3,r2,4005230 <altera_avalon_jtag_uart_read+0x158>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 40051e0:	e0bffe17 	ldw	r2,-8(fp)
 40051e4:	1090000c 	andi	r2,r2,16384
 40051e8:	1004c03a 	cmpne	r2,r2,zero
 40051ec:	1000101e 	bne	r2,zero,4005230 <altera_avalon_jtag_uart_read+0x158>
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
        ;
    }
#else
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 40051f0:	e0bffb17 	ldw	r2,-20(fp)
 40051f4:	10c00a17 	ldw	r3,40(r2)
 40051f8:	e0bff717 	ldw	r2,-36(fp)
 40051fc:	1880051e 	bne	r3,r2,4005214 <altera_avalon_jtag_uart_read+0x13c>
 4005200:	e0bffb17 	ldw	r2,-20(fp)
 4005204:	10c00917 	ldw	r3,36(r2)
 4005208:	e0bffb17 	ldw	r2,-20(fp)
 400520c:	10800117 	ldw	r2,4(r2)
 4005210:	18bff736 	bltu	r3,r2,40051f0 <altera_avalon_jtag_uart_read+0x118>
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 4005214:	e0bffb17 	ldw	r2,-20(fp)
 4005218:	10c00a17 	ldw	r3,40(r2)
 400521c:	e0bff717 	ldw	r2,-36(fp)
 4005220:	18800326 	beq	r3,r2,4005230 <altera_avalon_jtag_uart_read+0x158>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 4005224:	e0bffd17 	ldw	r2,-12(fp)
 4005228:	10800048 	cmpgei	r2,r2,1
 400522c:	103fb51e 	bne	r2,zero,4005104 <altera_avalon_jtag_uart_read+0x2c>
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);

  if (ptr != buffer)
 4005230:	e0fffa17 	ldw	r3,-24(fp)
 4005234:	e0bffc17 	ldw	r2,-16(fp)
 4005238:	18801926 	beq	r3,r2,40052a0 <altera_avalon_jtag_uart_read+0x1c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 400523c:	0005303a 	rdctl	r2,status
 4005240:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005244:	e0fff517 	ldw	r3,-44(fp)
 4005248:	00bfff84 	movi	r2,-2
 400524c:	1884703a 	and	r2,r3,r2
 4005250:	1001703a 	wrctl	status,r2
  
  return context;
 4005254:	e0bff517 	ldw	r2,-44(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 4005258:	e0bff915 	stw	r2,-28(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 400525c:	e0bffb17 	ldw	r2,-20(fp)
 4005260:	10800817 	ldw	r2,32(r2)
 4005264:	10c00054 	ori	r3,r2,1
 4005268:	e0bffb17 	ldw	r2,-20(fp)
 400526c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4005270:	e0bffb17 	ldw	r2,-20(fp)
 4005274:	10800017 	ldw	r2,0(r2)
 4005278:	11000104 	addi	r4,r2,4
 400527c:	e0bffb17 	ldw	r2,-20(fp)
 4005280:	10800817 	ldw	r2,32(r2)
 4005284:	1007883a 	mov	r3,r2
 4005288:	2005883a 	mov	r2,r4
 400528c:	10c00035 	stwio	r3,0(r2)
 4005290:	e0bff917 	ldw	r2,-28(fp)
 4005294:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4005298:	e0bff417 	ldw	r2,-48(fp)
 400529c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 40052a0:	e0fffa17 	ldw	r3,-24(fp)
 40052a4:	e0bffc17 	ldw	r2,-16(fp)
 40052a8:	18800526 	beq	r3,r2,40052c0 <altera_avalon_jtag_uart_read+0x1e8>
    return ptr - buffer;
 40052ac:	e0fffa17 	ldw	r3,-24(fp)
 40052b0:	e0bffc17 	ldw	r2,-16(fp)
 40052b4:	1887c83a 	sub	r3,r3,r2
 40052b8:	e0ffff15 	stw	r3,-4(fp)
 40052bc:	00000906 	br	40052e4 <altera_avalon_jtag_uart_read+0x20c>
  else if (flags & O_NONBLOCK)
 40052c0:	e0bffe17 	ldw	r2,-8(fp)
 40052c4:	1090000c 	andi	r2,r2,16384
 40052c8:	1005003a 	cmpeq	r2,r2,zero
 40052cc:	1000031e 	bne	r2,zero,40052dc <altera_avalon_jtag_uart_read+0x204>
    return -EWOULDBLOCK;
 40052d0:	00bffd44 	movi	r2,-11
 40052d4:	e0bfff15 	stw	r2,-4(fp)
 40052d8:	00000206 	br	40052e4 <altera_avalon_jtag_uart_read+0x20c>
  else
    return -EIO;
 40052dc:	00bffec4 	movi	r2,-5
 40052e0:	e0bfff15 	stw	r2,-4(fp)
 40052e4:	e0bfff17 	ldw	r2,-4(fp)
}
 40052e8:	e037883a 	mov	sp,fp
 40052ec:	dfc00117 	ldw	ra,4(sp)
 40052f0:	df000017 	ldw	fp,0(sp)
 40052f4:	dec00204 	addi	sp,sp,8
 40052f8:	f800283a 	ret

040052fc <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 40052fc:	defff204 	addi	sp,sp,-56
 4005300:	dfc00d15 	stw	ra,52(sp)
 4005304:	df000c15 	stw	fp,48(sp)
 4005308:	df000c04 	addi	fp,sp,48
 400530c:	e13ffb15 	stw	r4,-20(fp)
 4005310:	e17ffc15 	stw	r5,-16(fp)
 4005314:	e1bffd15 	stw	r6,-12(fp)
 4005318:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 400531c:	e03ff915 	stw	zero,-28(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 4005320:	e0bffc17 	ldw	r2,-16(fp)
 4005324:	e0bff615 	stw	r2,-40(fp)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 4005328:	00003a06 	br	4005414 <altera_avalon_jtag_uart_write+0x118>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 400532c:	e0bffb17 	ldw	r2,-20(fp)
 4005330:	10800c17 	ldw	r2,48(r2)
 4005334:	e0bffa15 	stw	r2,-24(fp)
      out = sp->tx_out;
 4005338:	e0bffb17 	ldw	r2,-20(fp)
 400533c:	10800d17 	ldw	r2,52(r2)
 4005340:	e0bff915 	stw	r2,-28(fp)

      if (in < out)
 4005344:	e0fffa17 	ldw	r3,-24(fp)
 4005348:	e0bff917 	ldw	r2,-28(fp)
 400534c:	1880062e 	bgeu	r3,r2,4005368 <altera_avalon_jtag_uart_write+0x6c>
        n = out - 1 - in;
 4005350:	e0fff917 	ldw	r3,-28(fp)
 4005354:	e0bffa17 	ldw	r2,-24(fp)
 4005358:	1885c83a 	sub	r2,r3,r2
 400535c:	10bfffc4 	addi	r2,r2,-1
 4005360:	e0bff815 	stw	r2,-32(fp)
 4005364:	00000c06 	br	4005398 <altera_avalon_jtag_uart_write+0x9c>
      else if (out > 0)
 4005368:	e0bff917 	ldw	r2,-28(fp)
 400536c:	1005003a 	cmpeq	r2,r2,zero
 4005370:	1000051e 	bne	r2,zero,4005388 <altera_avalon_jtag_uart_write+0x8c>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 4005374:	00820004 	movi	r2,2048
 4005378:	e0fffa17 	ldw	r3,-24(fp)
 400537c:	10c5c83a 	sub	r2,r2,r3
 4005380:	e0bff815 	stw	r2,-32(fp)
 4005384:	00000406 	br	4005398 <altera_avalon_jtag_uart_write+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 4005388:	0081ffc4 	movi	r2,2047
 400538c:	e0fffa17 	ldw	r3,-24(fp)
 4005390:	10c5c83a 	sub	r2,r2,r3
 4005394:	e0bff815 	stw	r2,-32(fp)

      if (n == 0)
 4005398:	e0bff817 	ldw	r2,-32(fp)
 400539c:	1005003a 	cmpeq	r2,r2,zero
 40053a0:	10001f1e 	bne	r2,zero,4005420 <altera_avalon_jtag_uart_write+0x124>
        break;

      if (n > count)
 40053a4:	e0fffd17 	ldw	r3,-12(fp)
 40053a8:	e0bff817 	ldw	r2,-32(fp)
 40053ac:	1880022e 	bgeu	r3,r2,40053b8 <altera_avalon_jtag_uart_write+0xbc>
        n = count;
 40053b0:	e0bffd17 	ldw	r2,-12(fp)
 40053b4:	e0bff815 	stw	r2,-32(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 40053b8:	e0bffb17 	ldw	r2,-20(fp)
 40053bc:	10c20e04 	addi	r3,r2,2104
 40053c0:	e0bffa17 	ldw	r2,-24(fp)
 40053c4:	1885883a 	add	r2,r3,r2
 40053c8:	e0fffc17 	ldw	r3,-16(fp)
 40053cc:	1009883a 	mov	r4,r2
 40053d0:	180b883a 	mov	r5,r3
 40053d4:	e1bff817 	ldw	r6,-32(fp)
 40053d8:	4003eb40 	call	4003eb4 <memcpy>
      ptr   += n;
 40053dc:	e0fff817 	ldw	r3,-32(fp)
 40053e0:	e0bffc17 	ldw	r2,-16(fp)
 40053e4:	10c5883a 	add	r2,r2,r3
 40053e8:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 40053ec:	e0fffd17 	ldw	r3,-12(fp)
 40053f0:	e0bff817 	ldw	r2,-32(fp)
 40053f4:	1885c83a 	sub	r2,r3,r2
 40053f8:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 40053fc:	e0fffa17 	ldw	r3,-24(fp)
 4005400:	e0bff817 	ldw	r2,-32(fp)
 4005404:	1885883a 	add	r2,r3,r2
 4005408:	10c1ffcc 	andi	r3,r2,2047
 400540c:	e0bffb17 	ldw	r2,-20(fp)
 4005410:	10c00c15 	stw	r3,48(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 4005414:	e0bffd17 	ldw	r2,-12(fp)
 4005418:	10800048 	cmpgei	r2,r2,1
 400541c:	103fc31e 	bne	r2,zero,400532c <altera_avalon_jtag_uart_write+0x30>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4005420:	0005303a 	rdctl	r2,status
 4005424:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005428:	e0fff517 	ldw	r3,-44(fp)
 400542c:	00bfff84 	movi	r2,-2
 4005430:	1884703a 	and	r2,r3,r2
 4005434:	1001703a 	wrctl	status,r2
  
  return context;
 4005438:	e0bff517 	ldw	r2,-44(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 400543c:	e0bff715 	stw	r2,-36(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 4005440:	e0bffb17 	ldw	r2,-20(fp)
 4005444:	10800817 	ldw	r2,32(r2)
 4005448:	10c00094 	ori	r3,r2,2
 400544c:	e0bffb17 	ldw	r2,-20(fp)
 4005450:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 4005454:	e0bffb17 	ldw	r2,-20(fp)
 4005458:	10800017 	ldw	r2,0(r2)
 400545c:	11000104 	addi	r4,r2,4
 4005460:	e0bffb17 	ldw	r2,-20(fp)
 4005464:	10800817 	ldw	r2,32(r2)
 4005468:	1007883a 	mov	r3,r2
 400546c:	2005883a 	mov	r2,r4
 4005470:	10c00035 	stwio	r3,0(r2)
 4005474:	e0bff717 	ldw	r2,-36(fp)
 4005478:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 400547c:	e0bff417 	ldw	r2,-48(fp)
 4005480:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 4005484:	e0bffd17 	ldw	r2,-12(fp)
 4005488:	10800050 	cmplti	r2,r2,1
 400548c:	1000111e 	bne	r2,zero,40054d4 <altera_avalon_jtag_uart_write+0x1d8>
    {
      if (flags & O_NONBLOCK)
 4005490:	e0bffe17 	ldw	r2,-8(fp)
 4005494:	1090000c 	andi	r2,r2,16384
 4005498:	1004c03a 	cmpne	r2,r2,zero
 400549c:	1000101e 	bne	r2,zero,40054e0 <altera_avalon_jtag_uart_write+0x1e4>
      /*
       * No OS present: Always wait for data to be removed from buffer.  Once
       * the interrupt routine has removed some data then we will be able to
       * insert some more.
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 40054a0:	e0bffb17 	ldw	r2,-20(fp)
 40054a4:	10c00d17 	ldw	r3,52(r2)
 40054a8:	e0bff917 	ldw	r2,-28(fp)
 40054ac:	1880051e 	bne	r3,r2,40054c4 <altera_avalon_jtag_uart_write+0x1c8>
 40054b0:	e0bffb17 	ldw	r2,-20(fp)
 40054b4:	10c00917 	ldw	r3,36(r2)
 40054b8:	e0bffb17 	ldw	r2,-20(fp)
 40054bc:	10800117 	ldw	r2,4(r2)
 40054c0:	18bff736 	bltu	r3,r2,40054a0 <altera_avalon_jtag_uart_write+0x1a4>
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 40054c4:	e0bffb17 	ldw	r2,-20(fp)
 40054c8:	10c00d17 	ldw	r3,52(r2)
 40054cc:	e0bff917 	ldw	r2,-28(fp)
 40054d0:	18800326 	beq	r3,r2,40054e0 <altera_avalon_jtag_uart_write+0x1e4>
         break;
    }
  }
  while (count > 0);
 40054d4:	e0bffd17 	ldw	r2,-12(fp)
 40054d8:	10800048 	cmpgei	r2,r2,1
 40054dc:	103fcd1e 	bne	r2,zero,4005414 <altera_avalon_jtag_uart_write+0x118>
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);

  if (ptr != start)
 40054e0:	e0fffc17 	ldw	r3,-16(fp)
 40054e4:	e0bff617 	ldw	r2,-40(fp)
 40054e8:	18800526 	beq	r3,r2,4005500 <altera_avalon_jtag_uart_write+0x204>
    return ptr - start;
 40054ec:	e0fffc17 	ldw	r3,-16(fp)
 40054f0:	e0bff617 	ldw	r2,-40(fp)
 40054f4:	1887c83a 	sub	r3,r3,r2
 40054f8:	e0ffff15 	stw	r3,-4(fp)
 40054fc:	00000906 	br	4005524 <altera_avalon_jtag_uart_write+0x228>
  else if (flags & O_NONBLOCK)
 4005500:	e0bffe17 	ldw	r2,-8(fp)
 4005504:	1090000c 	andi	r2,r2,16384
 4005508:	1005003a 	cmpeq	r2,r2,zero
 400550c:	1000031e 	bne	r2,zero,400551c <altera_avalon_jtag_uart_write+0x220>
    return -EWOULDBLOCK;
 4005510:	00bffd44 	movi	r2,-11
 4005514:	e0bfff15 	stw	r2,-4(fp)
 4005518:	00000206 	br	4005524 <altera_avalon_jtag_uart_write+0x228>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 400551c:	00bffec4 	movi	r2,-5
 4005520:	e0bfff15 	stw	r2,-4(fp)
 4005524:	e0bfff17 	ldw	r2,-4(fp)
}
 4005528:	e037883a 	mov	sp,fp
 400552c:	dfc00117 	ldw	ra,4(sp)
 4005530:	df000017 	ldw	fp,0(sp)
 4005534:	dec00204 	addi	sp,sp,8
 4005538:	f800283a 	ret

0400553c <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 400553c:	defff404 	addi	sp,sp,-48
 4005540:	df000b15 	stw	fp,44(sp)
 4005544:	df000b04 	addi	fp,sp,44
 4005548:	e13ffc15 	stw	r4,-16(fp)
 400554c:	e17ffd15 	stw	r5,-12(fp)
 4005550:	e1bffe15 	stw	r6,-8(fp)
 4005554:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 4005558:	e0fffe17 	ldw	r3,-8(fp)
 400555c:	e0bfff17 	ldw	r2,-4(fp)
 4005560:	10c5883a 	add	r2,r2,r3
 4005564:	e0bffb15 	stw	r2,-20(fp)
  alt_u8 * read_end = read_data + read_length;
 4005568:	e0c00117 	ldw	r3,4(fp)
 400556c:	e0800217 	ldw	r2,8(fp)
 4005570:	10c5883a 	add	r2,r2,r3
 4005574:	e0bffa15 	stw	r2,-24(fp)

  alt_u32 write_zeros = read_length;
 4005578:	e0800117 	ldw	r2,4(fp)
 400557c:	e0bff915 	stw	r2,-28(fp)
  alt_u32 read_ignore = write_length;
 4005580:	e0bffe17 	ldw	r2,-8(fp)
 4005584:	e0bff815 	stw	r2,-32(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 4005588:	00800044 	movi	r2,1
 400558c:	e0bff615 	stw	r2,-40(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 4005590:	e0bffc17 	ldw	r2,-16(fp)
 4005594:	11000504 	addi	r4,r2,20
 4005598:	e0fffd17 	ldw	r3,-12(fp)
 400559c:	00800044 	movi	r2,1
 40055a0:	10c6983a 	sll	r3,r2,r3
 40055a4:	2005883a 	mov	r2,r4
 40055a8:	10c00035 	stwio	r3,0(r2)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 40055ac:	e0800317 	ldw	r2,12(fp)
 40055b0:	1080008c 	andi	r2,r2,2
 40055b4:	1004c03a 	cmpne	r2,r2,zero
 40055b8:	1000051e 	bne	r2,zero,40055d0 <alt_avalon_spi_command+0x94>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 40055bc:	e0bffc17 	ldw	r2,-16(fp)
 40055c0:	10800304 	addi	r2,r2,12
 40055c4:	1007883a 	mov	r3,r2
 40055c8:	00810004 	movi	r2,1024
 40055cc:	18800035 	stwio	r2,0(r3)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 40055d0:	e0bffc17 	ldw	r2,-16(fp)
 40055d4:	10800037 	ldwio	r2,0(r2)
 40055d8:	00000006 	br	40055dc <alt_avalon_spi_command+0xa0>
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 40055dc:	e0bffc17 	ldw	r2,-16(fp)
 40055e0:	10800204 	addi	r2,r2,8
 40055e4:	10800037 	ldwio	r2,0(r2)
 40055e8:	e0bff715 	stw	r2,-36(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 40055ec:	e0bff717 	ldw	r2,-36(fp)
 40055f0:	1080100c 	andi	r2,r2,64
 40055f4:	1005003a 	cmpeq	r2,r2,zero
 40055f8:	1000031e 	bne	r2,zero,4005608 <alt_avalon_spi_command+0xcc>
 40055fc:	e0bff617 	ldw	r2,-40(fp)
 4005600:	1004c03a 	cmpne	r2,r2,zero
 4005604:	1000041e 	bne	r2,zero,4005618 <alt_avalon_spi_command+0xdc>
 4005608:	e0bff717 	ldw	r2,-36(fp)
 400560c:	1080200c 	andi	r2,r2,128
 4005610:	1005003a 	cmpeq	r2,r2,zero
 4005614:	103ff11e 	bne	r2,zero,40055dc <alt_avalon_spi_command+0xa0>

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 4005618:	e0bff717 	ldw	r2,-36(fp)
 400561c:	1080100c 	andi	r2,r2,64
 4005620:	1005003a 	cmpeq	r2,r2,zero
 4005624:	1000201e 	bne	r2,zero,40056a8 <alt_avalon_spi_command+0x16c>
 4005628:	e0bff617 	ldw	r2,-40(fp)
 400562c:	10800050 	cmplti	r2,r2,1
 4005630:	10001d1e 	bne	r2,zero,40056a8 <alt_avalon_spi_command+0x16c>
    {
      credits--;
 4005634:	e0bff617 	ldw	r2,-40(fp)
 4005638:	10bfffc4 	addi	r2,r2,-1
 400563c:	e0bff615 	stw	r2,-40(fp)

      if (write_data < write_end)
 4005640:	e0ffff17 	ldw	r3,-4(fp)
 4005644:	e0bffb17 	ldw	r2,-20(fp)
 4005648:	18800b2e 	bgeu	r3,r2,4005678 <alt_avalon_spi_command+0x13c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 400564c:	e0bffc17 	ldw	r2,-16(fp)
 4005650:	11000104 	addi	r4,r2,4
 4005654:	e0bfff17 	ldw	r2,-4(fp)
 4005658:	10800003 	ldbu	r2,0(r2)
 400565c:	10c03fcc 	andi	r3,r2,255
 4005660:	e0bfff17 	ldw	r2,-4(fp)
 4005664:	10800044 	addi	r2,r2,1
 4005668:	e0bfff15 	stw	r2,-4(fp)
 400566c:	2005883a 	mov	r2,r4
 4005670:	10c00035 	stwio	r3,0(r2)
 4005674:	00000c06 	br	40056a8 <alt_avalon_spi_command+0x16c>
      else if (write_zeros > 0)
 4005678:	e0bff917 	ldw	r2,-28(fp)
 400567c:	1005003a 	cmpeq	r2,r2,zero
 4005680:	1000071e 	bne	r2,zero,40056a0 <alt_avalon_spi_command+0x164>
      {
        write_zeros--;
 4005684:	e0bff917 	ldw	r2,-28(fp)
 4005688:	10bfffc4 	addi	r2,r2,-1
 400568c:	e0bff915 	stw	r2,-28(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 4005690:	e0bffc17 	ldw	r2,-16(fp)
 4005694:	10800104 	addi	r2,r2,4
 4005698:	10000035 	stwio	zero,0(r2)
 400569c:	00000206 	br	40056a8 <alt_avalon_spi_command+0x16c>
      }
      else
        credits = -1024;
 40056a0:	00bf0004 	movi	r2,-1024
 40056a4:	e0bff615 	stw	r2,-40(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 40056a8:	e0bff717 	ldw	r2,-36(fp)
 40056ac:	1080200c 	andi	r2,r2,128
 40056b0:	1005003a 	cmpeq	r2,r2,zero
 40056b4:	103fc91e 	bne	r2,zero,40055dc <alt_avalon_spi_command+0xa0>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 40056b8:	e0bffc17 	ldw	r2,-16(fp)
 40056bc:	10800037 	ldwio	r2,0(r2)
 40056c0:	e0bff515 	stw	r2,-44(fp)

      if (read_ignore > 0)
 40056c4:	e0bff817 	ldw	r2,-32(fp)
 40056c8:	1005003a 	cmpeq	r2,r2,zero
 40056cc:	1000041e 	bne	r2,zero,40056e0 <alt_avalon_spi_command+0x1a4>
        read_ignore--;
 40056d0:	e0bff817 	ldw	r2,-32(fp)
 40056d4:	10bfffc4 	addi	r2,r2,-1
 40056d8:	e0bff815 	stw	r2,-32(fp)
 40056dc:	00000706 	br	40056fc <alt_avalon_spi_command+0x1c0>
      else
        *read_data++ = (alt_u8)rxdata;
 40056e0:	e0bff517 	ldw	r2,-44(fp)
 40056e4:	1007883a 	mov	r3,r2
 40056e8:	e0800217 	ldw	r2,8(fp)
 40056ec:	10c00005 	stb	r3,0(r2)
 40056f0:	e0800217 	ldw	r2,8(fp)
 40056f4:	10800044 	addi	r2,r2,1
 40056f8:	e0800215 	stw	r2,8(fp)
      credits++;
 40056fc:	e0bff617 	ldw	r2,-40(fp)
 4005700:	10800044 	addi	r2,r2,1
 4005704:	e0bff615 	stw	r2,-40(fp)

      if (read_ignore == 0 && read_data == read_end)
 4005708:	e0bff817 	ldw	r2,-32(fp)
 400570c:	1004c03a 	cmpne	r2,r2,zero
 4005710:	103fb21e 	bne	r2,zero,40055dc <alt_avalon_spi_command+0xa0>
 4005714:	e0c00217 	ldw	r3,8(fp)
 4005718:	e0bffa17 	ldw	r2,-24(fp)
 400571c:	18800126 	beq	r3,r2,4005724 <alt_avalon_spi_command+0x1e8>
        break;
    }
    
  }
 4005720:	003fae06 	br	40055dc <alt_avalon_spi_command+0xa0>

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 4005724:	e0bffc17 	ldw	r2,-16(fp)
 4005728:	10800204 	addi	r2,r2,8
 400572c:	10800037 	ldwio	r2,0(r2)
 4005730:	e0bff715 	stw	r2,-36(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 4005734:	e0bff717 	ldw	r2,-36(fp)
 4005738:	1080080c 	andi	r2,r2,32
 400573c:	1005003a 	cmpeq	r2,r2,zero
 4005740:	103ff81e 	bne	r2,zero,4005724 <alt_avalon_spi_command+0x1e8>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 4005744:	e0800317 	ldw	r2,12(fp)
 4005748:	1080004c 	andi	r2,r2,1
 400574c:	1004c03a 	cmpne	r2,r2,zero
 4005750:	1000031e 	bne	r2,zero,4005760 <alt_avalon_spi_command+0x224>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 4005754:	e0bffc17 	ldw	r2,-16(fp)
 4005758:	10800304 	addi	r2,r2,12
 400575c:	10000035 	stwio	zero,0(r2)

  return read_length;
 4005760:	e0800117 	ldw	r2,4(fp)
}
 4005764:	e037883a 	mov	sp,fp
 4005768:	df000017 	ldw	fp,0(sp)
 400576c:	dec00104 	addi	sp,sp,4
 4005770:	f800283a 	ret

04005774 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
 4005774:	defff904 	addi	sp,sp,-28
 4005778:	dfc00615 	stw	ra,24(sp)
 400577c:	df000515 	stw	fp,20(sp)
 4005780:	df000504 	addi	fp,sp,20
 4005784:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
 4005788:	00800144 	movi	r2,5
 400578c:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
 4005790:	00800044 	movi	r2,1
 4005794:	d8800015 	stw	r2,0(sp)
 4005798:	e0bffe44 	addi	r2,fp,-7
 400579c:	d8800115 	stw	r2,4(sp)
 40057a0:	d8000215 	stw	zero,8(sp)
 40057a4:	e13fff17 	ldw	r4,-4(fp)
 40057a8:	000b883a 	mov	r5,zero
 40057ac:	01800044 	movi	r6,1
 40057b0:	e1fffe04 	addi	r7,fp,-8
 40057b4:	400553c0 	call	400553c <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
 40057b8:	e0bffe43 	ldbu	r2,-7(fp)
 40057bc:	10803fcc 	andi	r2,r2,255
}
 40057c0:	e037883a 	mov	sp,fp
 40057c4:	dfc00117 	ldw	ra,4(sp)
 40057c8:	df000017 	ldw	fp,0(sp)
 40057cc:	dec00204 	addi	sp,sp,8
 40057d0:	f800283a 	ret

040057d4 <epcs_sector_erase>:
  {
  }
}

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
 40057d4:	defff604 	addi	sp,sp,-40
 40057d8:	dfc00915 	stw	ra,36(sp)
 40057dc:	df000815 	stw	fp,32(sp)
 40057e0:	df000804 	addi	fp,sp,32
 40057e4:	e13ffd15 	stw	r4,-12(fp)
 40057e8:	e17ffe15 	stw	r5,-8(fp)
 40057ec:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
 40057f0:	e0bfff17 	ldw	r2,-4(fp)
 40057f4:	1005003a 	cmpeq	r2,r2,zero
 40057f8:	1000121e 	bne	r2,zero,4005844 <epcs_sector_erase+0x70>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
 40057fc:	00bff604 	movi	r2,-40
 4005800:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
 4005804:	e0bffe17 	ldw	r2,-8(fp)
 4005808:	1004d63a 	srli	r2,r2,24
 400580c:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
 4005810:	e0bffe17 	ldw	r2,-8(fp)
 4005814:	1004d43a 	srli	r2,r2,16
 4005818:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
 400581c:	e0bffe17 	ldw	r2,-8(fp)
 4005820:	1004d23a 	srli	r2,r2,8
 4005824:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
 4005828:	e0bffe17 	ldw	r2,-8(fp)
 400582c:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
 4005830:	00800144 	movi	r2,5
 4005834:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
 4005838:	e13ffd17 	ldw	r4,-12(fp)
 400583c:	4005d980 	call	4005d98 <epcs_enter_4_bytes_mode>
 4005840:	00000c06 	br	4005874 <epcs_sector_erase+0xa0>
  }
  else
  {
      se[0] = epcs_se;
 4005844:	00bff604 	movi	r2,-40
 4005848:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
 400584c:	e0bffe17 	ldw	r2,-8(fp)
 4005850:	1004d43a 	srli	r2,r2,16
 4005854:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
 4005858:	e0bffe17 	ldw	r2,-8(fp)
 400585c:	1004d23a 	srli	r2,r2,8
 4005860:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
 4005864:	e0bffe17 	ldw	r2,-8(fp)
 4005868:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
 400586c:	00800104 	movi	r2,4
 4005870:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
 4005874:	e13ffd17 	ldw	r4,-12(fp)
 4005878:	4005a880 	call	4005a88 <epcs_write_enable>

  alt_avalon_spi_command(
 400587c:	e1bffb03 	ldbu	r6,-20(fp)
 4005880:	e1fffb44 	addi	r7,fp,-19
 4005884:	d8000015 	stw	zero,0(sp)
 4005888:	d8000115 	stw	zero,4(sp)
 400588c:	d8000215 	stw	zero,8(sp)
 4005890:	e13ffd17 	ldw	r4,-12(fp)
 4005894:	000b883a 	mov	r5,zero
 4005898:	400553c0 	call	400553c <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 400589c:	e13ffd17 	ldw	r4,-12(fp)
 40058a0:	40058cc0 	call	40058cc <epcs_await_wip_released>

  if(four_bytes_mode)
 40058a4:	e0bfff17 	ldw	r2,-4(fp)
 40058a8:	1005003a 	cmpeq	r2,r2,zero
 40058ac:	1000021e 	bne	r2,zero,40058b8 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
 40058b0:	e13ffd17 	ldw	r4,-12(fp)
 40058b4:	4005df00 	call	4005df0 <epcs_exit_4_bytes_mode>
  }
}
 40058b8:	e037883a 	mov	sp,fp
 40058bc:	dfc00117 	ldw	ra,4(sp)
 40058c0:	df000017 	ldw	fp,0(sp)
 40058c4:	dec00204 	addi	sp,sp,8
 40058c8:	f800283a 	ret

040058cc <epcs_await_wip_released>:
{
  return epcs_read_status_register(base) & 1;
}

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
 40058cc:	defffd04 	addi	sp,sp,-12
 40058d0:	dfc00215 	stw	ra,8(sp)
 40058d4:	df000115 	stw	fp,4(sp)
 40058d8:	df000104 	addi	fp,sp,4
 40058dc:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
 40058e0:	e13fff17 	ldw	r4,-4(fp)
 40058e4:	40059040 	call	4005904 <epcs_test_wip>
 40058e8:	1004c03a 	cmpne	r2,r2,zero
 40058ec:	103ffc1e 	bne	r2,zero,40058e0 <epcs_await_wip_released+0x14>
  {
  }
}
 40058f0:	e037883a 	mov	sp,fp
 40058f4:	dfc00117 	ldw	ra,4(sp)
 40058f8:	df000017 	ldw	fp,0(sp)
 40058fc:	dec00204 	addi	sp,sp,8
 4005900:	f800283a 	ret

04005904 <epcs_test_wip>:

  return status;
}

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
 4005904:	defffd04 	addi	sp,sp,-12
 4005908:	dfc00215 	stw	ra,8(sp)
 400590c:	df000115 	stw	fp,4(sp)
 4005910:	df000104 	addi	fp,sp,4
 4005914:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
 4005918:	e13fff17 	ldw	r4,-4(fp)
 400591c:	40057740 	call	4005774 <epcs_read_status_register>
 4005920:	10803fcc 	andi	r2,r2,255
 4005924:	1080004c 	andi	r2,r2,1
}
 4005928:	e037883a 	mov	sp,fp
 400592c:	dfc00117 	ldw	ra,4(sp)
 4005930:	df000017 	ldw	fp,0(sp)
 4005934:	dec00204 	addi	sp,sp,8
 4005938:	f800283a 	ret

0400593c <epcs_read_buffer>:
  }
}

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
 400593c:	defff404 	addi	sp,sp,-48
 4005940:	dfc00b15 	stw	ra,44(sp)
 4005944:	df000a15 	stw	fp,40(sp)
 4005948:	df000a04 	addi	fp,sp,40
 400594c:	e13ffc15 	stw	r4,-16(fp)
 4005950:	e17ffd15 	stw	r5,-12(fp)
 4005954:	e1bffe15 	stw	r6,-8(fp)
 4005958:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
 400595c:	008000c4 	movi	r2,3
 4005960:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 4005964:	e0800217 	ldw	r2,8(fp)
 4005968:	1005003a 	cmpeq	r2,r2,zero
 400596c:	10001c1e 	bne	r2,zero,40059e0 <epcs_read_buffer+0xa4>
  {
        read_command[1] = (offset >> 24) & 0xFF;
 4005970:	e0bffd17 	ldw	r2,-12(fp)
 4005974:	1005d63a 	srai	r2,r2,24
 4005978:	1007883a 	mov	r3,r2
 400597c:	00bfffc4 	movi	r2,-1
 4005980:	1884703a 	and	r2,r3,r2
 4005984:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
 4005988:	e0bffd17 	ldw	r2,-12(fp)
 400598c:	1005d43a 	srai	r2,r2,16
 4005990:	1007883a 	mov	r3,r2
 4005994:	00bfffc4 	movi	r2,-1
 4005998:	1884703a 	and	r2,r3,r2
 400599c:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
 40059a0:	e0bffd17 	ldw	r2,-12(fp)
 40059a4:	1005d23a 	srai	r2,r2,8
 40059a8:	1007883a 	mov	r3,r2
 40059ac:	00bfffc4 	movi	r2,-1
 40059b0:	1884703a 	and	r2,r3,r2
 40059b4:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
 40059b8:	e0bffd17 	ldw	r2,-12(fp)
 40059bc:	1007883a 	mov	r3,r2
 40059c0:	00bfffc4 	movi	r2,-1
 40059c4:	1884703a 	and	r2,r3,r2
 40059c8:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
 40059cc:	00800144 	movi	r2,5
 40059d0:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
 40059d4:	e13ffc17 	ldw	r4,-16(fp)
 40059d8:	4005d980 	call	4005d98 <epcs_enter_4_bytes_mode>
 40059dc:	00001306 	br	4005a2c <epcs_read_buffer+0xf0>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
 40059e0:	e0bffd17 	ldw	r2,-12(fp)
 40059e4:	1005d43a 	srai	r2,r2,16
 40059e8:	1007883a 	mov	r3,r2
 40059ec:	00bfffc4 	movi	r2,-1
 40059f0:	1884703a 	and	r2,r3,r2
 40059f4:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
 40059f8:	e0bffd17 	ldw	r2,-12(fp)
 40059fc:	1005d23a 	srai	r2,r2,8
 4005a00:	1007883a 	mov	r3,r2
 4005a04:	00bfffc4 	movi	r2,-1
 4005a08:	1884703a 	and	r2,r3,r2
 4005a0c:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
 4005a10:	e0bffd17 	ldw	r2,-12(fp)
 4005a14:	1007883a 	mov	r3,r2
 4005a18:	00bfffc4 	movi	r2,-1
 4005a1c:	1884703a 	and	r2,r3,r2
 4005a20:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
 4005a24:	00800104 	movi	r2,4
 4005a28:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
 4005a2c:	e13ffc17 	ldw	r4,-16(fp)
 4005a30:	40058cc0 	call	40058cc <epcs_await_wip_released>

  alt_avalon_spi_command(
 4005a34:	e0bfff17 	ldw	r2,-4(fp)
 4005a38:	e1fffa04 	addi	r7,fp,-24
 4005a3c:	d8800015 	stw	r2,0(sp)
 4005a40:	e0bffe17 	ldw	r2,-8(fp)
 4005a44:	d8800115 	stw	r2,4(sp)
 4005a48:	d8000215 	stw	zero,8(sp)
 4005a4c:	e13ffc17 	ldw	r4,-16(fp)
 4005a50:	000b883a 	mov	r5,zero
 4005a54:	e1bff917 	ldw	r6,-28(fp)
 4005a58:	400553c0 	call	400553c <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
 4005a5c:	e0800217 	ldw	r2,8(fp)
 4005a60:	1005003a 	cmpeq	r2,r2,zero
 4005a64:	1000021e 	bne	r2,zero,4005a70 <epcs_read_buffer+0x134>
  {
    epcs_exit_4_bytes_mode(base);
 4005a68:	e13ffc17 	ldw	r4,-16(fp)
 4005a6c:	4005df00 	call	4005df0 <epcs_exit_4_bytes_mode>
  }

  return length;
 4005a70:	e0bfff17 	ldw	r2,-4(fp)
}
 4005a74:	e037883a 	mov	sp,fp
 4005a78:	dfc00117 	ldw	ra,4(sp)
 4005a7c:	df000017 	ldw	fp,0(sp)
 4005a80:	dec00204 	addi	sp,sp,8
 4005a84:	f800283a 	ret

04005a88 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
 4005a88:	defff904 	addi	sp,sp,-28
 4005a8c:	dfc00615 	stw	ra,24(sp)
 4005a90:	df000515 	stw	fp,20(sp)
 4005a94:	df000504 	addi	fp,sp,20
 4005a98:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
 4005a9c:	00800184 	movi	r2,6
 4005aa0:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
 4005aa4:	d8000015 	stw	zero,0(sp)
 4005aa8:	d8000115 	stw	zero,4(sp)
 4005aac:	d8000215 	stw	zero,8(sp)
 4005ab0:	e13fff17 	ldw	r4,-4(fp)
 4005ab4:	000b883a 	mov	r5,zero
 4005ab8:	01800044 	movi	r6,1
 4005abc:	e1fffe04 	addi	r7,fp,-8
 4005ac0:	400553c0 	call	400553c <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
 4005ac4:	e037883a 	mov	sp,fp
 4005ac8:	dfc00117 	ldw	ra,4(sp)
 4005acc:	df000017 	ldw	fp,0(sp)
 4005ad0:	dec00204 	addi	sp,sp,8
 4005ad4:	f800283a 	ret

04005ad8 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
 4005ad8:	defff804 	addi	sp,sp,-32
 4005adc:	dfc00715 	stw	ra,28(sp)
 4005ae0:	df000615 	stw	fp,24(sp)
 4005ae4:	df000604 	addi	fp,sp,24
 4005ae8:	e13ffe15 	stw	r4,-8(fp)
 4005aec:	e17fff05 	stb	r5,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
 4005af0:	00800044 	movi	r2,1
 4005af4:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
 4005af8:	e0bfff03 	ldbu	r2,-4(fp)
 4005afc:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
 4005b00:	d8000015 	stw	zero,0(sp)
 4005b04:	d8000115 	stw	zero,4(sp)
 4005b08:	d8000215 	stw	zero,8(sp)
 4005b0c:	e13ffe17 	ldw	r4,-8(fp)
 4005b10:	000b883a 	mov	r5,zero
 4005b14:	01800084 	movi	r6,2
 4005b18:	e1fffd04 	addi	r7,fp,-12
 4005b1c:	400553c0 	call	400553c <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 4005b20:	e13ffe17 	ldw	r4,-8(fp)
 4005b24:	40058cc0 	call	40058cc <epcs_await_wip_released>
}
 4005b28:	e037883a 	mov	sp,fp
 4005b2c:	dfc00117 	ldw	ra,4(sp)
 4005b30:	df000017 	ldw	fp,0(sp)
 4005b34:	dec00204 	addi	sp,sp,8
 4005b38:	f800283a 	ret

04005b3c <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
 4005b3c:	defff404 	addi	sp,sp,-48
 4005b40:	dfc00b15 	stw	ra,44(sp)
 4005b44:	df000a15 	stw	fp,40(sp)
 4005b48:	df000a04 	addi	fp,sp,40
 4005b4c:	e13ffc15 	stw	r4,-16(fp)
 4005b50:	e17ffd15 	stw	r5,-12(fp)
 4005b54:	e1bffe15 	stw	r6,-8(fp)
 4005b58:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
 4005b5c:	00800084 	movi	r2,2
 4005b60:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 4005b64:	e0800217 	ldw	r2,8(fp)
 4005b68:	1005003a 	cmpeq	r2,r2,zero
 4005b6c:	10001c1e 	bne	r2,zero,4005be0 <epcs_write_buffer+0xa4>
  {
      pp[1] = (offset >> 24) & 0xFF;
 4005b70:	e0bffd17 	ldw	r2,-12(fp)
 4005b74:	1005d63a 	srai	r2,r2,24
 4005b78:	1007883a 	mov	r3,r2
 4005b7c:	00bfffc4 	movi	r2,-1
 4005b80:	1884703a 	and	r2,r3,r2
 4005b84:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
 4005b88:	e0bffd17 	ldw	r2,-12(fp)
 4005b8c:	1005d43a 	srai	r2,r2,16
 4005b90:	1007883a 	mov	r3,r2
 4005b94:	00bfffc4 	movi	r2,-1
 4005b98:	1884703a 	and	r2,r3,r2
 4005b9c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
 4005ba0:	e0bffd17 	ldw	r2,-12(fp)
 4005ba4:	1005d23a 	srai	r2,r2,8
 4005ba8:	1007883a 	mov	r3,r2
 4005bac:	00bfffc4 	movi	r2,-1
 4005bb0:	1884703a 	and	r2,r3,r2
 4005bb4:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
 4005bb8:	e0bffd17 	ldw	r2,-12(fp)
 4005bbc:	1007883a 	mov	r3,r2
 4005bc0:	00bfffc4 	movi	r2,-1
 4005bc4:	1884703a 	and	r2,r3,r2
 4005bc8:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
 4005bcc:	00800144 	movi	r2,5
 4005bd0:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
 4005bd4:	e13ffc17 	ldw	r4,-16(fp)
 4005bd8:	4005d980 	call	4005d98 <epcs_enter_4_bytes_mode>
 4005bdc:	00001306 	br	4005c2c <epcs_write_buffer+0xf0>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
 4005be0:	e0bffd17 	ldw	r2,-12(fp)
 4005be4:	1005d43a 	srai	r2,r2,16
 4005be8:	1007883a 	mov	r3,r2
 4005bec:	00bfffc4 	movi	r2,-1
 4005bf0:	1884703a 	and	r2,r3,r2
 4005bf4:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
 4005bf8:	e0bffd17 	ldw	r2,-12(fp)
 4005bfc:	1005d23a 	srai	r2,r2,8
 4005c00:	1007883a 	mov	r3,r2
 4005c04:	00bfffc4 	movi	r2,-1
 4005c08:	1884703a 	and	r2,r3,r2
 4005c0c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
 4005c10:	e0bffd17 	ldw	r2,-12(fp)
 4005c14:	1007883a 	mov	r3,r2
 4005c18:	00bfffc4 	movi	r2,-1
 4005c1c:	1884703a 	and	r2,r3,r2
 4005c20:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
 4005c24:	00800104 	movi	r2,4
 4005c28:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
 4005c2c:	e13ffc17 	ldw	r4,-16(fp)
 4005c30:	4005a880 	call	4005a88 <epcs_write_enable>

  /* Send the PP command */
  alt_avalon_spi_command(
 4005c34:	e1fffa04 	addi	r7,fp,-24
 4005c38:	d8000015 	stw	zero,0(sp)
 4005c3c:	d8000115 	stw	zero,4(sp)
 4005c40:	00800044 	movi	r2,1
 4005c44:	d8800215 	stw	r2,8(sp)
 4005c48:	e13ffc17 	ldw	r4,-16(fp)
 4005c4c:	000b883a 	mov	r5,zero
 4005c50:	e1bff917 	ldw	r6,-28(fp)
 4005c54:	400553c0 	call	400553c <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
 4005c58:	e1bfff17 	ldw	r6,-4(fp)
 4005c5c:	d8000015 	stw	zero,0(sp)
 4005c60:	d8000115 	stw	zero,4(sp)
 4005c64:	d8000215 	stw	zero,8(sp)
 4005c68:	e13ffc17 	ldw	r4,-16(fp)
 4005c6c:	000b883a 	mov	r5,zero
 4005c70:	e1fffe17 	ldw	r7,-8(fp)
 4005c74:	400553c0 	call	400553c <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
 4005c78:	e13ffc17 	ldw	r4,-16(fp)
 4005c7c:	40058cc0 	call	40058cc <epcs_await_wip_released>

  if(four_bytes_mode)
 4005c80:	e0800217 	ldw	r2,8(fp)
 4005c84:	1005003a 	cmpeq	r2,r2,zero
 4005c88:	1000021e 	bne	r2,zero,4005c94 <epcs_write_buffer+0x158>
  {
    epcs_exit_4_bytes_mode(base);
 4005c8c:	e13ffc17 	ldw	r4,-16(fp)
 4005c90:	4005df00 	call	4005df0 <epcs_exit_4_bytes_mode>
  }

  return length;
 4005c94:	e0bfff17 	ldw	r2,-4(fp)
}
 4005c98:	e037883a 	mov	sp,fp
 4005c9c:	dfc00117 	ldw	ra,4(sp)
 4005ca0:	df000017 	ldw	fp,0(sp)
 4005ca4:	dec00204 	addi	sp,sp,8
 4005ca8:	f800283a 	ret

04005cac <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
 4005cac:	defff804 	addi	sp,sp,-32
 4005cb0:	dfc00715 	stw	ra,28(sp)
 4005cb4:	df000615 	stw	fp,24(sp)
 4005cb8:	df000604 	addi	fp,sp,24
 4005cbc:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
 4005cc0:	00bfeac4 	movi	r2,-85
 4005cc4:	e0bffd05 	stb	r2,-12(fp)
 4005cc8:	e03ffd45 	stb	zero,-11(fp)
 4005ccc:	e03ffd85 	stb	zero,-10(fp)
 4005cd0:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
 4005cd4:	00800044 	movi	r2,1
 4005cd8:	d8800015 	stw	r2,0(sp)
 4005cdc:	e0bffe04 	addi	r2,fp,-8
 4005ce0:	d8800115 	stw	r2,4(sp)
 4005ce4:	d8000215 	stw	zero,8(sp)
 4005ce8:	e13fff17 	ldw	r4,-4(fp)
 4005cec:	000b883a 	mov	r5,zero
 4005cf0:	01800104 	movi	r6,4
 4005cf4:	e1fffd04 	addi	r7,fp,-12
 4005cf8:	400553c0 	call	400553c <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
 4005cfc:	e0bffe03 	ldbu	r2,-8(fp)
 4005d00:	10803fcc 	andi	r2,r2,255
}
 4005d04:	e037883a 	mov	sp,fp
 4005d08:	dfc00117 	ldw	ra,4(sp)
 4005d0c:	df000017 	ldw	fp,0(sp)
 4005d10:	dec00204 	addi	sp,sp,8
 4005d14:	f800283a 	ret

04005d18 <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
 4005d18:	defff904 	addi	sp,sp,-28
 4005d1c:	dfc00615 	stw	ra,24(sp)
 4005d20:	df000515 	stw	fp,20(sp)
 4005d24:	df000504 	addi	fp,sp,20
 4005d28:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
 4005d2c:	00bfe7c4 	movi	r2,-97
 4005d30:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
 4005d34:	008000c4 	movi	r2,3
 4005d38:	d8800015 	stw	r2,0(sp)
 4005d3c:	e0bffe44 	addi	r2,fp,-7
 4005d40:	d8800115 	stw	r2,4(sp)
 4005d44:	d8000215 	stw	zero,8(sp)
 4005d48:	e13fff17 	ldw	r4,-4(fp)
 4005d4c:	000b883a 	mov	r5,zero
 4005d50:	01800044 	movi	r6,1
 4005d54:	e1fffe04 	addi	r7,fp,-8
 4005d58:	400553c0 	call	400553c <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
 4005d5c:	e0bffe43 	ldbu	r2,-7(fp)
 4005d60:	10803fcc 	andi	r2,r2,255
 4005d64:	1006943a 	slli	r3,r2,16
 4005d68:	e0bffe83 	ldbu	r2,-6(fp)
 4005d6c:	10803fcc 	andi	r2,r2,255
 4005d70:	1004923a 	slli	r2,r2,8
 4005d74:	1886b03a 	or	r3,r3,r2
 4005d78:	e0bffec3 	ldbu	r2,-5(fp)
 4005d7c:	10803fcc 	andi	r2,r2,255
 4005d80:	1884b03a 	or	r2,r3,r2
}
 4005d84:	e037883a 	mov	sp,fp
 4005d88:	dfc00117 	ldw	ra,4(sp)
 4005d8c:	df000017 	ldw	fp,0(sp)
 4005d90:	dec00204 	addi	sp,sp,8
 4005d94:	f800283a 	ret

04005d98 <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
 4005d98:	defff904 	addi	sp,sp,-28
 4005d9c:	dfc00615 	stw	ra,24(sp)
 4005da0:	df000515 	stw	fp,20(sp)
 4005da4:	df000504 	addi	fp,sp,20
 4005da8:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
 4005dac:	00bfedc4 	movi	r2,-73
 4005db0:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 4005db4:	e13fff17 	ldw	r4,-4(fp)
 4005db8:	4005a880 	call	4005a88 <epcs_write_enable>

  alt_avalon_spi_command(
 4005dbc:	d8000015 	stw	zero,0(sp)
 4005dc0:	d8000115 	stw	zero,4(sp)
 4005dc4:	d8000215 	stw	zero,8(sp)
 4005dc8:	e13fff17 	ldw	r4,-4(fp)
 4005dcc:	000b883a 	mov	r5,zero
 4005dd0:	01800044 	movi	r6,1
 4005dd4:	e1fffe04 	addi	r7,fp,-8
 4005dd8:	400553c0 	call	400553c <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
 4005ddc:	e037883a 	mov	sp,fp
 4005de0:	dfc00117 	ldw	ra,4(sp)
 4005de4:	df000017 	ldw	fp,0(sp)
 4005de8:	dec00204 	addi	sp,sp,8
 4005dec:	f800283a 	ret

04005df0 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
 4005df0:	defff904 	addi	sp,sp,-28
 4005df4:	dfc00615 	stw	ra,24(sp)
 4005df8:	df000515 	stw	fp,20(sp)
 4005dfc:	df000504 	addi	fp,sp,20
 4005e00:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
 4005e04:	00bffa44 	movi	r2,-23
 4005e08:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 4005e0c:	e13fff17 	ldw	r4,-4(fp)
 4005e10:	4005a880 	call	4005a88 <epcs_write_enable>

  alt_avalon_spi_command(
 4005e14:	d8000015 	stw	zero,0(sp)
 4005e18:	d8000115 	stw	zero,4(sp)
 4005e1c:	d8000215 	stw	zero,8(sp)
 4005e20:	e13fff17 	ldw	r4,-4(fp)
 4005e24:	000b883a 	mov	r5,zero
 4005e28:	01800044 	movi	r6,1
 4005e2c:	e1fffe04 	addi	r7,fp,-8
 4005e30:	400553c0 	call	400553c <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
 4005e34:	e037883a 	mov	sp,fp
 4005e38:	dfc00117 	ldw	ra,4(sp)
 4005e3c:	df000017 	ldw	fp,0(sp)
 4005e40:	dec00204 	addi	sp,sp,8
 4005e44:	f800283a 	ret

04005e48 <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 4005e48:	defff404 	addi	sp,sp,-48
 4005e4c:	df000b15 	stw	fp,44(sp)
 4005e50:	df000b04 	addi	fp,sp,44
 4005e54:	e13ffb15 	stw	r4,-20(fp)
 4005e58:	e17ffc15 	stw	r5,-16(fp)
 4005e5c:	e1bffd15 	stw	r6,-12(fp)
 4005e60:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 4005e64:	e03ff915 	stw	zero,-28(fp)
 4005e68:	00810074 	movhi	r2,1025
 4005e6c:	10a53804 	addi	r2,r2,-27424
 4005e70:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 4005e74:	1005003a 	cmpeq	r2,r2,zero
 4005e78:	1000411e 	bne	r2,zero,4005f80 <alt_alarm_start+0x138>
  {
    if (alarm)
 4005e7c:	e0bffb17 	ldw	r2,-20(fp)
 4005e80:	1005003a 	cmpeq	r2,r2,zero
 4005e84:	10003b1e 	bne	r2,zero,4005f74 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 4005e88:	e0fffb17 	ldw	r3,-20(fp)
 4005e8c:	e0bffd17 	ldw	r2,-12(fp)
 4005e90:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 4005e94:	e0fffb17 	ldw	r3,-20(fp)
 4005e98:	e0bffe17 	ldw	r2,-8(fp)
 4005e9c:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4005ea0:	0005303a 	rdctl	r2,status
 4005ea4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4005ea8:	e0fff817 	ldw	r3,-32(fp)
 4005eac:	00bfff84 	movi	r2,-2
 4005eb0:	1884703a 	and	r2,r3,r2
 4005eb4:	1001703a 	wrctl	status,r2
  
  return context;
 4005eb8:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 4005ebc:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 4005ec0:	00810074 	movhi	r2,1025
 4005ec4:	10a53904 	addi	r2,r2,-27420
 4005ec8:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 4005ecc:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 4005ed0:	e0fffc17 	ldw	r3,-16(fp)
 4005ed4:	e0bff917 	ldw	r2,-28(fp)
 4005ed8:	1885883a 	add	r2,r3,r2
 4005edc:	10c00044 	addi	r3,r2,1
 4005ee0:	e0bffb17 	ldw	r2,-20(fp)
 4005ee4:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 4005ee8:	e0bffb17 	ldw	r2,-20(fp)
 4005eec:	10c00217 	ldw	r3,8(r2)
 4005ef0:	e0bff917 	ldw	r2,-28(fp)
 4005ef4:	1880042e 	bgeu	r3,r2,4005f08 <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 4005ef8:	e0fffb17 	ldw	r3,-20(fp)
 4005efc:	00800044 	movi	r2,1
 4005f00:	18800405 	stb	r2,16(r3)
 4005f04:	00000206 	br	4005f10 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 4005f08:	e0bffb17 	ldw	r2,-20(fp)
 4005f0c:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 4005f10:	e0fffb17 	ldw	r3,-20(fp)
 4005f14:	00810074 	movhi	r2,1025
 4005f18:	10a52d04 	addi	r2,r2,-27468
 4005f1c:	e0bff615 	stw	r2,-40(fp)
 4005f20:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 4005f24:	e0fff717 	ldw	r3,-36(fp)
 4005f28:	e0bff617 	ldw	r2,-40(fp)
 4005f2c:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 4005f30:	e0bff617 	ldw	r2,-40(fp)
 4005f34:	10c00017 	ldw	r3,0(r2)
 4005f38:	e0bff717 	ldw	r2,-36(fp)
 4005f3c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 4005f40:	e0bff617 	ldw	r2,-40(fp)
 4005f44:	10c00017 	ldw	r3,0(r2)
 4005f48:	e0bff717 	ldw	r2,-36(fp)
 4005f4c:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 4005f50:	e0fff617 	ldw	r3,-40(fp)
 4005f54:	e0bff717 	ldw	r2,-36(fp)
 4005f58:	18800015 	stw	r2,0(r3)
 4005f5c:	e0bffa17 	ldw	r2,-24(fp)
 4005f60:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4005f64:	e0bff517 	ldw	r2,-44(fp)
 4005f68:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 4005f6c:	e03fff15 	stw	zero,-4(fp)
 4005f70:	00000506 	br	4005f88 <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 4005f74:	00bffa84 	movi	r2,-22
 4005f78:	e0bfff15 	stw	r2,-4(fp)
 4005f7c:	00000206 	br	4005f88 <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 4005f80:	00bfde84 	movi	r2,-134
 4005f84:	e0bfff15 	stw	r2,-4(fp)
 4005f88:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 4005f8c:	e037883a 	mov	sp,fp
 4005f90:	df000017 	ldw	fp,0(sp)
 4005f94:	dec00104 	addi	sp,sp,4
 4005f98:	f800283a 	ret

04005f9c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 4005f9c:	defffa04 	addi	sp,sp,-24
 4005fa0:	dfc00515 	stw	ra,20(sp)
 4005fa4:	df000415 	stw	fp,16(sp)
 4005fa8:	df000404 	addi	fp,sp,16
 4005fac:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 4005fb0:	008000c4 	movi	r2,3
 4005fb4:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 4005fb8:	e0fffc17 	ldw	r3,-16(fp)
 4005fbc:	008003f4 	movhi	r2,15
 4005fc0:	10909004 	addi	r2,r2,16960
 4005fc4:	188b383a 	mul	r5,r3,r2
 4005fc8:	0100bef4 	movhi	r4,763
 4005fcc:	213c2004 	addi	r4,r4,-3968
 4005fd0:	40075d00 	call	40075d0 <__udivsi3>
 4005fd4:	100b883a 	mov	r5,r2
 4005fd8:	01200034 	movhi	r4,32768
 4005fdc:	213fffc4 	addi	r4,r4,-1
 4005fe0:	40075d00 	call	40075d0 <__udivsi3>
 4005fe4:	100b883a 	mov	r5,r2
 4005fe8:	e13fff17 	ldw	r4,-4(fp)
 4005fec:	40075d00 	call	40075d0 <__udivsi3>
 4005ff0:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 4005ff4:	e0bffd17 	ldw	r2,-12(fp)
 4005ff8:	1005003a 	cmpeq	r2,r2,zero
 4005ffc:	1000281e 	bne	r2,zero,40060a0 <alt_busy_sleep+0x104>
  {
    for(i=0;i<big_loops;i++)
 4006000:	e03ffe15 	stw	zero,-8(fp)
 4006004:	00001606 	br	4006060 <alt_busy_sleep+0xc4>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 4006008:	00a00034 	movhi	r2,32768
 400600c:	10bfffc4 	addi	r2,r2,-1
 4006010:	10bfffc4 	addi	r2,r2,-1
 4006014:	103ffe1e 	bne	r2,zero,4006010 <alt_busy_sleep+0x74>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 4006018:	e0fffc17 	ldw	r3,-16(fp)
 400601c:	008003f4 	movhi	r2,15
 4006020:	10909004 	addi	r2,r2,16960
 4006024:	188b383a 	mul	r5,r3,r2
 4006028:	0100bef4 	movhi	r4,763
 400602c:	213c2004 	addi	r4,r4,-3968
 4006030:	40075d00 	call	40075d0 <__udivsi3>
 4006034:	100b883a 	mov	r5,r2
 4006038:	01200034 	movhi	r4,32768
 400603c:	213fffc4 	addi	r4,r4,-1
 4006040:	40075d00 	call	40075d0 <__udivsi3>
 4006044:	1007883a 	mov	r3,r2
 4006048:	e0bfff17 	ldw	r2,-4(fp)
 400604c:	10c5c83a 	sub	r2,r2,r3
 4006050:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 4006054:	e0bffe17 	ldw	r2,-8(fp)
 4006058:	10800044 	addi	r2,r2,1
 400605c:	e0bffe15 	stw	r2,-8(fp)
 4006060:	e0fffe17 	ldw	r3,-8(fp)
 4006064:	e0bffd17 	ldw	r2,-12(fp)
 4006068:	18bfe716 	blt	r3,r2,4006008 <alt_busy_sleep+0x6c>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 400606c:	e0fffc17 	ldw	r3,-16(fp)
 4006070:	008003f4 	movhi	r2,15
 4006074:	10909004 	addi	r2,r2,16960
 4006078:	188b383a 	mul	r5,r3,r2
 400607c:	0100bef4 	movhi	r4,763
 4006080:	213c2004 	addi	r4,r4,-3968
 4006084:	40075d00 	call	40075d0 <__udivsi3>
 4006088:	1007883a 	mov	r3,r2
 400608c:	e0bfff17 	ldw	r2,-4(fp)
 4006090:	1885383a 	mul	r2,r3,r2
 4006094:	10bfffc4 	addi	r2,r2,-1
 4006098:	103ffe1e 	bne	r2,zero,4006094 <alt_busy_sleep+0xf8>
 400609c:	00000c06 	br	40060d0 <alt_busy_sleep+0x134>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 40060a0:	e0fffc17 	ldw	r3,-16(fp)
 40060a4:	008003f4 	movhi	r2,15
 40060a8:	10909004 	addi	r2,r2,16960
 40060ac:	188b383a 	mul	r5,r3,r2
 40060b0:	0100bef4 	movhi	r4,763
 40060b4:	213c2004 	addi	r4,r4,-3968
 40060b8:	40075d00 	call	40075d0 <__udivsi3>
 40060bc:	1007883a 	mov	r3,r2
 40060c0:	e0bfff17 	ldw	r2,-4(fp)
 40060c4:	1885383a 	mul	r2,r3,r2
 40060c8:	10bfffc4 	addi	r2,r2,-1
 40060cc:	00bffe16 	blt	zero,r2,40060c8 <alt_busy_sleep+0x12c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 40060d0:	0005883a 	mov	r2,zero
}
 40060d4:	e037883a 	mov	sp,fp
 40060d8:	dfc00117 	ldw	ra,4(sp)
 40060dc:	df000017 	ldw	fp,0(sp)
 40060e0:	dec00204 	addi	sp,sp,8
 40060e4:	f800283a 	ret

040060e8 <close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 40060e8:	defff804 	addi	sp,sp,-32
 40060ec:	dfc00715 	stw	ra,28(sp)
 40060f0:	df000615 	stw	fp,24(sp)
 40060f4:	df000604 	addi	fp,sp,24
 40060f8:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 40060fc:	e0bffc17 	ldw	r2,-16(fp)
 4006100:	1004803a 	cmplt	r2,r2,zero
 4006104:	1000081e 	bne	r2,zero,4006128 <close+0x40>
 4006108:	e0bffc17 	ldw	r2,-16(fp)
 400610c:	10800324 	muli	r2,r2,12
 4006110:	1007883a 	mov	r3,r2
 4006114:	00810074 	movhi	r2,1025
 4006118:	10a3c404 	addi	r2,r2,-28912
 400611c:	1887883a 	add	r3,r3,r2
 4006120:	e0ffff15 	stw	r3,-4(fp)
 4006124:	00000106 	br	400612c <close+0x44>
 4006128:	e03fff15 	stw	zero,-4(fp)
 400612c:	e0bfff17 	ldw	r2,-4(fp)
 4006130:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 4006134:	e0bffb17 	ldw	r2,-20(fp)
 4006138:	1005003a 	cmpeq	r2,r2,zero
 400613c:	10001d1e 	bne	r2,zero,40061b4 <close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 4006140:	e0bffb17 	ldw	r2,-20(fp)
 4006144:	10800017 	ldw	r2,0(r2)
 4006148:	10800417 	ldw	r2,16(r2)
 400614c:	1005003a 	cmpeq	r2,r2,zero
 4006150:	1000071e 	bne	r2,zero,4006170 <close+0x88>
 4006154:	e0bffb17 	ldw	r2,-20(fp)
 4006158:	10800017 	ldw	r2,0(r2)
 400615c:	10800417 	ldw	r2,16(r2)
 4006160:	e13ffb17 	ldw	r4,-20(fp)
 4006164:	103ee83a 	callr	r2
 4006168:	e0bffe15 	stw	r2,-8(fp)
 400616c:	00000106 	br	4006174 <close+0x8c>
 4006170:	e03ffe15 	stw	zero,-8(fp)
 4006174:	e0bffe17 	ldw	r2,-8(fp)
 4006178:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 400617c:	e13ffc17 	ldw	r4,-16(fp)
 4006180:	4006be80 	call	4006be8 <alt_release_fd>
    if (rval < 0)
 4006184:	e0bffa17 	ldw	r2,-24(fp)
 4006188:	1004403a 	cmpge	r2,r2,zero
 400618c:	1000071e 	bne	r2,zero,40061ac <close+0xc4>
    {
      ALT_ERRNO = -rval;
 4006190:	40061e40 	call	40061e4 <alt_get_errno>
 4006194:	e0fffa17 	ldw	r3,-24(fp)
 4006198:	00c7c83a 	sub	r3,zero,r3
 400619c:	10c00015 	stw	r3,0(r2)
      return -1;
 40061a0:	00bfffc4 	movi	r2,-1
 40061a4:	e0bffd15 	stw	r2,-12(fp)
 40061a8:	00000806 	br	40061cc <close+0xe4>
    }
    return 0;
 40061ac:	e03ffd15 	stw	zero,-12(fp)
 40061b0:	00000606 	br	40061cc <close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 40061b4:	40061e40 	call	40061e4 <alt_get_errno>
 40061b8:	1007883a 	mov	r3,r2
 40061bc:	00801444 	movi	r2,81
 40061c0:	18800015 	stw	r2,0(r3)
    return -1;
 40061c4:	00bfffc4 	movi	r2,-1
 40061c8:	e0bffd15 	stw	r2,-12(fp)
 40061cc:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 40061d0:	e037883a 	mov	sp,fp
 40061d4:	dfc00117 	ldw	ra,4(sp)
 40061d8:	df000017 	ldw	fp,0(sp)
 40061dc:	dec00204 	addi	sp,sp,8
 40061e0:	f800283a 	ret

040061e4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 40061e4:	defffd04 	addi	sp,sp,-12
 40061e8:	dfc00215 	stw	ra,8(sp)
 40061ec:	df000115 	stw	fp,4(sp)
 40061f0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 40061f4:	00810074 	movhi	r2,1025
 40061f8:	10a52904 	addi	r2,r2,-27484
 40061fc:	10800017 	ldw	r2,0(r2)
 4006200:	1005003a 	cmpeq	r2,r2,zero
 4006204:	1000061e 	bne	r2,zero,4006220 <alt_get_errno+0x3c>
 4006208:	00810074 	movhi	r2,1025
 400620c:	10a52904 	addi	r2,r2,-27484
 4006210:	10800017 	ldw	r2,0(r2)
 4006214:	103ee83a 	callr	r2
 4006218:	e0bfff15 	stw	r2,-4(fp)
 400621c:	00000306 	br	400622c <alt_get_errno+0x48>
 4006220:	00810074 	movhi	r2,1025
 4006224:	10a53a04 	addi	r2,r2,-27416
 4006228:	e0bfff15 	stw	r2,-4(fp)
 400622c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006230:	e037883a 	mov	sp,fp
 4006234:	dfc00117 	ldw	ra,4(sp)
 4006238:	df000017 	ldw	fp,0(sp)
 400623c:	dec00204 	addi	sp,sp,8
 4006240:	f800283a 	ret

04006244 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 4006244:	defffc04 	addi	sp,sp,-16
 4006248:	df000315 	stw	fp,12(sp)
 400624c:	df000304 	addi	fp,sp,12
 4006250:	e13ffd15 	stw	r4,-12(fp)
 4006254:	e17ffe15 	stw	r5,-8(fp)
 4006258:	e1bfff15 	stw	r6,-4(fp)
  return len;
 400625c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006260:	e037883a 	mov	sp,fp
 4006264:	df000017 	ldw	fp,0(sp)
 4006268:	dec00104 	addi	sp,sp,4
 400626c:	f800283a 	ret

04006270 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 4006270:	defff904 	addi	sp,sp,-28
 4006274:	dfc00615 	stw	ra,24(sp)
 4006278:	df000515 	stw	fp,20(sp)
 400627c:	df000504 	addi	fp,sp,20
 4006280:	e13ffd15 	stw	r4,-12(fp)
 4006284:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 4006288:	e0bffd17 	ldw	r2,-12(fp)
 400628c:	1005003a 	cmpeq	r2,r2,zero
 4006290:	1000041e 	bne	r2,zero,40062a4 <alt_dev_llist_insert+0x34>
 4006294:	e0bffd17 	ldw	r2,-12(fp)
 4006298:	10800217 	ldw	r2,8(r2)
 400629c:	1004c03a 	cmpne	r2,r2,zero
 40062a0:	1000071e 	bne	r2,zero,40062c0 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 40062a4:	40063240 	call	4006324 <alt_get_errno>
 40062a8:	1007883a 	mov	r3,r2
 40062ac:	00800584 	movi	r2,22
 40062b0:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 40062b4:	00bffa84 	movi	r2,-22
 40062b8:	e0bfff15 	stw	r2,-4(fp)
 40062bc:	00001306 	br	400630c <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 40062c0:	e0fffd17 	ldw	r3,-12(fp)
 40062c4:	e0bffe17 	ldw	r2,-8(fp)
 40062c8:	e0bffb15 	stw	r2,-20(fp)
 40062cc:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 40062d0:	e0fffc17 	ldw	r3,-16(fp)
 40062d4:	e0bffb17 	ldw	r2,-20(fp)
 40062d8:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 40062dc:	e0bffb17 	ldw	r2,-20(fp)
 40062e0:	10c00017 	ldw	r3,0(r2)
 40062e4:	e0bffc17 	ldw	r2,-16(fp)
 40062e8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 40062ec:	e0bffb17 	ldw	r2,-20(fp)
 40062f0:	10c00017 	ldw	r3,0(r2)
 40062f4:	e0bffc17 	ldw	r2,-16(fp)
 40062f8:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 40062fc:	e0fffb17 	ldw	r3,-20(fp)
 4006300:	e0bffc17 	ldw	r2,-16(fp)
 4006304:	18800015 	stw	r2,0(r3)

  return 0;  
 4006308:	e03fff15 	stw	zero,-4(fp)
 400630c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006310:	e037883a 	mov	sp,fp
 4006314:	dfc00117 	ldw	ra,4(sp)
 4006318:	df000017 	ldw	fp,0(sp)
 400631c:	dec00204 	addi	sp,sp,8
 4006320:	f800283a 	ret

04006324 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4006324:	defffd04 	addi	sp,sp,-12
 4006328:	dfc00215 	stw	ra,8(sp)
 400632c:	df000115 	stw	fp,4(sp)
 4006330:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4006334:	00810074 	movhi	r2,1025
 4006338:	10a52904 	addi	r2,r2,-27484
 400633c:	10800017 	ldw	r2,0(r2)
 4006340:	1005003a 	cmpeq	r2,r2,zero
 4006344:	1000061e 	bne	r2,zero,4006360 <alt_get_errno+0x3c>
 4006348:	00810074 	movhi	r2,1025
 400634c:	10a52904 	addi	r2,r2,-27484
 4006350:	10800017 	ldw	r2,0(r2)
 4006354:	103ee83a 	callr	r2
 4006358:	e0bfff15 	stw	r2,-4(fp)
 400635c:	00000306 	br	400636c <alt_get_errno+0x48>
 4006360:	00810074 	movhi	r2,1025
 4006364:	10a53a04 	addi	r2,r2,-27416
 4006368:	e0bfff15 	stw	r2,-4(fp)
 400636c:	e0bfff17 	ldw	r2,-4(fp)
}
 4006370:	e037883a 	mov	sp,fp
 4006374:	dfc00117 	ldw	ra,4(sp)
 4006378:	df000017 	ldw	fp,0(sp)
 400637c:	dec00204 	addi	sp,sp,8
 4006380:	f800283a 	ret

04006384 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 4006384:	defffd04 	addi	sp,sp,-12
 4006388:	dfc00215 	stw	ra,8(sp)
 400638c:	df000115 	stw	fp,4(sp)
 4006390:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 4006394:	00bfff04 	movi	r2,-4
 4006398:	00c10034 	movhi	r3,1024
 400639c:	18dd9104 	addi	r3,r3,30276
 40063a0:	1885883a 	add	r2,r3,r2
 40063a4:	e0bfff15 	stw	r2,-4(fp)
 40063a8:	00000606 	br	40063c4 <_do_ctors+0x40>
        (*ctor) (); 
 40063ac:	e0bfff17 	ldw	r2,-4(fp)
 40063b0:	10800017 	ldw	r2,0(r2)
 40063b4:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 40063b8:	e0bfff17 	ldw	r2,-4(fp)
 40063bc:	10bfff04 	addi	r2,r2,-4
 40063c0:	e0bfff15 	stw	r2,-4(fp)
 40063c4:	e0ffff17 	ldw	r3,-4(fp)
 40063c8:	00810034 	movhi	r2,1024
 40063cc:	109d9004 	addi	r2,r2,30272
 40063d0:	18bff62e 	bgeu	r3,r2,40063ac <_do_ctors+0x28>
        (*ctor) (); 
}
 40063d4:	e037883a 	mov	sp,fp
 40063d8:	dfc00117 	ldw	ra,4(sp)
 40063dc:	df000017 	ldw	fp,0(sp)
 40063e0:	dec00204 	addi	sp,sp,8
 40063e4:	f800283a 	ret

040063e8 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 40063e8:	defffd04 	addi	sp,sp,-12
 40063ec:	dfc00215 	stw	ra,8(sp)
 40063f0:	df000115 	stw	fp,4(sp)
 40063f4:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 40063f8:	00bfff04 	movi	r2,-4
 40063fc:	00c10034 	movhi	r3,1024
 4006400:	18dd9104 	addi	r3,r3,30276
 4006404:	1885883a 	add	r2,r3,r2
 4006408:	e0bfff15 	stw	r2,-4(fp)
 400640c:	00000606 	br	4006428 <_do_dtors+0x40>
        (*dtor) (); 
 4006410:	e0bfff17 	ldw	r2,-4(fp)
 4006414:	10800017 	ldw	r2,0(r2)
 4006418:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 400641c:	e0bfff17 	ldw	r2,-4(fp)
 4006420:	10bfff04 	addi	r2,r2,-4
 4006424:	e0bfff15 	stw	r2,-4(fp)
 4006428:	e0ffff17 	ldw	r3,-4(fp)
 400642c:	00810034 	movhi	r2,1024
 4006430:	109d9104 	addi	r2,r2,30276
 4006434:	18bff62e 	bgeu	r3,r2,4006410 <_do_dtors+0x28>
        (*dtor) (); 
}
 4006438:	e037883a 	mov	sp,fp
 400643c:	dfc00117 	ldw	ra,4(sp)
 4006440:	df000017 	ldw	fp,0(sp)
 4006444:	dec00204 	addi	sp,sp,8
 4006448:	f800283a 	ret

0400644c <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 400644c:	defffb04 	addi	sp,sp,-20
 4006450:	dfc00415 	stw	ra,16(sp)
 4006454:	df000315 	stw	fp,12(sp)
 4006458:	df000304 	addi	fp,sp,12
 400645c:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 4006460:	e13ffe17 	ldw	r4,-8(fp)
 4006464:	d1600604 	addi	r5,gp,-32744
 4006468:	4006e0c0 	call	4006e0c <alt_find_dev>
 400646c:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 4006470:	e0bffd17 	ldw	r2,-12(fp)
 4006474:	1005003a 	cmpeq	r2,r2,zero
 4006478:	10000b1e 	bne	r2,zero,40064a8 <alt_flash_open_dev+0x5c>
 400647c:	e0bffd17 	ldw	r2,-12(fp)
 4006480:	10800317 	ldw	r2,12(r2)
 4006484:	1005003a 	cmpeq	r2,r2,zero
 4006488:	1000071e 	bne	r2,zero,40064a8 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 400648c:	e0bffd17 	ldw	r2,-12(fp)
 4006490:	10800317 	ldw	r2,12(r2)
 4006494:	e13ffd17 	ldw	r4,-12(fp)
 4006498:	e17ffe17 	ldw	r5,-8(fp)
 400649c:	103ee83a 	callr	r2
 40064a0:	e0bfff15 	stw	r2,-4(fp)
 40064a4:	00000206 	br	40064b0 <alt_flash_open_dev+0x64>
  }

  return dev;
 40064a8:	e0bffd17 	ldw	r2,-12(fp)
 40064ac:	e0bfff15 	stw	r2,-4(fp)
 40064b0:	e0bfff17 	ldw	r2,-4(fp)
}
 40064b4:	e037883a 	mov	sp,fp
 40064b8:	dfc00117 	ldw	ra,4(sp)
 40064bc:	df000017 	ldw	fp,0(sp)
 40064c0:	dec00204 	addi	sp,sp,8
 40064c4:	f800283a 	ret

040064c8 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 40064c8:	defffd04 	addi	sp,sp,-12
 40064cc:	dfc00215 	stw	ra,8(sp)
 40064d0:	df000115 	stw	fp,4(sp)
 40064d4:	df000104 	addi	fp,sp,4
 40064d8:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 40064dc:	e0bfff17 	ldw	r2,-4(fp)
 40064e0:	1005003a 	cmpeq	r2,r2,zero
 40064e4:	1000081e 	bne	r2,zero,4006508 <alt_flash_close_dev+0x40>
 40064e8:	e0bfff17 	ldw	r2,-4(fp)
 40064ec:	10800417 	ldw	r2,16(r2)
 40064f0:	1005003a 	cmpeq	r2,r2,zero
 40064f4:	1000041e 	bne	r2,zero,4006508 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 40064f8:	e0bfff17 	ldw	r2,-4(fp)
 40064fc:	10800417 	ldw	r2,16(r2)
 4006500:	e13fff17 	ldw	r4,-4(fp)
 4006504:	103ee83a 	callr	r2
  }
  return;
}
 4006508:	e037883a 	mov	sp,fp
 400650c:	dfc00117 	ldw	ra,4(sp)
 4006510:	df000017 	ldw	fp,0(sp)
 4006514:	dec00204 	addi	sp,sp,8
 4006518:	f800283a 	ret

0400651c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 400651c:	defff904 	addi	sp,sp,-28
 4006520:	dfc00615 	stw	ra,24(sp)
 4006524:	df000515 	stw	fp,20(sp)
 4006528:	df000504 	addi	fp,sp,20
 400652c:	e13ffc15 	stw	r4,-16(fp)
 4006530:	e17ffd15 	stw	r5,-12(fp)
 4006534:	e1bffe15 	stw	r6,-8(fp)
 4006538:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 400653c:	e0800217 	ldw	r2,8(fp)
 4006540:	d8800015 	stw	r2,0(sp)
 4006544:	e13ffc17 	ldw	r4,-16(fp)
 4006548:	e17ffd17 	ldw	r5,-12(fp)
 400654c:	e1bffe17 	ldw	r6,-8(fp)
 4006550:	e1ffff17 	ldw	r7,-4(fp)
 4006554:	40066f00 	call	40066f0 <alt_iic_isr_register>
}  
 4006558:	e037883a 	mov	sp,fp
 400655c:	dfc00117 	ldw	ra,4(sp)
 4006560:	df000017 	ldw	fp,0(sp)
 4006564:	dec00204 	addi	sp,sp,8
 4006568:	f800283a 	ret

0400656c <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 400656c:	defff904 	addi	sp,sp,-28
 4006570:	df000615 	stw	fp,24(sp)
 4006574:	df000604 	addi	fp,sp,24
 4006578:	e13ffe15 	stw	r4,-8(fp)
 400657c:	e17fff15 	stw	r5,-4(fp)
 4006580:	e0bfff17 	ldw	r2,-4(fp)
 4006584:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4006588:	0005303a 	rdctl	r2,status
 400658c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4006590:	e0fffb17 	ldw	r3,-20(fp)
 4006594:	00bfff84 	movi	r2,-2
 4006598:	1884703a 	and	r2,r3,r2
 400659c:	1001703a 	wrctl	status,r2
  
  return context;
 40065a0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 40065a4:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 40065a8:	e0fffc17 	ldw	r3,-16(fp)
 40065ac:	00800044 	movi	r2,1
 40065b0:	10c4983a 	sll	r2,r2,r3
 40065b4:	1007883a 	mov	r3,r2
 40065b8:	00810074 	movhi	r2,1025
 40065bc:	10a53704 	addi	r2,r2,-27428
 40065c0:	10800017 	ldw	r2,0(r2)
 40065c4:	1886b03a 	or	r3,r3,r2
 40065c8:	00810074 	movhi	r2,1025
 40065cc:	10a53704 	addi	r2,r2,-27428
 40065d0:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 40065d4:	00810074 	movhi	r2,1025
 40065d8:	10a53704 	addi	r2,r2,-27428
 40065dc:	10800017 	ldw	r2,0(r2)
 40065e0:	100170fa 	wrctl	ienable,r2
 40065e4:	e0bffd17 	ldw	r2,-12(fp)
 40065e8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 40065ec:	e0bffa17 	ldw	r2,-24(fp)
 40065f0:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 40065f4:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 40065f8:	e037883a 	mov	sp,fp
 40065fc:	df000017 	ldw	fp,0(sp)
 4006600:	dec00104 	addi	sp,sp,4
 4006604:	f800283a 	ret

04006608 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 4006608:	defff904 	addi	sp,sp,-28
 400660c:	df000615 	stw	fp,24(sp)
 4006610:	df000604 	addi	fp,sp,24
 4006614:	e13ffe15 	stw	r4,-8(fp)
 4006618:	e17fff15 	stw	r5,-4(fp)
 400661c:	e0bfff17 	ldw	r2,-4(fp)
 4006620:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4006624:	0005303a 	rdctl	r2,status
 4006628:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 400662c:	e0fffb17 	ldw	r3,-20(fp)
 4006630:	00bfff84 	movi	r2,-2
 4006634:	1884703a 	and	r2,r3,r2
 4006638:	1001703a 	wrctl	status,r2
  
  return context;
 400663c:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 4006640:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 4006644:	e0fffc17 	ldw	r3,-16(fp)
 4006648:	00800044 	movi	r2,1
 400664c:	10c4983a 	sll	r2,r2,r3
 4006650:	0084303a 	nor	r2,zero,r2
 4006654:	1007883a 	mov	r3,r2
 4006658:	00810074 	movhi	r2,1025
 400665c:	10a53704 	addi	r2,r2,-27428
 4006660:	10800017 	ldw	r2,0(r2)
 4006664:	1886703a 	and	r3,r3,r2
 4006668:	00810074 	movhi	r2,1025
 400666c:	10a53704 	addi	r2,r2,-27428
 4006670:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 4006674:	00810074 	movhi	r2,1025
 4006678:	10a53704 	addi	r2,r2,-27428
 400667c:	10800017 	ldw	r2,0(r2)
 4006680:	100170fa 	wrctl	ienable,r2
 4006684:	e0bffd17 	ldw	r2,-12(fp)
 4006688:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 400668c:	e0bffa17 	ldw	r2,-24(fp)
 4006690:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 4006694:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 4006698:	e037883a 	mov	sp,fp
 400669c:	df000017 	ldw	fp,0(sp)
 40066a0:	dec00104 	addi	sp,sp,4
 40066a4:	f800283a 	ret

040066a8 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 40066a8:	defffc04 	addi	sp,sp,-16
 40066ac:	df000315 	stw	fp,12(sp)
 40066b0:	df000304 	addi	fp,sp,12
 40066b4:	e13ffe15 	stw	r4,-8(fp)
 40066b8:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 40066bc:	000530fa 	rdctl	r2,ienable
 40066c0:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 40066c4:	e0ffff17 	ldw	r3,-4(fp)
 40066c8:	00800044 	movi	r2,1
 40066cc:	10c4983a 	sll	r2,r2,r3
 40066d0:	1007883a 	mov	r3,r2
 40066d4:	e0bffd17 	ldw	r2,-12(fp)
 40066d8:	1884703a 	and	r2,r3,r2
 40066dc:	1004c03a 	cmpne	r2,r2,zero
}
 40066e0:	e037883a 	mov	sp,fp
 40066e4:	df000017 	ldw	fp,0(sp)
 40066e8:	dec00104 	addi	sp,sp,4
 40066ec:	f800283a 	ret

040066f0 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 40066f0:	defff404 	addi	sp,sp,-48
 40066f4:	dfc00b15 	stw	ra,44(sp)
 40066f8:	df000a15 	stw	fp,40(sp)
 40066fc:	df000a04 	addi	fp,sp,40
 4006700:	e13ffb15 	stw	r4,-20(fp)
 4006704:	e17ffc15 	stw	r5,-16(fp)
 4006708:	e1bffd15 	stw	r6,-12(fp)
 400670c:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 4006710:	00bffa84 	movi	r2,-22
 4006714:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 4006718:	e0bffc17 	ldw	r2,-16(fp)
 400671c:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 4006720:	e0bff917 	ldw	r2,-28(fp)
 4006724:	10800808 	cmpgei	r2,r2,32
 4006728:	1000291e 	bne	r2,zero,40067d0 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 400672c:	0005303a 	rdctl	r2,status
 4006730:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4006734:	e0fff717 	ldw	r3,-36(fp)
 4006738:	00bfff84 	movi	r2,-2
 400673c:	1884703a 	and	r2,r3,r2
 4006740:	1001703a 	wrctl	status,r2
  
  return context;
 4006744:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 4006748:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 400674c:	e0bff917 	ldw	r2,-28(fp)
 4006750:	00c10074 	movhi	r3,1025
 4006754:	18e54c04 	addi	r3,r3,-27344
 4006758:	100490fa 	slli	r2,r2,3
 400675c:	10c7883a 	add	r3,r2,r3
 4006760:	e0bffd17 	ldw	r2,-12(fp)
 4006764:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 4006768:	e0bff917 	ldw	r2,-28(fp)
 400676c:	00c10074 	movhi	r3,1025
 4006770:	18e54c04 	addi	r3,r3,-27344
 4006774:	100490fa 	slli	r2,r2,3
 4006778:	10c5883a 	add	r2,r2,r3
 400677c:	10c00104 	addi	r3,r2,4
 4006780:	e0bffe17 	ldw	r2,-8(fp)
 4006784:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 4006788:	e0bffd17 	ldw	r2,-12(fp)
 400678c:	1005003a 	cmpeq	r2,r2,zero
 4006790:	1000051e 	bne	r2,zero,40067a8 <alt_iic_isr_register+0xb8>
 4006794:	e17ff917 	ldw	r5,-28(fp)
 4006798:	e13ffb17 	ldw	r4,-20(fp)
 400679c:	400656c0 	call	400656c <alt_ic_irq_enable>
 40067a0:	e0bfff15 	stw	r2,-4(fp)
 40067a4:	00000406 	br	40067b8 <alt_iic_isr_register+0xc8>
 40067a8:	e17ff917 	ldw	r5,-28(fp)
 40067ac:	e13ffb17 	ldw	r4,-20(fp)
 40067b0:	40066080 	call	4006608 <alt_ic_irq_disable>
 40067b4:	e0bfff15 	stw	r2,-4(fp)
 40067b8:	e0bfff17 	ldw	r2,-4(fp)
 40067bc:	e0bffa15 	stw	r2,-24(fp)
 40067c0:	e0bff817 	ldw	r2,-32(fp)
 40067c4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 40067c8:	e0bff617 	ldw	r2,-40(fp)
 40067cc:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 40067d0:	e0bffa17 	ldw	r2,-24(fp)
}
 40067d4:	e037883a 	mov	sp,fp
 40067d8:	dfc00117 	ldw	ra,4(sp)
 40067dc:	df000017 	ldw	fp,0(sp)
 40067e0:	dec00204 	addi	sp,sp,8
 40067e4:	f800283a 	ret

040067e8 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 40067e8:	defff904 	addi	sp,sp,-28
 40067ec:	dfc00615 	stw	ra,24(sp)
 40067f0:	df000515 	stw	fp,20(sp)
 40067f4:	df000504 	addi	fp,sp,20
 40067f8:	e13ffc15 	stw	r4,-16(fp)
 40067fc:	e17ffd15 	stw	r5,-12(fp)
 4006800:	e1bffe15 	stw	r6,-8(fp)
 4006804:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 4006808:	e13ffd17 	ldw	r4,-12(fp)
 400680c:	e17ffe17 	ldw	r5,-8(fp)
 4006810:	e1bfff17 	ldw	r6,-4(fp)
 4006814:	4006a000 	call	4006a00 <open>
 4006818:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 400681c:	e0bffb17 	ldw	r2,-20(fp)
 4006820:	1004803a 	cmplt	r2,r2,zero
 4006824:	10001c1e 	bne	r2,zero,4006898 <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 4006828:	e0bffb17 	ldw	r2,-20(fp)
 400682c:	00c10074 	movhi	r3,1025
 4006830:	18e3c404 	addi	r3,r3,-28912
 4006834:	10800324 	muli	r2,r2,12
 4006838:	10c5883a 	add	r2,r2,r3
 400683c:	10c00017 	ldw	r3,0(r2)
 4006840:	e0bffc17 	ldw	r2,-16(fp)
 4006844:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 4006848:	e0bffb17 	ldw	r2,-20(fp)
 400684c:	00c10074 	movhi	r3,1025
 4006850:	18e3c404 	addi	r3,r3,-28912
 4006854:	10800324 	muli	r2,r2,12
 4006858:	10c5883a 	add	r2,r2,r3
 400685c:	10800104 	addi	r2,r2,4
 4006860:	10c00017 	ldw	r3,0(r2)
 4006864:	e0bffc17 	ldw	r2,-16(fp)
 4006868:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 400686c:	e0bffb17 	ldw	r2,-20(fp)
 4006870:	00c10074 	movhi	r3,1025
 4006874:	18e3c404 	addi	r3,r3,-28912
 4006878:	10800324 	muli	r2,r2,12
 400687c:	10c5883a 	add	r2,r2,r3
 4006880:	10800204 	addi	r2,r2,8
 4006884:	10c00017 	ldw	r3,0(r2)
 4006888:	e0bffc17 	ldw	r2,-16(fp)
 400688c:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 4006890:	e13ffb17 	ldw	r4,-20(fp)
 4006894:	4006be80 	call	4006be8 <alt_release_fd>
  }
} 
 4006898:	e037883a 	mov	sp,fp
 400689c:	dfc00117 	ldw	ra,4(sp)
 40068a0:	df000017 	ldw	fp,0(sp)
 40068a4:	dec00204 	addi	sp,sp,8
 40068a8:	f800283a 	ret

040068ac <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 40068ac:	defffb04 	addi	sp,sp,-20
 40068b0:	dfc00415 	stw	ra,16(sp)
 40068b4:	df000315 	stw	fp,12(sp)
 40068b8:	df000304 	addi	fp,sp,12
 40068bc:	e13ffd15 	stw	r4,-12(fp)
 40068c0:	e17ffe15 	stw	r5,-8(fp)
 40068c4:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 40068c8:	01010074 	movhi	r4,1025
 40068cc:	2123c704 	addi	r4,r4,-28900
 40068d0:	e17ffd17 	ldw	r5,-12(fp)
 40068d4:	01800044 	movi	r6,1
 40068d8:	01c07fc4 	movi	r7,511
 40068dc:	40067e80 	call	40067e8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 40068e0:	01010074 	movhi	r4,1025
 40068e4:	2123c404 	addi	r4,r4,-28912
 40068e8:	e17ffe17 	ldw	r5,-8(fp)
 40068ec:	000d883a 	mov	r6,zero
 40068f0:	01c07fc4 	movi	r7,511
 40068f4:	40067e80 	call	40067e8 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 40068f8:	01010074 	movhi	r4,1025
 40068fc:	2123ca04 	addi	r4,r4,-28888
 4006900:	e17fff17 	ldw	r5,-4(fp)
 4006904:	01800044 	movi	r6,1
 4006908:	01c07fc4 	movi	r7,511
 400690c:	40067e80 	call	40067e8 <alt_open_fd>
}  
 4006910:	e037883a 	mov	sp,fp
 4006914:	dfc00117 	ldw	ra,4(sp)
 4006918:	df000017 	ldw	fp,0(sp)
 400691c:	dec00204 	addi	sp,sp,8
 4006920:	f800283a 	ret

04006924 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 4006924:	defffc04 	addi	sp,sp,-16
 4006928:	df000315 	stw	fp,12(sp)
 400692c:	df000304 	addi	fp,sp,12
 4006930:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 4006934:	e0bffe17 	ldw	r2,-8(fp)
 4006938:	10800217 	ldw	r2,8(r2)
 400693c:	10d00034 	orhi	r3,r2,16384
 4006940:	e0bffe17 	ldw	r2,-8(fp)
 4006944:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 4006948:	e03ffd15 	stw	zero,-12(fp)
 400694c:	00002006 	br	40069d0 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 4006950:	e0bffd17 	ldw	r2,-12(fp)
 4006954:	00c10074 	movhi	r3,1025
 4006958:	18e3c404 	addi	r3,r3,-28912
 400695c:	10800324 	muli	r2,r2,12
 4006960:	10c5883a 	add	r2,r2,r3
 4006964:	10c00017 	ldw	r3,0(r2)
 4006968:	e0bffe17 	ldw	r2,-8(fp)
 400696c:	10800017 	ldw	r2,0(r2)
 4006970:	1880141e 	bne	r3,r2,40069c4 <alt_file_locked+0xa0>
 4006974:	e0bffd17 	ldw	r2,-12(fp)
 4006978:	00c10074 	movhi	r3,1025
 400697c:	18e3c404 	addi	r3,r3,-28912
 4006980:	10800324 	muli	r2,r2,12
 4006984:	10c5883a 	add	r2,r2,r3
 4006988:	10800204 	addi	r2,r2,8
 400698c:	10800017 	ldw	r2,0(r2)
 4006990:	1004403a 	cmpge	r2,r2,zero
 4006994:	10000b1e 	bne	r2,zero,40069c4 <alt_file_locked+0xa0>
 4006998:	e0bffd17 	ldw	r2,-12(fp)
 400699c:	10800324 	muli	r2,r2,12
 40069a0:	1007883a 	mov	r3,r2
 40069a4:	00810074 	movhi	r2,1025
 40069a8:	10a3c404 	addi	r2,r2,-28912
 40069ac:	1887883a 	add	r3,r3,r2
 40069b0:	e0bffe17 	ldw	r2,-8(fp)
 40069b4:	18800326 	beq	r3,r2,40069c4 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 40069b8:	00bffcc4 	movi	r2,-13
 40069bc:	e0bfff15 	stw	r2,-4(fp)
 40069c0:	00000a06 	br	40069ec <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 40069c4:	e0bffd17 	ldw	r2,-12(fp)
 40069c8:	10800044 	addi	r2,r2,1
 40069cc:	e0bffd15 	stw	r2,-12(fp)
 40069d0:	00810074 	movhi	r2,1025
 40069d4:	10a52804 	addi	r2,r2,-27488
 40069d8:	10800017 	ldw	r2,0(r2)
 40069dc:	1007883a 	mov	r3,r2
 40069e0:	e0bffd17 	ldw	r2,-12(fp)
 40069e4:	18bfda2e 	bgeu	r3,r2,4006950 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 40069e8:	e03fff15 	stw	zero,-4(fp)
 40069ec:	e0bfff17 	ldw	r2,-4(fp)
}
 40069f0:	e037883a 	mov	sp,fp
 40069f4:	df000017 	ldw	fp,0(sp)
 40069f8:	dec00104 	addi	sp,sp,4
 40069fc:	f800283a 	ret

04006a00 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 4006a00:	defff404 	addi	sp,sp,-48
 4006a04:	dfc00b15 	stw	ra,44(sp)
 4006a08:	df000a15 	stw	fp,40(sp)
 4006a0c:	df000a04 	addi	fp,sp,40
 4006a10:	e13ffb15 	stw	r4,-20(fp)
 4006a14:	e17ffc15 	stw	r5,-16(fp)
 4006a18:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 4006a1c:	00bfffc4 	movi	r2,-1
 4006a20:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 4006a24:	00bffb44 	movi	r2,-19
 4006a28:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 4006a2c:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 4006a30:	e13ffb17 	ldw	r4,-20(fp)
 4006a34:	01410074 	movhi	r5,1025
 4006a38:	29652604 	addi	r5,r5,-27496
 4006a3c:	4006e0c0 	call	4006e0c <alt_find_dev>
 4006a40:	e0bffa15 	stw	r2,-24(fp)
 4006a44:	e0bffa17 	ldw	r2,-24(fp)
 4006a48:	1004c03a 	cmpne	r2,r2,zero
 4006a4c:	1000051e 	bne	r2,zero,4006a64 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 4006a50:	e13ffb17 	ldw	r4,-20(fp)
 4006a54:	4006ea00 	call	4006ea0 <alt_find_file>
 4006a58:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 4006a5c:	00800044 	movi	r2,1
 4006a60:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 4006a64:	e0bffa17 	ldw	r2,-24(fp)
 4006a68:	1005003a 	cmpeq	r2,r2,zero
 4006a6c:	1000301e 	bne	r2,zero,4006b30 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 4006a70:	e13ffa17 	ldw	r4,-24(fp)
 4006a74:	4006fc00 	call	4006fc0 <alt_get_fd>
 4006a78:	e0bff815 	stw	r2,-32(fp)
 4006a7c:	e0bff817 	ldw	r2,-32(fp)
 4006a80:	1004403a 	cmpge	r2,r2,zero
 4006a84:	1000031e 	bne	r2,zero,4006a94 <open+0x94>
    {
      status = index;
 4006a88:	e0bff817 	ldw	r2,-32(fp)
 4006a8c:	e0bff715 	stw	r2,-36(fp)
 4006a90:	00002906 	br	4006b38 <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 4006a94:	e0bff817 	ldw	r2,-32(fp)
 4006a98:	10800324 	muli	r2,r2,12
 4006a9c:	1007883a 	mov	r3,r2
 4006aa0:	00810074 	movhi	r2,1025
 4006aa4:	10a3c404 	addi	r2,r2,-28912
 4006aa8:	1885883a 	add	r2,r3,r2
 4006aac:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 4006ab0:	e0fffc17 	ldw	r3,-16(fp)
 4006ab4:	00900034 	movhi	r2,16384
 4006ab8:	10bfffc4 	addi	r2,r2,-1
 4006abc:	1886703a 	and	r3,r3,r2
 4006ac0:	e0bff917 	ldw	r2,-28(fp)
 4006ac4:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 4006ac8:	e0bff617 	ldw	r2,-40(fp)
 4006acc:	1004c03a 	cmpne	r2,r2,zero
 4006ad0:	1000061e 	bne	r2,zero,4006aec <open+0xec>
 4006ad4:	e13ff917 	ldw	r4,-28(fp)
 4006ad8:	40069240 	call	4006924 <alt_file_locked>
 4006adc:	e0bff715 	stw	r2,-36(fp)
 4006ae0:	e0bff717 	ldw	r2,-36(fp)
 4006ae4:	1004803a 	cmplt	r2,r2,zero
 4006ae8:	1000131e 	bne	r2,zero,4006b38 <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 4006aec:	e0bffa17 	ldw	r2,-24(fp)
 4006af0:	10800317 	ldw	r2,12(r2)
 4006af4:	1005003a 	cmpeq	r2,r2,zero
 4006af8:	1000091e 	bne	r2,zero,4006b20 <open+0x120>
 4006afc:	e0bffa17 	ldw	r2,-24(fp)
 4006b00:	10800317 	ldw	r2,12(r2)
 4006b04:	e13ff917 	ldw	r4,-28(fp)
 4006b08:	e17ffb17 	ldw	r5,-20(fp)
 4006b0c:	e1bffc17 	ldw	r6,-16(fp)
 4006b10:	e1fffd17 	ldw	r7,-12(fp)
 4006b14:	103ee83a 	callr	r2
 4006b18:	e0bfff15 	stw	r2,-4(fp)
 4006b1c:	00000106 	br	4006b24 <open+0x124>
 4006b20:	e03fff15 	stw	zero,-4(fp)
 4006b24:	e0bfff17 	ldw	r2,-4(fp)
 4006b28:	e0bff715 	stw	r2,-36(fp)
 4006b2c:	00000206 	br	4006b38 <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 4006b30:	00bffb44 	movi	r2,-19
 4006b34:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 4006b38:	e0bff717 	ldw	r2,-36(fp)
 4006b3c:	1004403a 	cmpge	r2,r2,zero
 4006b40:	1000091e 	bne	r2,zero,4006b68 <open+0x168>
  {
    alt_release_fd (index);  
 4006b44:	e13ff817 	ldw	r4,-32(fp)
 4006b48:	4006be80 	call	4006be8 <alt_release_fd>
    ALT_ERRNO = -status;
 4006b4c:	4006b880 	call	4006b88 <alt_get_errno>
 4006b50:	e0fff717 	ldw	r3,-36(fp)
 4006b54:	00c7c83a 	sub	r3,zero,r3
 4006b58:	10c00015 	stw	r3,0(r2)
    return -1;
 4006b5c:	00bfffc4 	movi	r2,-1
 4006b60:	e0bffe15 	stw	r2,-8(fp)
 4006b64:	00000206 	br	4006b70 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 4006b68:	e0bff817 	ldw	r2,-32(fp)
 4006b6c:	e0bffe15 	stw	r2,-8(fp)
 4006b70:	e0bffe17 	ldw	r2,-8(fp)
}
 4006b74:	e037883a 	mov	sp,fp
 4006b78:	dfc00117 	ldw	ra,4(sp)
 4006b7c:	df000017 	ldw	fp,0(sp)
 4006b80:	dec00204 	addi	sp,sp,8
 4006b84:	f800283a 	ret

04006b88 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 4006b88:	defffd04 	addi	sp,sp,-12
 4006b8c:	dfc00215 	stw	ra,8(sp)
 4006b90:	df000115 	stw	fp,4(sp)
 4006b94:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 4006b98:	00810074 	movhi	r2,1025
 4006b9c:	10a52904 	addi	r2,r2,-27484
 4006ba0:	10800017 	ldw	r2,0(r2)
 4006ba4:	1005003a 	cmpeq	r2,r2,zero
 4006ba8:	1000061e 	bne	r2,zero,4006bc4 <alt_get_errno+0x3c>
 4006bac:	00810074 	movhi	r2,1025
 4006bb0:	10a52904 	addi	r2,r2,-27484
 4006bb4:	10800017 	ldw	r2,0(r2)
 4006bb8:	103ee83a 	callr	r2
 4006bbc:	e0bfff15 	stw	r2,-4(fp)
 4006bc0:	00000306 	br	4006bd0 <alt_get_errno+0x48>
 4006bc4:	00810074 	movhi	r2,1025
 4006bc8:	10a53a04 	addi	r2,r2,-27416
 4006bcc:	e0bfff15 	stw	r2,-4(fp)
 4006bd0:	e0bfff17 	ldw	r2,-4(fp)
}
 4006bd4:	e037883a 	mov	sp,fp
 4006bd8:	dfc00117 	ldw	ra,4(sp)
 4006bdc:	df000017 	ldw	fp,0(sp)
 4006be0:	dec00204 	addi	sp,sp,8
 4006be4:	f800283a 	ret

04006be8 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 4006be8:	defffe04 	addi	sp,sp,-8
 4006bec:	df000115 	stw	fp,4(sp)
 4006bf0:	df000104 	addi	fp,sp,4
 4006bf4:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 4006bf8:	e0bfff17 	ldw	r2,-4(fp)
 4006bfc:	108000d0 	cmplti	r2,r2,3
 4006c00:	10000d1e 	bne	r2,zero,4006c38 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 4006c04:	e0bfff17 	ldw	r2,-4(fp)
 4006c08:	00c10074 	movhi	r3,1025
 4006c0c:	18e3c404 	addi	r3,r3,-28912
 4006c10:	10800324 	muli	r2,r2,12
 4006c14:	10c5883a 	add	r2,r2,r3
 4006c18:	10800204 	addi	r2,r2,8
 4006c1c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 4006c20:	e0bfff17 	ldw	r2,-4(fp)
 4006c24:	00c10074 	movhi	r3,1025
 4006c28:	18e3c404 	addi	r3,r3,-28912
 4006c2c:	10800324 	muli	r2,r2,12
 4006c30:	10c5883a 	add	r2,r2,r3
 4006c34:	10000015 	stw	zero,0(r2)
  }
}
 4006c38:	e037883a 	mov	sp,fp
 4006c3c:	df000017 	ldw	fp,0(sp)
 4006c40:	dec00104 	addi	sp,sp,4
 4006c44:	f800283a 	ret

04006c48 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 4006c48:	defffa04 	addi	sp,sp,-24
 4006c4c:	df000515 	stw	fp,20(sp)
 4006c50:	df000504 	addi	fp,sp,20
 4006c54:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 4006c58:	0005303a 	rdctl	r2,status
 4006c5c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 4006c60:	e0fffd17 	ldw	r3,-12(fp)
 4006c64:	00bfff84 	movi	r2,-2
 4006c68:	1884703a 	and	r2,r3,r2
 4006c6c:	1001703a 	wrctl	status,r2
  
  return context;
 4006c70:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 4006c74:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 4006c78:	e0bfff17 	ldw	r2,-4(fp)
 4006c7c:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 4006c80:	e0bffc17 	ldw	r2,-16(fp)
 4006c84:	10c00017 	ldw	r3,0(r2)
 4006c88:	e0bffc17 	ldw	r2,-16(fp)
 4006c8c:	10800117 	ldw	r2,4(r2)
 4006c90:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 4006c94:	e0bffc17 	ldw	r2,-16(fp)
 4006c98:	10c00117 	ldw	r3,4(r2)
 4006c9c:	e0bffc17 	ldw	r2,-16(fp)
 4006ca0:	10800017 	ldw	r2,0(r2)
 4006ca4:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 4006ca8:	e0fffc17 	ldw	r3,-16(fp)
 4006cac:	e0bffc17 	ldw	r2,-16(fp)
 4006cb0:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 4006cb4:	e0fffc17 	ldw	r3,-16(fp)
 4006cb8:	e0bffc17 	ldw	r2,-16(fp)
 4006cbc:	18800015 	stw	r2,0(r3)
 4006cc0:	e0bffe17 	ldw	r2,-8(fp)
 4006cc4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 4006cc8:	e0bffb17 	ldw	r2,-20(fp)
 4006ccc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 4006cd0:	e037883a 	mov	sp,fp
 4006cd4:	df000017 	ldw	fp,0(sp)
 4006cd8:	dec00104 	addi	sp,sp,4
 4006cdc:	f800283a 	ret

04006ce0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 4006ce0:	defffb04 	addi	sp,sp,-20
 4006ce4:	dfc00415 	stw	ra,16(sp)
 4006ce8:	df000315 	stw	fp,12(sp)
 4006cec:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 4006cf0:	d0a00917 	ldw	r2,-32732(gp)
 4006cf4:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 4006cf8:	d0a01517 	ldw	r2,-32684(gp)
 4006cfc:	10800044 	addi	r2,r2,1
 4006d00:	d0a01515 	stw	r2,-32684(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 4006d04:	00003106 	br	4006dcc <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 4006d08:	e0bffe17 	ldw	r2,-8(fp)
 4006d0c:	10800017 	ldw	r2,0(r2)
 4006d10:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 4006d14:	e0bffe17 	ldw	r2,-8(fp)
 4006d18:	10800403 	ldbu	r2,16(r2)
 4006d1c:	10803fcc 	andi	r2,r2,255
 4006d20:	1005003a 	cmpeq	r2,r2,zero
 4006d24:	1000051e 	bne	r2,zero,4006d3c <alt_tick+0x5c>
 4006d28:	d0a01517 	ldw	r2,-32684(gp)
 4006d2c:	1004c03a 	cmpne	r2,r2,zero
 4006d30:	1000021e 	bne	r2,zero,4006d3c <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 4006d34:	e0bffe17 	ldw	r2,-8(fp)
 4006d38:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 4006d3c:	e0bffe17 	ldw	r2,-8(fp)
 4006d40:	10c00217 	ldw	r3,8(r2)
 4006d44:	d0a01517 	ldw	r2,-32684(gp)
 4006d48:	10c01e36 	bltu	r2,r3,4006dc4 <alt_tick+0xe4>
 4006d4c:	e0bffe17 	ldw	r2,-8(fp)
 4006d50:	10800403 	ldbu	r2,16(r2)
 4006d54:	10803fcc 	andi	r2,r2,255
 4006d58:	1004c03a 	cmpne	r2,r2,zero
 4006d5c:	1000191e 	bne	r2,zero,4006dc4 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 4006d60:	e0bffe17 	ldw	r2,-8(fp)
 4006d64:	10c00317 	ldw	r3,12(r2)
 4006d68:	e0bffe17 	ldw	r2,-8(fp)
 4006d6c:	11000517 	ldw	r4,20(r2)
 4006d70:	183ee83a 	callr	r3
 4006d74:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 4006d78:	e0bffd17 	ldw	r2,-12(fp)
 4006d7c:	1004c03a 	cmpne	r2,r2,zero
 4006d80:	1000031e 	bne	r2,zero,4006d90 <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 4006d84:	e13ffe17 	ldw	r4,-8(fp)
 4006d88:	4006c480 	call	4006c48 <alt_alarm_stop>
 4006d8c:	00000d06 	br	4006dc4 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 4006d90:	e0bffe17 	ldw	r2,-8(fp)
 4006d94:	10c00217 	ldw	r3,8(r2)
 4006d98:	e0bffd17 	ldw	r2,-12(fp)
 4006d9c:	1887883a 	add	r3,r3,r2
 4006da0:	e0bffe17 	ldw	r2,-8(fp)
 4006da4:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 4006da8:	e0bffe17 	ldw	r2,-8(fp)
 4006dac:	10c00217 	ldw	r3,8(r2)
 4006db0:	d0a01517 	ldw	r2,-32684(gp)
 4006db4:	1880032e 	bgeu	r3,r2,4006dc4 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 4006db8:	e0fffe17 	ldw	r3,-8(fp)
 4006dbc:	00800044 	movi	r2,1
 4006dc0:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 4006dc4:	e0bfff17 	ldw	r2,-4(fp)
 4006dc8:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 4006dcc:	d0e00904 	addi	r3,gp,-32732
 4006dd0:	e0bffe17 	ldw	r2,-8(fp)
 4006dd4:	10ffcc1e 	bne	r2,r3,4006d08 <alt_tick+0x28>
  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
}
 4006dd8:	e037883a 	mov	sp,fp
 4006ddc:	dfc00117 	ldw	ra,4(sp)
 4006de0:	df000017 	ldw	fp,0(sp)
 4006de4:	dec00204 	addi	sp,sp,8
 4006de8:	f800283a 	ret

04006dec <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 4006dec:	deffff04 	addi	sp,sp,-4
 4006df0:	df000015 	stw	fp,0(sp)
 4006df4:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 4006df8:	000170fa 	wrctl	ienable,zero
}
 4006dfc:	e037883a 	mov	sp,fp
 4006e00:	df000017 	ldw	fp,0(sp)
 4006e04:	dec00104 	addi	sp,sp,4
 4006e08:	f800283a 	ret

04006e0c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 4006e0c:	defff904 	addi	sp,sp,-28
 4006e10:	dfc00615 	stw	ra,24(sp)
 4006e14:	df000515 	stw	fp,20(sp)
 4006e18:	df000504 	addi	fp,sp,20
 4006e1c:	e13ffd15 	stw	r4,-12(fp)
 4006e20:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 4006e24:	e0bffe17 	ldw	r2,-8(fp)
 4006e28:	10800017 	ldw	r2,0(r2)
 4006e2c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 4006e30:	e13ffd17 	ldw	r4,-12(fp)
 4006e34:	40071380 	call	4007138 <strlen>
 4006e38:	10800044 	addi	r2,r2,1
 4006e3c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4006e40:	00000d06 	br	4006e78 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 4006e44:	e0bffc17 	ldw	r2,-16(fp)
 4006e48:	11000217 	ldw	r4,8(r2)
 4006e4c:	e1bffb17 	ldw	r6,-20(fp)
 4006e50:	e17ffd17 	ldw	r5,-12(fp)
 4006e54:	40070c40 	call	40070c4 <memcmp>
 4006e58:	1004c03a 	cmpne	r2,r2,zero
 4006e5c:	1000031e 	bne	r2,zero,4006e6c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 4006e60:	e0bffc17 	ldw	r2,-16(fp)
 4006e64:	e0bfff15 	stw	r2,-4(fp)
 4006e68:	00000706 	br	4006e88 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 4006e6c:	e0bffc17 	ldw	r2,-16(fp)
 4006e70:	10800017 	ldw	r2,0(r2)
 4006e74:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 4006e78:	e0fffe17 	ldw	r3,-8(fp)
 4006e7c:	e0bffc17 	ldw	r2,-16(fp)
 4006e80:	10fff01e 	bne	r2,r3,4006e44 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 4006e84:	e03fff15 	stw	zero,-4(fp)
 4006e88:	e0bfff17 	ldw	r2,-4(fp)
}
 4006e8c:	e037883a 	mov	sp,fp
 4006e90:	dfc00117 	ldw	ra,4(sp)
 4006e94:	df000017 	ldw	fp,0(sp)
 4006e98:	dec00204 	addi	sp,sp,8
 4006e9c:	f800283a 	ret

04006ea0 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 4006ea0:	defffa04 	addi	sp,sp,-24
 4006ea4:	dfc00515 	stw	ra,20(sp)
 4006ea8:	df000415 	stw	fp,16(sp)
 4006eac:	df000404 	addi	fp,sp,16
 4006eb0:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 4006eb4:	00810074 	movhi	r2,1025
 4006eb8:	10a52404 	addi	r2,r2,-27504
 4006ebc:	10800017 	ldw	r2,0(r2)
 4006ec0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 4006ec4:	00003306 	br	4006f94 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 4006ec8:	e0bffd17 	ldw	r2,-12(fp)
 4006ecc:	11000217 	ldw	r4,8(r2)
 4006ed0:	40071380 	call	4007138 <strlen>
 4006ed4:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 4006ed8:	e0bffd17 	ldw	r2,-12(fp)
 4006edc:	10c00217 	ldw	r3,8(r2)
 4006ee0:	e0bffc17 	ldw	r2,-16(fp)
 4006ee4:	1885883a 	add	r2,r3,r2
 4006ee8:	10bfffc4 	addi	r2,r2,-1
 4006eec:	10800003 	ldbu	r2,0(r2)
 4006ef0:	10803fcc 	andi	r2,r2,255
 4006ef4:	1080201c 	xori	r2,r2,128
 4006ef8:	10bfe004 	addi	r2,r2,-128
 4006efc:	10800bd8 	cmpnei	r2,r2,47
 4006f00:	1000031e 	bne	r2,zero,4006f10 <alt_find_file+0x70>
    {
      len -= 1;
 4006f04:	e0bffc17 	ldw	r2,-16(fp)
 4006f08:	10bfffc4 	addi	r2,r2,-1
 4006f0c:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 4006f10:	e0bffc17 	ldw	r2,-16(fp)
 4006f14:	1007883a 	mov	r3,r2
 4006f18:	e0bffe17 	ldw	r2,-8(fp)
 4006f1c:	1885883a 	add	r2,r3,r2
 4006f20:	10800003 	ldbu	r2,0(r2)
 4006f24:	10803fcc 	andi	r2,r2,255
 4006f28:	1080201c 	xori	r2,r2,128
 4006f2c:	10bfe004 	addi	r2,r2,-128
 4006f30:	10800be0 	cmpeqi	r2,r2,47
 4006f34:	10000a1e 	bne	r2,zero,4006f60 <alt_find_file+0xc0>
 4006f38:	e0bffc17 	ldw	r2,-16(fp)
 4006f3c:	1007883a 	mov	r3,r2
 4006f40:	e0bffe17 	ldw	r2,-8(fp)
 4006f44:	1885883a 	add	r2,r3,r2
 4006f48:	10800003 	ldbu	r2,0(r2)
 4006f4c:	10803fcc 	andi	r2,r2,255
 4006f50:	1080201c 	xori	r2,r2,128
 4006f54:	10bfe004 	addi	r2,r2,-128
 4006f58:	1004c03a 	cmpne	r2,r2,zero
 4006f5c:	10000a1e 	bne	r2,zero,4006f88 <alt_find_file+0xe8>
 4006f60:	e0bffd17 	ldw	r2,-12(fp)
 4006f64:	11000217 	ldw	r4,8(r2)
 4006f68:	e1bffc17 	ldw	r6,-16(fp)
 4006f6c:	e17ffe17 	ldw	r5,-8(fp)
 4006f70:	40070c40 	call	40070c4 <memcmp>
 4006f74:	1004c03a 	cmpne	r2,r2,zero
 4006f78:	1000031e 	bne	r2,zero,4006f88 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 4006f7c:	e0bffd17 	ldw	r2,-12(fp)
 4006f80:	e0bfff15 	stw	r2,-4(fp)
 4006f84:	00000806 	br	4006fa8 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 4006f88:	e0bffd17 	ldw	r2,-12(fp)
 4006f8c:	10800017 	ldw	r2,0(r2)
 4006f90:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 4006f94:	00c10074 	movhi	r3,1025
 4006f98:	18e52404 	addi	r3,r3,-27504
 4006f9c:	e0bffd17 	ldw	r2,-12(fp)
 4006fa0:	10ffc91e 	bne	r2,r3,4006ec8 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 4006fa4:	e03fff15 	stw	zero,-4(fp)
 4006fa8:	e0bfff17 	ldw	r2,-4(fp)
}
 4006fac:	e037883a 	mov	sp,fp
 4006fb0:	dfc00117 	ldw	ra,4(sp)
 4006fb4:	df000017 	ldw	fp,0(sp)
 4006fb8:	dec00204 	addi	sp,sp,8
 4006fbc:	f800283a 	ret

04006fc0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 4006fc0:	defffc04 	addi	sp,sp,-16
 4006fc4:	df000315 	stw	fp,12(sp)
 4006fc8:	df000304 	addi	fp,sp,12
 4006fcc:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 4006fd0:	00bffa04 	movi	r2,-24
 4006fd4:	e0bffd15 	stw	r2,-12(fp)
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 4006fd8:	e03ffe15 	stw	zero,-8(fp)
 4006fdc:	00001e06 	br	4007058 <alt_get_fd+0x98>
  {
    if (!alt_fd_list[i].dev)
 4006fe0:	e0bffe17 	ldw	r2,-8(fp)
 4006fe4:	00c10074 	movhi	r3,1025
 4006fe8:	18e3c404 	addi	r3,r3,-28912
 4006fec:	10800324 	muli	r2,r2,12
 4006ff0:	10c5883a 	add	r2,r2,r3
 4006ff4:	10800017 	ldw	r2,0(r2)
 4006ff8:	1004c03a 	cmpne	r2,r2,zero
 4006ffc:	1000131e 	bne	r2,zero,400704c <alt_get_fd+0x8c>
    {
      alt_fd_list[i].dev = dev;
 4007000:	e0bffe17 	ldw	r2,-8(fp)
 4007004:	00c10074 	movhi	r3,1025
 4007008:	18e3c404 	addi	r3,r3,-28912
 400700c:	10800324 	muli	r2,r2,12
 4007010:	10c7883a 	add	r3,r2,r3
 4007014:	e0bfff17 	ldw	r2,-4(fp)
 4007018:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 400701c:	00810074 	movhi	r2,1025
 4007020:	10a52804 	addi	r2,r2,-27488
 4007024:	10c00017 	ldw	r3,0(r2)
 4007028:	e0bffe17 	ldw	r2,-8(fp)
 400702c:	1880040e 	bge	r3,r2,4007040 <alt_get_fd+0x80>
      {
        alt_max_fd = i;
 4007030:	00c10074 	movhi	r3,1025
 4007034:	18e52804 	addi	r3,r3,-27488
 4007038:	e0bffe17 	ldw	r2,-8(fp)
 400703c:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 4007040:	e0bffe17 	ldw	r2,-8(fp)
 4007044:	e0bffd15 	stw	r2,-12(fp)
      goto alt_get_fd_exit;
 4007048:	00000606 	br	4007064 <alt_get_fd+0xa4>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 400704c:	e0bffe17 	ldw	r2,-8(fp)
 4007050:	10800044 	addi	r2,r2,1
 4007054:	e0bffe15 	stw	r2,-8(fp)
 4007058:	e0bffe17 	ldw	r2,-8(fp)
 400705c:	10800810 	cmplti	r2,r2,32
 4007060:	103fdf1e 	bne	r2,zero,4006fe0 <alt_get_fd+0x20>
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);

  return rc;
 4007064:	e0bffd17 	ldw	r2,-12(fp)
}
 4007068:	e037883a 	mov	sp,fp
 400706c:	df000017 	ldw	fp,0(sp)
 4007070:	dec00104 	addi	sp,sp,4
 4007074:	f800283a 	ret

04007078 <atexit>:
 4007078:	200b883a 	mov	r5,r4
 400707c:	000d883a 	mov	r6,zero
 4007080:	0009883a 	mov	r4,zero
 4007084:	000f883a 	mov	r7,zero
 4007088:	40071ac1 	jmpi	40071ac <__register_exitproc>

0400708c <exit>:
 400708c:	defffe04 	addi	sp,sp,-8
 4007090:	000b883a 	mov	r5,zero
 4007094:	dc000015 	stw	r16,0(sp)
 4007098:	dfc00115 	stw	ra,4(sp)
 400709c:	2021883a 	mov	r16,r4
 40070a0:	40072e40 	call	40072e4 <__call_exitprocs>
 40070a4:	00810074 	movhi	r2,1025
 40070a8:	10a53004 	addi	r2,r2,-27456
 40070ac:	11000017 	ldw	r4,0(r2)
 40070b0:	20800f17 	ldw	r2,60(r4)
 40070b4:	10000126 	beq	r2,zero,40070bc <exit+0x30>
 40070b8:	103ee83a 	callr	r2
 40070bc:	8009883a 	mov	r4,r16
 40070c0:	40076200 	call	4007620 <_exit>

040070c4 <memcmp>:
 40070c4:	00c000c4 	movi	r3,3
 40070c8:	1980032e 	bgeu	r3,r6,40070d8 <memcmp+0x14>
 40070cc:	2144b03a 	or	r2,r4,r5
 40070d0:	10c4703a 	and	r2,r2,r3
 40070d4:	10000f26 	beq	r2,zero,4007114 <memcmp+0x50>
 40070d8:	31ffffc4 	addi	r7,r6,-1
 40070dc:	3000061e 	bne	r6,zero,40070f8 <memcmp+0x34>
 40070e0:	00000a06 	br	400710c <memcmp+0x48>
 40070e4:	39ffffc4 	addi	r7,r7,-1
 40070e8:	00bfffc4 	movi	r2,-1
 40070ec:	21000044 	addi	r4,r4,1
 40070f0:	29400044 	addi	r5,r5,1
 40070f4:	38800526 	beq	r7,r2,400710c <memcmp+0x48>
 40070f8:	20c00003 	ldbu	r3,0(r4)
 40070fc:	28800003 	ldbu	r2,0(r5)
 4007100:	18bff826 	beq	r3,r2,40070e4 <memcmp+0x20>
 4007104:	1885c83a 	sub	r2,r3,r2
 4007108:	f800283a 	ret
 400710c:	0005883a 	mov	r2,zero
 4007110:	f800283a 	ret
 4007114:	180f883a 	mov	r7,r3
 4007118:	20c00017 	ldw	r3,0(r4)
 400711c:	28800017 	ldw	r2,0(r5)
 4007120:	18bfed1e 	bne	r3,r2,40070d8 <memcmp+0x14>
 4007124:	31bfff04 	addi	r6,r6,-4
 4007128:	21000104 	addi	r4,r4,4
 400712c:	29400104 	addi	r5,r5,4
 4007130:	39bff936 	bltu	r7,r6,4007118 <memcmp+0x54>
 4007134:	003fe806 	br	40070d8 <memcmp+0x14>

04007138 <strlen>:
 4007138:	208000cc 	andi	r2,r4,3
 400713c:	2011883a 	mov	r8,r4
 4007140:	1000161e 	bne	r2,zero,400719c <strlen+0x64>
 4007144:	20c00017 	ldw	r3,0(r4)
 4007148:	017fbff4 	movhi	r5,65279
 400714c:	297fbfc4 	addi	r5,r5,-257
 4007150:	01e02074 	movhi	r7,32897
 4007154:	39e02004 	addi	r7,r7,-32640
 4007158:	1945883a 	add	r2,r3,r5
 400715c:	11c4703a 	and	r2,r2,r7
 4007160:	00c6303a 	nor	r3,zero,r3
 4007164:	1886703a 	and	r3,r3,r2
 4007168:	18000c1e 	bne	r3,zero,400719c <strlen+0x64>
 400716c:	280d883a 	mov	r6,r5
 4007170:	380b883a 	mov	r5,r7
 4007174:	21000104 	addi	r4,r4,4
 4007178:	20800017 	ldw	r2,0(r4)
 400717c:	1187883a 	add	r3,r2,r6
 4007180:	1946703a 	and	r3,r3,r5
 4007184:	0084303a 	nor	r2,zero,r2
 4007188:	10c4703a 	and	r2,r2,r3
 400718c:	103ff926 	beq	r2,zero,4007174 <strlen+0x3c>
 4007190:	20800007 	ldb	r2,0(r4)
 4007194:	10000326 	beq	r2,zero,40071a4 <strlen+0x6c>
 4007198:	21000044 	addi	r4,r4,1
 400719c:	20800007 	ldb	r2,0(r4)
 40071a0:	103ffd1e 	bne	r2,zero,4007198 <strlen+0x60>
 40071a4:	2205c83a 	sub	r2,r4,r8
 40071a8:	f800283a 	ret

040071ac <__register_exitproc>:
 40071ac:	defffa04 	addi	sp,sp,-24
 40071b0:	00810074 	movhi	r2,1025
 40071b4:	10a53004 	addi	r2,r2,-27456
 40071b8:	dc000015 	stw	r16,0(sp)
 40071bc:	14000017 	ldw	r16,0(r2)
 40071c0:	dd000415 	stw	r20,16(sp)
 40071c4:	2829883a 	mov	r20,r5
 40071c8:	81405217 	ldw	r5,328(r16)
 40071cc:	dcc00315 	stw	r19,12(sp)
 40071d0:	dc800215 	stw	r18,8(sp)
 40071d4:	dc400115 	stw	r17,4(sp)
 40071d8:	dfc00515 	stw	ra,20(sp)
 40071dc:	2023883a 	mov	r17,r4
 40071e0:	3027883a 	mov	r19,r6
 40071e4:	3825883a 	mov	r18,r7
 40071e8:	28002526 	beq	r5,zero,4007280 <__register_exitproc+0xd4>
 40071ec:	29000117 	ldw	r4,4(r5)
 40071f0:	008007c4 	movi	r2,31
 40071f4:	11002716 	blt	r2,r4,4007294 <__register_exitproc+0xe8>
 40071f8:	8800101e 	bne	r17,zero,400723c <__register_exitproc+0x90>
 40071fc:	2105883a 	add	r2,r4,r4
 4007200:	1085883a 	add	r2,r2,r2
 4007204:	20c00044 	addi	r3,r4,1
 4007208:	1145883a 	add	r2,r2,r5
 400720c:	0009883a 	mov	r4,zero
 4007210:	15000215 	stw	r20,8(r2)
 4007214:	28c00115 	stw	r3,4(r5)
 4007218:	2005883a 	mov	r2,r4
 400721c:	dfc00517 	ldw	ra,20(sp)
 4007220:	dd000417 	ldw	r20,16(sp)
 4007224:	dcc00317 	ldw	r19,12(sp)
 4007228:	dc800217 	ldw	r18,8(sp)
 400722c:	dc400117 	ldw	r17,4(sp)
 4007230:	dc000017 	ldw	r16,0(sp)
 4007234:	dec00604 	addi	sp,sp,24
 4007238:	f800283a 	ret
 400723c:	29802204 	addi	r6,r5,136
 4007240:	00800044 	movi	r2,1
 4007244:	110e983a 	sll	r7,r2,r4
 4007248:	30c04017 	ldw	r3,256(r6)
 400724c:	2105883a 	add	r2,r4,r4
 4007250:	1085883a 	add	r2,r2,r2
 4007254:	1185883a 	add	r2,r2,r6
 4007258:	19c6b03a 	or	r3,r3,r7
 400725c:	14802015 	stw	r18,128(r2)
 4007260:	14c00015 	stw	r19,0(r2)
 4007264:	00800084 	movi	r2,2
 4007268:	30c04015 	stw	r3,256(r6)
 400726c:	88bfe31e 	bne	r17,r2,40071fc <__register_exitproc+0x50>
 4007270:	30804117 	ldw	r2,260(r6)
 4007274:	11c4b03a 	or	r2,r2,r7
 4007278:	30804115 	stw	r2,260(r6)
 400727c:	003fdf06 	br	40071fc <__register_exitproc+0x50>
 4007280:	00810074 	movhi	r2,1025
 4007284:	10a58c04 	addi	r2,r2,-27088
 4007288:	100b883a 	mov	r5,r2
 400728c:	80805215 	stw	r2,328(r16)
 4007290:	003fd606 	br	40071ec <__register_exitproc+0x40>
 4007294:	00800034 	movhi	r2,0
 4007298:	10800004 	addi	r2,r2,0
 400729c:	1000021e 	bne	r2,zero,40072a8 <__register_exitproc+0xfc>
 40072a0:	013fffc4 	movi	r4,-1
 40072a4:	003fdc06 	br	4007218 <__register_exitproc+0x6c>
 40072a8:	01006404 	movi	r4,400
 40072ac:	103ee83a 	callr	r2
 40072b0:	1007883a 	mov	r3,r2
 40072b4:	103ffa26 	beq	r2,zero,40072a0 <__register_exitproc+0xf4>
 40072b8:	80805217 	ldw	r2,328(r16)
 40072bc:	180b883a 	mov	r5,r3
 40072c0:	18000115 	stw	zero,4(r3)
 40072c4:	18800015 	stw	r2,0(r3)
 40072c8:	80c05215 	stw	r3,328(r16)
 40072cc:	18006215 	stw	zero,392(r3)
 40072d0:	18006315 	stw	zero,396(r3)
 40072d4:	0009883a 	mov	r4,zero
 40072d8:	883fc826 	beq	r17,zero,40071fc <__register_exitproc+0x50>
 40072dc:	003fd706 	br	400723c <__register_exitproc+0x90>

040072e0 <register_fini>:
 40072e0:	f800283a 	ret

040072e4 <__call_exitprocs>:
 40072e4:	00810074 	movhi	r2,1025
 40072e8:	10a53004 	addi	r2,r2,-27456
 40072ec:	10800017 	ldw	r2,0(r2)
 40072f0:	defff304 	addi	sp,sp,-52
 40072f4:	df000b15 	stw	fp,44(sp)
 40072f8:	d8800115 	stw	r2,4(sp)
 40072fc:	00800034 	movhi	r2,0
 4007300:	10800004 	addi	r2,r2,0
 4007304:	1005003a 	cmpeq	r2,r2,zero
 4007308:	d8800215 	stw	r2,8(sp)
 400730c:	d8800117 	ldw	r2,4(sp)
 4007310:	dd400815 	stw	r21,32(sp)
 4007314:	dd000715 	stw	r20,28(sp)
 4007318:	10805204 	addi	r2,r2,328
 400731c:	dfc00c15 	stw	ra,48(sp)
 4007320:	ddc00a15 	stw	r23,40(sp)
 4007324:	dd800915 	stw	r22,36(sp)
 4007328:	dcc00615 	stw	r19,24(sp)
 400732c:	dc800515 	stw	r18,20(sp)
 4007330:	dc400415 	stw	r17,16(sp)
 4007334:	dc000315 	stw	r16,12(sp)
 4007338:	282b883a 	mov	r21,r5
 400733c:	2039883a 	mov	fp,r4
 4007340:	d8800015 	stw	r2,0(sp)
 4007344:	2829003a 	cmpeq	r20,r5,zero
 4007348:	d8800117 	ldw	r2,4(sp)
 400734c:	14405217 	ldw	r17,328(r2)
 4007350:	88001026 	beq	r17,zero,4007394 <__call_exitprocs+0xb0>
 4007354:	ddc00017 	ldw	r23,0(sp)
 4007358:	88800117 	ldw	r2,4(r17)
 400735c:	8c802204 	addi	r18,r17,136
 4007360:	143fffc4 	addi	r16,r2,-1
 4007364:	80000916 	blt	r16,zero,400738c <__call_exitprocs+0xa8>
 4007368:	05bfffc4 	movi	r22,-1
 400736c:	a000151e 	bne	r20,zero,40073c4 <__call_exitprocs+0xe0>
 4007370:	8409883a 	add	r4,r16,r16
 4007374:	2105883a 	add	r2,r4,r4
 4007378:	1485883a 	add	r2,r2,r18
 400737c:	10c02017 	ldw	r3,128(r2)
 4007380:	a8c01126 	beq	r21,r3,40073c8 <__call_exitprocs+0xe4>
 4007384:	843fffc4 	addi	r16,r16,-1
 4007388:	85bff81e 	bne	r16,r22,400736c <__call_exitprocs+0x88>
 400738c:	d8800217 	ldw	r2,8(sp)
 4007390:	10003126 	beq	r2,zero,4007458 <__call_exitprocs+0x174>
 4007394:	dfc00c17 	ldw	ra,48(sp)
 4007398:	df000b17 	ldw	fp,44(sp)
 400739c:	ddc00a17 	ldw	r23,40(sp)
 40073a0:	dd800917 	ldw	r22,36(sp)
 40073a4:	dd400817 	ldw	r21,32(sp)
 40073a8:	dd000717 	ldw	r20,28(sp)
 40073ac:	dcc00617 	ldw	r19,24(sp)
 40073b0:	dc800517 	ldw	r18,20(sp)
 40073b4:	dc400417 	ldw	r17,16(sp)
 40073b8:	dc000317 	ldw	r16,12(sp)
 40073bc:	dec00d04 	addi	sp,sp,52
 40073c0:	f800283a 	ret
 40073c4:	8409883a 	add	r4,r16,r16
 40073c8:	88c00117 	ldw	r3,4(r17)
 40073cc:	2105883a 	add	r2,r4,r4
 40073d0:	1445883a 	add	r2,r2,r17
 40073d4:	18ffffc4 	addi	r3,r3,-1
 40073d8:	11800217 	ldw	r6,8(r2)
 40073dc:	1c001526 	beq	r3,r16,4007434 <__call_exitprocs+0x150>
 40073e0:	10000215 	stw	zero,8(r2)
 40073e4:	303fe726 	beq	r6,zero,4007384 <__call_exitprocs+0xa0>
 40073e8:	00c00044 	movi	r3,1
 40073ec:	1c06983a 	sll	r3,r3,r16
 40073f0:	90804017 	ldw	r2,256(r18)
 40073f4:	8cc00117 	ldw	r19,4(r17)
 40073f8:	1884703a 	and	r2,r3,r2
 40073fc:	10001426 	beq	r2,zero,4007450 <__call_exitprocs+0x16c>
 4007400:	90804117 	ldw	r2,260(r18)
 4007404:	1884703a 	and	r2,r3,r2
 4007408:	10000c1e 	bne	r2,zero,400743c <__call_exitprocs+0x158>
 400740c:	2105883a 	add	r2,r4,r4
 4007410:	1485883a 	add	r2,r2,r18
 4007414:	11400017 	ldw	r5,0(r2)
 4007418:	e009883a 	mov	r4,fp
 400741c:	303ee83a 	callr	r6
 4007420:	88800117 	ldw	r2,4(r17)
 4007424:	98bfc81e 	bne	r19,r2,4007348 <__call_exitprocs+0x64>
 4007428:	b8800017 	ldw	r2,0(r23)
 400742c:	147fd526 	beq	r2,r17,4007384 <__call_exitprocs+0xa0>
 4007430:	003fc506 	br	4007348 <__call_exitprocs+0x64>
 4007434:	8c000115 	stw	r16,4(r17)
 4007438:	003fea06 	br	40073e4 <__call_exitprocs+0x100>
 400743c:	2105883a 	add	r2,r4,r4
 4007440:	1485883a 	add	r2,r2,r18
 4007444:	11000017 	ldw	r4,0(r2)
 4007448:	303ee83a 	callr	r6
 400744c:	003ff406 	br	4007420 <__call_exitprocs+0x13c>
 4007450:	303ee83a 	callr	r6
 4007454:	003ff206 	br	4007420 <__call_exitprocs+0x13c>
 4007458:	88800117 	ldw	r2,4(r17)
 400745c:	1000081e 	bne	r2,zero,4007480 <__call_exitprocs+0x19c>
 4007460:	89000017 	ldw	r4,0(r17)
 4007464:	20000726 	beq	r4,zero,4007484 <__call_exitprocs+0x1a0>
 4007468:	b9000015 	stw	r4,0(r23)
 400746c:	8809883a 	mov	r4,r17
 4007470:	00000000 	call	0 <__alt_mem_epcs>
 4007474:	bc400017 	ldw	r17,0(r23)
 4007478:	883fb71e 	bne	r17,zero,4007358 <__call_exitprocs+0x74>
 400747c:	003fc506 	br	4007394 <__call_exitprocs+0xb0>
 4007480:	89000017 	ldw	r4,0(r17)
 4007484:	882f883a 	mov	r23,r17
 4007488:	2023883a 	mov	r17,r4
 400748c:	883fb21e 	bne	r17,zero,4007358 <__call_exitprocs+0x74>
 4007490:	003fc006 	br	4007394 <__call_exitprocs+0xb0>

04007494 <udivmodsi4>:
 4007494:	29001b2e 	bgeu	r5,r4,4007504 <udivmodsi4+0x70>
 4007498:	28001a16 	blt	r5,zero,4007504 <udivmodsi4+0x70>
 400749c:	00800044 	movi	r2,1
 40074a0:	0007883a 	mov	r3,zero
 40074a4:	01c007c4 	movi	r7,31
 40074a8:	00000306 	br	40074b8 <udivmodsi4+0x24>
 40074ac:	19c01326 	beq	r3,r7,40074fc <udivmodsi4+0x68>
 40074b0:	18c00044 	addi	r3,r3,1
 40074b4:	28000416 	blt	r5,zero,40074c8 <udivmodsi4+0x34>
 40074b8:	294b883a 	add	r5,r5,r5
 40074bc:	1085883a 	add	r2,r2,r2
 40074c0:	293ffa36 	bltu	r5,r4,40074ac <udivmodsi4+0x18>
 40074c4:	10000d26 	beq	r2,zero,40074fc <udivmodsi4+0x68>
 40074c8:	0007883a 	mov	r3,zero
 40074cc:	21400236 	bltu	r4,r5,40074d8 <udivmodsi4+0x44>
 40074d0:	2149c83a 	sub	r4,r4,r5
 40074d4:	1886b03a 	or	r3,r3,r2
 40074d8:	1004d07a 	srli	r2,r2,1
 40074dc:	280ad07a 	srli	r5,r5,1
 40074e0:	103ffa1e 	bne	r2,zero,40074cc <udivmodsi4+0x38>
 40074e4:	30000226 	beq	r6,zero,40074f0 <udivmodsi4+0x5c>
 40074e8:	2005883a 	mov	r2,r4
 40074ec:	f800283a 	ret
 40074f0:	1809883a 	mov	r4,r3
 40074f4:	2005883a 	mov	r2,r4
 40074f8:	f800283a 	ret
 40074fc:	0007883a 	mov	r3,zero
 4007500:	003ff806 	br	40074e4 <udivmodsi4+0x50>
 4007504:	00800044 	movi	r2,1
 4007508:	0007883a 	mov	r3,zero
 400750c:	003fef06 	br	40074cc <udivmodsi4+0x38>

04007510 <__divsi3>:
 4007510:	defffe04 	addi	sp,sp,-8
 4007514:	dc000015 	stw	r16,0(sp)
 4007518:	dfc00115 	stw	ra,4(sp)
 400751c:	0021883a 	mov	r16,zero
 4007520:	20000c16 	blt	r4,zero,4007554 <__divsi3+0x44>
 4007524:	000d883a 	mov	r6,zero
 4007528:	28000e16 	blt	r5,zero,4007564 <__divsi3+0x54>
 400752c:	40074940 	call	4007494 <udivmodsi4>
 4007530:	1007883a 	mov	r3,r2
 4007534:	8005003a 	cmpeq	r2,r16,zero
 4007538:	1000011e 	bne	r2,zero,4007540 <__divsi3+0x30>
 400753c:	00c7c83a 	sub	r3,zero,r3
 4007540:	1805883a 	mov	r2,r3
 4007544:	dfc00117 	ldw	ra,4(sp)
 4007548:	dc000017 	ldw	r16,0(sp)
 400754c:	dec00204 	addi	sp,sp,8
 4007550:	f800283a 	ret
 4007554:	0109c83a 	sub	r4,zero,r4
 4007558:	04000044 	movi	r16,1
 400755c:	000d883a 	mov	r6,zero
 4007560:	283ff20e 	bge	r5,zero,400752c <__divsi3+0x1c>
 4007564:	014bc83a 	sub	r5,zero,r5
 4007568:	8021003a 	cmpeq	r16,r16,zero
 400756c:	003fef06 	br	400752c <__divsi3+0x1c>

04007570 <__modsi3>:
 4007570:	deffff04 	addi	sp,sp,-4
 4007574:	dfc00015 	stw	ra,0(sp)
 4007578:	01800044 	movi	r6,1
 400757c:	2807883a 	mov	r3,r5
 4007580:	20000416 	blt	r4,zero,4007594 <__modsi3+0x24>
 4007584:	28000c16 	blt	r5,zero,40075b8 <__modsi3+0x48>
 4007588:	dfc00017 	ldw	ra,0(sp)
 400758c:	dec00104 	addi	sp,sp,4
 4007590:	40074941 	jmpi	4007494 <udivmodsi4>
 4007594:	0109c83a 	sub	r4,zero,r4
 4007598:	28000b16 	blt	r5,zero,40075c8 <__modsi3+0x58>
 400759c:	180b883a 	mov	r5,r3
 40075a0:	01800044 	movi	r6,1
 40075a4:	40074940 	call	4007494 <udivmodsi4>
 40075a8:	0085c83a 	sub	r2,zero,r2
 40075ac:	dfc00017 	ldw	ra,0(sp)
 40075b0:	dec00104 	addi	sp,sp,4
 40075b4:	f800283a 	ret
 40075b8:	014bc83a 	sub	r5,zero,r5
 40075bc:	dfc00017 	ldw	ra,0(sp)
 40075c0:	dec00104 	addi	sp,sp,4
 40075c4:	40074941 	jmpi	4007494 <udivmodsi4>
 40075c8:	0147c83a 	sub	r3,zero,r5
 40075cc:	003ff306 	br	400759c <__modsi3+0x2c>

040075d0 <__udivsi3>:
 40075d0:	000d883a 	mov	r6,zero
 40075d4:	40074941 	jmpi	4007494 <udivmodsi4>

040075d8 <__umodsi3>:
 40075d8:	01800044 	movi	r6,1
 40075dc:	40074941 	jmpi	4007494 <udivmodsi4>

040075e0 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 40075e0:	defffd04 	addi	sp,sp,-12
 40075e4:	df000215 	stw	fp,8(sp)
 40075e8:	df000204 	addi	fp,sp,8
 40075ec:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 40075f0:	e0bfff17 	ldw	r2,-4(fp)
 40075f4:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 40075f8:	e0bffe17 	ldw	r2,-8(fp)
 40075fc:	1005003a 	cmpeq	r2,r2,zero
 4007600:	1000021e 	bne	r2,zero,400760c <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 4007604:	002af070 	cmpltui	zero,zero,43969
 4007608:	00000106 	br	4007610 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 400760c:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 4007610:	e037883a 	mov	sp,fp
 4007614:	df000017 	ldw	fp,0(sp)
 4007618:	dec00104 	addi	sp,sp,4
 400761c:	f800283a 	ret

04007620 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 4007620:	defffd04 	addi	sp,sp,-12
 4007624:	dfc00215 	stw	ra,8(sp)
 4007628:	df000115 	stw	fp,4(sp)
 400762c:	df000104 	addi	fp,sp,4
 4007630:	e13fff15 	stw	r4,-4(fp)
  ALT_OS_STOP();

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 4007634:	e13fff17 	ldw	r4,-4(fp)
 4007638:	40075e00 	call	40075e0 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 400763c:	003fff06 	br	400763c <_exit+0x1c>
 4007640:	040072e0 	cmpeqi	r16,zero,459
